<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>KalmanFilter</title>
  <meta name="description" content="C++ KalmanFilter"/>
  <meta name="keywords" content="C++ KalmanFilter "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppKalmanFilter.htm">KalmanFilter</a></h1>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/CppKalmanFilter.pri</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/CppKalmanFilter.pri" border = "1"><tr><td><code>
INCLUDEPATH += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter<br/>
<br/>
SOURCES += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilter.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystem.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystemfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystemparameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilter.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfiltercalculationelements.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfiltercalculationelementsfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterexample.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperiment.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperimentparameter.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperimentparametertype.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterparameter.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterparameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterparametertype.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfiltertype.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfiltertypes.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystem.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystemfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystemparameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardkalmanfilter.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardkalmanfiltercalculationelements.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardkalmanfilterfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardkalmanfilterparameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystem.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystemfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystemparameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilter.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfiltercalculationelements.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilterfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilterparameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystem.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemfactory.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparameter.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparameters.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparametertype.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemtype.cpp \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemtypes.cpp<br/>
<br/>
HEADERS&nbsp;&nbsp;+= \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilter.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystem.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystemfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystemparameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilter.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfiltercalculationelements.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfiltercalculationelementsfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterexample.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperiment.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperimentparameter.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperimentparametertype.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterparameter.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterparameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfilterparametertype.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfiltertype.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/kalmanfiltertypes.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystem.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystemfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystemparameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardkalmanfilter.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardkalmanfiltercalculationelements.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardkalmanfilterfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardkalmanfilterparameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystem.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystemfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystemparameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilter.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfiltercalculationelements.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilterfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilterparameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystem.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemfactory.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparameter.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparameters.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparametertype.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemtype.h \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/whitenoisesystemtypes.h<br/>
<br/>
OTHER_FILES += \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;../../Classes/CppKalmanFilter/Licence.txt<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/fixedlagsmootherkalmanfilter.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilter.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "fixedlagsmootherkalmanfilter.h"<br/>
<br/>
#include &lt;boost/numeric/ublas/io.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector_proxy.hpp&gt;<br/>
<br/>
#include "matrix.h"<br/>
#include "trace.h"<br/>
#include "standardkalmanfilterfactory.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::kalman::FixedLagSmootherKalmanFilter::FixedLagSmootherKalmanFilter(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FixedLagSmootherKalmanFilterCalculationElements&gt;&amp; calculation,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters)<br/>
&nbsp;&nbsp;: KalmanFilter{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_last_calculation{calculation},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_last_fixed_lag_smoother_calculation{boost::dynamic_pointer_cast&lt;FixedLagSmootherKalmanFilterCalculationElements&gt;(calculation)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_standard_filter{StandardKalmanFilterFactory::Create(DownCast(parameters)-&gt;GetStandardParameters())},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_parameters{DownCast(parameters)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_state_estimates{CreateInitialStates(DownCast(parameters))}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(m_last_fixed_lag_smoother_calculation);<br/>
&nbsp;&nbsp;assert(m_parameters);<br/>
&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(m_state_estimates.size()) == m_parameters-&gt;GetLag() * m_standard_filter-&gt;GetStateSize());<br/>
}<br/>
<br/>
<br/>
const boost::numeric::ublas::vector&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt; ribi::kalman::FixedLagSmootherKalmanFilter::CreateInitialGains(<br/>
&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;const StandardKalmanFilter&amp; filter)<br/>
{<br/>
<br/>
&nbsp;&nbsp;assert(filter.GetStateSize() == boost::numeric_cast&lt;int&gt;(filter.GetLastStandardCalculation()-&gt;GetKalmanGain().size1()));<br/>
&nbsp;&nbsp;assert(filter.GetLastStandardCalculation()-&gt;GetKalmanGain().size1() == filter.GetLastStandardCalculation()-&gt;GetKalmanGain().size2());<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt; v(lag,filter.GetLastStandardCalculation()-&gt;GetKalmanGain());<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; ribi::kalman::FixedLagSmootherKalmanFilter::CreateComplexInitialStates(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const FixedLagSmootherKalmanFilterParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; v(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetLag(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetStandardParameters()-&gt;GetInitialStateEstimate());<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt;<br/>
&nbsp;&nbsp;ribi::kalman::FixedLagSmootherKalmanFilter::CreateComplexTermA(<br/>
&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;const int state_size)<br/>
{<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;assert(lag &gt; 0 &amp;&amp; "Term A is not needed for a lag of zero");<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt; v(lag);<br/>
<br/>
&nbsp;&nbsp;v[0] = boost::numeric::ublas::identity_matrix&lt;double&gt;(state_size);<br/>
&nbsp;&nbsp;for (int i=1; i!=lag; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; boost::numeric_cast&lt;int&gt;(v.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v[i] = boost::numeric::ublas::zero_matrix&lt;double&gt;(state_size);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const boost::numeric::ublas::matrix&lt;double&gt;<br/>
&nbsp;&nbsp;ribi::kalman::FixedLagSmootherKalmanFilter::CreateTermA(<br/>
&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;const int state_size)<br/>
{<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;assert(lag &gt; 0 &amp;&amp; "Term A is not needed for a lag of zero");<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::SimplifyVectorOfMatrix(CreateComplexTermA(lag,state_size));<br/>
&nbsp;&nbsp;assert(lag * state_size == boost::numeric_cast&lt;int&gt;(v.size1()));<br/>
&nbsp;&nbsp;assert(&nbsp;&nbsp;1 * state_size == boost::numeric_cast&lt;int&gt;(v.size2()));<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const boost::numeric::ublas::matrix&lt;double &gt;<br/>
&nbsp;&nbsp;ribi::kalman::FixedLagSmootherKalmanFilter::CreateTermB(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int state_size)<br/>
{<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;boost::numeric::ublas::matrix&lt;double&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::SimplifyMatrixOfMatrix(CreateComplexTermB(lag,state_size));<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;assert(lag &gt; 0 &amp;&amp; "Term B is not needed for a lag of zero");<br/>
&nbsp;&nbsp;assert(lag &gt; 1 &amp;&amp; "Term B cannot be calculated for a lag of one");<br/>
&nbsp;&nbsp;assert((lag - 0) * state_size == boost::numeric_cast&lt;int&gt;(v.size1()));<br/>
&nbsp;&nbsp;assert((lag - 1) * state_size == boost::numeric_cast&lt;int&gt;(v.size2()));<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
<br/>
const boost::numeric::ublas::matrix&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt;<br/>
&nbsp;&nbsp;ribi::kalman::FixedLagSmootherKalmanFilter::CreateComplexTermB(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int state_size)<br/>
{<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;assert(lag &gt; 0 &amp;&amp; "Term B is not needed for a lag of zero");<br/>
&nbsp;&nbsp;const int n_cols = lag - 1;<br/>
&nbsp;&nbsp;const int n_rows = lag;<br/>
&nbsp;&nbsp;boost::numeric::ublas::matrix&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt; v(n_rows,n_cols);<br/>
&nbsp;&nbsp;for (int y=0; y!=n_rows; ++y)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int x=0; x!=n_cols; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (y - 1 == x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(y &lt; boost::numeric_cast&lt;int&gt;(v.size1()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(x &lt; boost::numeric_cast&lt;int&gt;(v.size2()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(y,x) = boost::numeric::ublas::identity_matrix&lt;double&gt;(state_size);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(y &lt; boost::numeric_cast&lt;int&gt;(v.size1()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(x &lt; boost::numeric_cast&lt;int&gt;(v.size2()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(y,x) = boost::numeric::ublas::zero_matrix&lt;double&gt;(state_size);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt; ribi::kalman::FixedLagSmootherKalmanFilter::CreateInitialStates(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const FixedLagSmootherKalmanFilterParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;//if (lag == 0) return boost::numeric::ublas::vector&lt;double&gt;();<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; v = Matrix::SimplifyVectorOfVector(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreateComplexInitialStates(parameters));<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;const ribi::kalman::FixedLagSmootherKalmanFilterParameters&gt; ribi::kalman::FixedLagSmootherKalmanFilter::DownCast(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;const auto i = parameters.use_count();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const FixedLagSmootherKalmanFilterParameters&gt; p<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::dynamic_pointer_cast&lt;const FixedLagSmootherKalmanFilterParameters&gt;(parameters);<br/>
&nbsp;&nbsp;assert(p);<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;const auto j = parameters.use_count();<br/>
&nbsp;&nbsp;assert(i + 1 == j);<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
<br/>
const std::string ribi::kalman::FixedLagSmootherKalmanFilter::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.0";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::FixedLagSmootherKalmanFilter::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-03: version 1.0: initial version"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt; ribi::kalman::FixedLagSmootherKalmanFilter::PredictState(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input) const<br/>
{<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;using boost::numeric::ublas::range;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::vector;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::vector_range;<br/>
<br/>
&nbsp;&nbsp;if (m_parameters-&gt;GetLag() == 0) return m_standard_filter-&gt;PredictState(input);<br/>
&nbsp;&nbsp;assert(!m_state_estimates.empty());<br/>
&nbsp;&nbsp;const std::size_t state_size = m_standard_filter-&gt;GetStateSize();<br/>
&nbsp;&nbsp;assert(state_size &lt;= m_state_estimates.size());<br/>
&nbsp;&nbsp;const vector_range&lt;const vector&lt;double&gt; &gt; state(m_state_estimates,range(0,state_size));<br/>
&nbsp;&nbsp;return vector&lt;double&gt;(state);<br/>
}<br/>
<br/>
<br/>
void ribi::kalman::FixedLagSmootherKalmanFilter::SupplyMeasurementAndInput(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; x,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input)<br/>
{<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::vector;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::vector_range;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::range;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::matrix;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::trans;<br/>
<br/>
&nbsp;&nbsp;//Store calculation for KalmanFilterExperiment<br/>
&nbsp;&nbsp;m_last_fixed_lag_smoother_calculation-&gt;Clear();<br/>
&nbsp;&nbsp;m_last_fixed_lag_smoother_calculation-&gt;SetPreviousStateEstimate(this-&gt;GetStandardKalmanFilter()-&gt;GetStateEstimate()); //1<br/>
&nbsp;&nbsp;//m_last_fixed_lag_smoother_calculation-&gt;SetPreviousCovarianceEstimate(this-&gt;GetEstimationErrorCovariance()); //2<br/>
<br/>
&nbsp;&nbsp;const int state_size = m_standard_filter-&gt;GetStateSize();<br/>
&nbsp;&nbsp;assert(state_size == boost::numeric_cast&lt;int&gt;(x.size()));<br/>
&nbsp;&nbsp;assert(state_size == boost::numeric_cast&lt;int&gt;(input.size()));<br/>
&nbsp;&nbsp;m_standard_filter-&gt;SupplyMeasurementAndInput(x,input);<br/>
&nbsp;&nbsp;if (m_parameters-&gt;GetLag() == 0) return;<br/>
&nbsp;&nbsp;const matrix&lt;double&gt; term_a = CreateTermA(m_parameters-&gt;GetLag(),state_size);<br/>
&nbsp;&nbsp;const int lag = m_parameters-&gt;GetLag();<br/>
&nbsp;&nbsp;assert(lag * state_size == boost::numeric_cast&lt;int&gt;(term_a.size1()));<br/>
&nbsp;&nbsp;assert(&nbsp;&nbsp;1 * state_size == boost::numeric_cast&lt;int&gt;(term_a.size2()));<br/>
<br/>
&nbsp;&nbsp;//Get the naive (that is, based on no time lag) prediction<br/>
&nbsp;&nbsp;const vector&lt;double&gt; x_naive = m_standard_filter-&gt;PredictState(input);<br/>
&nbsp;&nbsp;const matrix&lt;double&gt; term_b = CreateTermB(lag,state_size);<br/>
<br/>
&nbsp;&nbsp;//Find P(i) (yes, i can be zero and goes to lag)<br/>
&nbsp;&nbsp;//ps has length lag<br/>
&nbsp;&nbsp;//P(i) has size state_size x state_size<br/>
&nbsp;&nbsp;//P(i) = P . [ [F-KH]^T ]^i (where ^T denotes a transposition, where ^i denotes an exponent to the power of i<br/>
&nbsp;&nbsp;TRACE(m_standard_filter-&gt;GetLastStandardCalculation()-&gt;GetPreviousCovarianceEstimate());<br/>
&nbsp;&nbsp;TRACE(m_standard_filter-&gt;GetLastStandardCalculation()-&gt;GetKalmanGain());<br/>
&nbsp;&nbsp;vector&lt;matrix&lt;double&gt; &gt; ps_complex(lag);<br/>
&nbsp;&nbsp;for (int i=0; i!=lag; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; boost::numeric_cast&lt;int&gt;(ps_complex.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ps_complex[i]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_standard_filter-&gt;GetEstimationErrorCovariance(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::Power(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_standard_filter-&gt;GetParameters()-&gt;GetStateTransition()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Matrix::Prod(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_standard_filter-&gt;GetLastStandardCalculation()-&gt;GetKalmanGain(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_standard_filter-&gt;GetParameters()-&gt;GetObservation()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Find K(i) (yes, i can be zero and goes to lag)<br/>
&nbsp;&nbsp;//ks has length lag<br/>
&nbsp;&nbsp;//K(i) has size state_size x state_size<br/>
&nbsp;&nbsp;//K(i) = P(i) . H^T . [H.P.H^T + R]^-1<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;vector&lt;matrix&lt;double&gt; &gt; ks_complex(lag);<br/>
&nbsp;&nbsp;for (int i=0; i!=lag; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; term<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::MultiProd(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_standard_filter-&gt;GetParameters()-&gt;GetObservation(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_standard_filter-&gt;GetEstimationErrorCovariance(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans(m_standard_filter-&gt;GetParameters()-&gt;GetObservation())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ m_standard_filter-&gt;GetStandardParameters()-&gt;GetEstimatedMeasurementNoise();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (Matrix::CalcDeterminant(term) == 0.0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("Determinant of term in K(i) equals zero");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; boost::numeric_cast&lt;int&gt;(ks_complex.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; boost::numeric_cast&lt;int&gt;(ps_complex.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ks_complex[i]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::MultiProd(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ps_complex[i],<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans(m_standard_filter-&gt;GetParameters()-&gt;GetObservation()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::Inverse(term)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;matrix&lt;double&gt; ks = Matrix::SimplifyVectorOfMatrix(ks_complex);<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;const vector&lt;double&gt; innovation = m_standard_filter-&gt;GetLastStandardCalculation()-&gt;GetInnovation();<br/>
&nbsp;&nbsp;//<br/>
<br/>
&nbsp;&nbsp;const vector&lt;double&gt; new_states_term_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(term_a,x_naive);<br/>
&nbsp;&nbsp;const vector&lt;double&gt; new_states_term_b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(term_b,vector_range&lt;const vector&lt;double&gt; &gt;(m_state_estimates,range(0,m_state_estimates.size()- m_standard_filter-&gt;GetStateSize())));<br/>
&nbsp;&nbsp;//const vector&lt;double&gt; new_states_term_b<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;= Matrix::Prod(term_b,vector_range&lt;const vector&lt;double&gt; &gt;(m_states,range(m_standard_filter-&gt;GetStateSize(),m_states.size())))<br/>
&nbsp;&nbsp;const vector&lt;double&gt; new_states_term_c<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(ks,innovation);<br/>
<br/>
&nbsp;&nbsp;m_state_estimates<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= new_states_term_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ new_states_term_b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ new_states_term_c;<br/>
<br/>
&nbsp;&nbsp;TRACE("Store the calculation hiero");<br/>
&nbsp;&nbsp;m_last_fixed_lag_smoother_calculation-&gt;SetStandardCalculationElement(this-&gt;m_standard_filter-&gt;GetLastStandardCalculation());<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::kalman::FixedLagSmootherKalmanFilter::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;TRACE("Starting ribi::kalman::FixedLagSmootherKalmanFilter::Test()")<br/>
&nbsp;&nbsp;try<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boost::numeric_cast&lt;std::size_t&gt;(-1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Line above must fail, so shouldn't get here");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;catch (boost::numeric::bad_numeric_cast&amp; e)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//OK!<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//CreateTermA<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag = 13;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int state_size = 17;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; v = CreateTermA(lag,state_size);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_rows = lag * state_size;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_cols =&nbsp;&nbsp; 1 * state_size;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size1()) == n_rows);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size2()) == n_cols);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int row = 0; row!=n_rows; ++row)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(row &lt; boost::numeric_cast&lt;int&gt;(v.size1()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int col = 0; col!=n_cols; ++col)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(col &lt; boost::numeric_cast&lt;int&gt;(v.size2()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double expected = row == col ? 1.0 : 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Matrix::IsAboutEqual(v(row,col),expected));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//CreateTermB<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag = 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int state_size = 5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; v = CreateTermB(lag,state_size);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_rows = lag * state_size;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_cols = (lag - 1) * state_size;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size1()) == n_rows);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size2()) == n_cols);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int row = 0; row!=n_rows; ++row)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(row &lt; boost::numeric_cast&lt;int&gt;(v.size1()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int col = 0; col!=n_cols; ++col)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(col &lt; boost::numeric_cast&lt;int&gt;(v.size2()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double expected = row - state_size == col ? 1.0 : 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Matrix::IsAboutEqual(v(row,col),expected));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::kalman::FixedLagSmootherKalmanFilter::Test()")<br/>
}<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/fixedlagsmootherkalmanfilter.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilter.h" border = "1"><tr><td><code>
#ifndef FIXEDLAGSMOOTHERKALMANFILTER_H<br/>
#define FIXEDLAGSMOOTHERKALMANFILTER_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfilter.h"<br/>
#include "standardkalmanfilter.h"<br/>
#include "standardkalmanfilterparameters.h"<br/>
#include "fixedlagsmootherkalmanfilterparameters.h"<br/>
#include "fixedlagsmootherkalmanfiltercalculationelements.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct FixedLagSmootherKalmanFilter : public KalmanFilter<br/>
{<br/>
&nbsp;&nbsp;///The augmented estimation error covariances, that is the estimation error covariance for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::matrix&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp; Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified<br/>
&nbsp;&nbsp;/// [ [ A B ] ]<br/>
&nbsp;&nbsp;/// [ [ C D ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ A B ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ C D ]<br/>
&nbsp;&nbsp;/// [ [ E F ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ E F ]<br/>
&nbsp;&nbsp;/// [ [ G H ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp;[ G H ]<br/>
&nbsp;&nbsp;//const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetEstimationErrorCovariances() const { return m_estimation_error_covariances; }<br/>
<br/>
&nbsp;&nbsp;///Get the Kalman filter last calculation elements<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; GetLastCalculation() const<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return m_last_calculation;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;///The last augmented Kalman gains, that is the gain for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::matrix&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp; Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified<br/>
&nbsp;&nbsp;/// [ [ A B ] ]<br/>
&nbsp;&nbsp;/// [ [ C D ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ A B ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ C D ]<br/>
&nbsp;&nbsp;/// [ [ E F ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ E F ]<br/>
&nbsp;&nbsp;/// [ [ G H ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp;[ G H ]<br/>
&nbsp;&nbsp;//const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetLastGains() const { return m_kalman_gains; }<br/>
<br/>
&nbsp;&nbsp;///The last predicted augmented estimation error covariances,<br/>
&nbsp;&nbsp;///that is the estimation error covariance for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::matrix&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp; Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified<br/>
&nbsp;&nbsp;/// [ [ A B ] ]<br/>
&nbsp;&nbsp;/// [ [ C D ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ A B ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ C D ]<br/>
&nbsp;&nbsp;/// [ [ E F ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ E F ]<br/>
&nbsp;&nbsp;/// [ [ G H ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp;[ G H ]<br/>
&nbsp;&nbsp;//const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetLastPredictedCovariances() const { return m_last_predicted_covariances; }<br/>
<br/>
&nbsp;&nbsp;///The last predicted augmented states<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::vector&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Simplified<br/>
&nbsp;&nbsp;/// [ [ A ] ]<br/>
&nbsp;&nbsp;/// [ [ B ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ A ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ B ]<br/>
&nbsp;&nbsp;/// [ [ C ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ C ]<br/>
&nbsp;&nbsp;/// [ [ D ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp; [ D ]<br/>
&nbsp;&nbsp;//const boost::numeric::ublas::vector&lt;double&gt;&amp; GetLastPredictedStates() const { return m_last_predicted_states; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt; GetParameters() const<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return m_parameters;<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;///The augmented states, that is the state for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::vector&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Simplified<br/>
&nbsp;&nbsp;/// [ [ A ] ]<br/>
&nbsp;&nbsp;/// [ [ B ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ A ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ B ]<br/>
&nbsp;&nbsp;/// [ [ C ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ C ]<br/>
&nbsp;&nbsp;/// [ [ D ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp; [ D ]<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetStateEstimates() const { return m_state_estimates; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const { return KalmanFilterType::fixed_lag_smoother; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Let the filter predict<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; PredictState(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input) const;<br/>
<br/>
&nbsp;&nbsp;///Give the filter a measurement and input, and it will update its predictions<br/>
&nbsp;&nbsp;void SupplyMeasurementAndInput(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; x,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Only a FixedLagSmootherKalmanFilterFactory can create a FixedLagSmootherKalmanFilter<br/>
&nbsp;&nbsp;explicit FixedLagSmootherKalmanFilter(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;FixedLagSmootherKalmanFilterCalculationElements&gt;&amp; calculation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters);<br/>
&nbsp;&nbsp;friend class FixedLagSmootherKalmanFilterFactory;<br/>
<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~FixedLagSmootherKalmanFilter() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(FixedLagSmootherKalmanFilter*);<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(const FixedLagSmootherKalmanFilter*);<br/>
<br/>
&nbsp;&nbsp;///The Kalman filter last calculation elements<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; m_last_calculation;<br/>
<br/>
&nbsp;&nbsp;///The (downcasted) calculation<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FixedLagSmootherKalmanFilterCalculationElements&gt; m_last_fixed_lag_smoother_calculation;<br/>
<br/>
&nbsp;&nbsp;///The standard (unlagged) Kalman filter used<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilter&gt; m_standard_filter;<br/>
<br/>
&nbsp;&nbsp;///The augmented estimation error covariances, that is the estimation error covariance for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::matrix&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp; Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified<br/>
&nbsp;&nbsp;/// [ [ A B ] ]<br/>
&nbsp;&nbsp;/// [ [ C D ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ A B ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ C D ]<br/>
&nbsp;&nbsp;/// [ [ E F ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ E F ]<br/>
&nbsp;&nbsp;/// [ [ G H ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp;[ G H ]<br/>
&nbsp;&nbsp;//boost::numeric::ublas::matrix&lt;double&gt; m_estimation_error_covariances;<br/>
<br/>
&nbsp;&nbsp;///The augmented Kalman gains, that is the gain for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::matrix&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp; Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified<br/>
&nbsp;&nbsp;/// [ [ A B ] ]<br/>
&nbsp;&nbsp;/// [ [ C D ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ A B ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ C D ]<br/>
&nbsp;&nbsp;/// [ [ E F ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ E F ]<br/>
&nbsp;&nbsp;/// [ [ G H ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp;[ G H ]<br/>
&nbsp;&nbsp;//boost::numeric::ublas::matrix&lt;double&gt; m_kalman_gains;<br/>
<br/>
&nbsp;&nbsp;///The augmented Kalman gains, that is the gain for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::matrix&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp; Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified<br/>
&nbsp;&nbsp;/// [ [ A B ] ]<br/>
&nbsp;&nbsp;/// [ [ C D ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ A B ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ C D ]<br/>
&nbsp;&nbsp;/// [ [ E F ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ E F ]<br/>
&nbsp;&nbsp;/// [ [ G H ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp;[ G H ]<br/>
&nbsp;&nbsp;//boost::numeric::ublas::matrix&lt;double&gt; m_last_kalman_gains;<br/>
<br/>
&nbsp;&nbsp;///The last predicted augmented estimation error covariances,<br/>
&nbsp;&nbsp;///that is the estimation error covariance for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::matrix&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp; Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified<br/>
&nbsp;&nbsp;/// [ [ A B ] ]<br/>
&nbsp;&nbsp;/// [ [ C D ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ A B ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ C D ]<br/>
&nbsp;&nbsp;/// [ [ E F ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ E F ]<br/>
&nbsp;&nbsp;/// [ [ G H ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp;[ G H ]<br/>
&nbsp;&nbsp;//boost::numeric::ublas::matrix&lt;double&gt; m_last_predicted_covariances;<br/>
<br/>
&nbsp;&nbsp;///The last predicted augmented states<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::vector&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Simplified<br/>
&nbsp;&nbsp;/// [ [ A ] ]<br/>
&nbsp;&nbsp;/// [ [ B ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ A ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ B ]<br/>
&nbsp;&nbsp;/// [ [ C ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ C ]<br/>
&nbsp;&nbsp;/// [ [ D ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp; [ D ]<br/>
&nbsp;&nbsp;//boost::numeric::ublas::vector&lt;double&gt; m_last_predicted_states;<br/>
<br/>
&nbsp;&nbsp;///The downcasted parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const FixedLagSmootherKalmanFilterParameters&gt; m_parameters;<br/>
<br/>
&nbsp;&nbsp;///The augmented states, that is the state for each lag timestep<br/>
&nbsp;&nbsp;///Use boost::numeric::ublas::vector&lt;double&gt; instead of<br/>
&nbsp;&nbsp;///std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; to allow for matrix operation<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;Complex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Simplified<br/>
&nbsp;&nbsp;/// [ [ A ] ]<br/>
&nbsp;&nbsp;/// [ [ B ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ A ]<br/>
&nbsp;&nbsp;/// [&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ B ]<br/>
&nbsp;&nbsp;/// [ [ C ] ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ C ]<br/>
&nbsp;&nbsp;/// [ [ D ] ]&nbsp;&nbsp; -&gt;&nbsp;&nbsp; [ D ]<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_state_estimates;<br/>
<br/>
&nbsp;&nbsp;static const boost::numeric::ublas::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; CreateComplexInitialStates(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const FixedLagSmootherKalmanFilterParameters&gt;&amp; parameters);<br/>
<br/>
&nbsp;&nbsp;static const boost::numeric::ublas::vector&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt; CreateInitialGains(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const StandardKalmanFilter&amp; filter);<br/>
<br/>
&nbsp;&nbsp;static const boost::numeric::ublas::vector&lt;double&gt; CreateInitialStates(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const FixedLagSmootherKalmanFilterParameters&gt;&amp; parameters);<br/>
<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ I ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 0 ]<br/>
&nbsp;&nbsp;///term_a = [ 0 ], where I denotes an identity matrix with size input.size() x input.size()<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and where 0 denotes a null matrix with size input.size() x input.size()<br/>
&nbsp;&nbsp;///The length of term_a is equal to the lag (3 in this example)<br/>
&nbsp;&nbsp;static const boost::numeric::ublas::vector&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt; CreateComplexTermA(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int state_size);<br/>
<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 0&nbsp;&nbsp;0&nbsp;&nbsp;0]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ I&nbsp;&nbsp;0&nbsp;&nbsp;0]<br/>
&nbsp;&nbsp;///term_b = [ 0&nbsp;&nbsp;I&nbsp;&nbsp;0], where I denotes an identity matrix with size input.size() x input.size()<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and where 0 denotes a null matrix with size input.size() x input.size()<br/>
&nbsp;&nbsp;///The size of term_b is lag x lag (3 in this example)<br/>
&nbsp;&nbsp;static const boost::numeric::ublas::matrix&lt;boost::numeric::ublas::matrix&lt;double&gt; &gt; CreateComplexTermB(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int state_size);<br/>
<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 0 ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ I ]&nbsp;&nbsp;&nbsp;&nbsp;[ 0 0 ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 0 ]&nbsp;&nbsp;&nbsp;&nbsp;[ 0 0 ]<br/>
&nbsp;&nbsp;///term_a = [ 0 ] =&gt; [ 0 0 ],<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;where I denotes an identity matrix with size input.size() x input.size()<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;and where 0 denotes a null matrix with size input.size() x input.size()<br/>
&nbsp;&nbsp;///The size of term_a will be:<br/>
&nbsp;&nbsp;/// - number of rows&nbsp;&nbsp; : lag (3) x input.size() (2) = 6<br/>
&nbsp;&nbsp;/// - number of columns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input.size() (2) = 2<br/>
&nbsp;&nbsp;static const boost::numeric::ublas::matrix&lt;double&gt; CreateTermA(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int state_size);<br/>
<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 0 0 0 0 0 0 ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 0 0 0 0 0 0 ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 1 0 0 0 0 0 ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 0&nbsp;&nbsp;0&nbsp;&nbsp;0]&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 0 0 0 0 ]<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ I&nbsp;&nbsp;0&nbsp;&nbsp;0]&nbsp;&nbsp;&nbsp;&nbsp;[ 0 0 1 0 0 0 ]<br/>
&nbsp;&nbsp;///term_b = [ 0&nbsp;&nbsp;I&nbsp;&nbsp;0] =&gt; [ 0 0 0 1 0 0 ]<br/>
&nbsp;&nbsp;///where I denotes an identity matrix with size input.size() x input.size()<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and where 0 denotes a null matrix with size input.size() x input.size()<br/>
&nbsp;&nbsp;///The size of term_b is lag x lag (3 in this example)<br/>
&nbsp;&nbsp;///The size of term_b will be:<br/>
&nbsp;&nbsp;/// - number of rows&nbsp;&nbsp; : lag (3) x input.size() (2) = 6<br/>
&nbsp;&nbsp;/// - number of columns: lag (3) x input.size() (2) = 6<br/>
&nbsp;&nbsp;static const boost::numeric::ublas::matrix&lt;double&gt; CreateTermB(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int state_size);<br/>
<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;const FixedLagSmootherKalmanFilterParameters&gt; DownCast(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters);<br/>
<br/>
&nbsp;&nbsp;///Obtain the (unlagged) Kalman filter<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilter&gt; GetStandardKalmanFilter() const { return m_standard_filter; }<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;///Test this class<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // FIXEDLAGSMOOTHERKALMANFILTER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "fixedlagsmootherkalmanfiltercalculationelements.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include "standardkalmanfiltercalculationelements.h"<br/>
<br/>
ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::FixedLagSmootherKalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state)<br/>
&nbsp;&nbsp;: KalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;measurement,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predicted_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previous_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updated_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_standard_calculation{}<br/>
{<br/>
&nbsp;&nbsp;//... nothing to check left<br/>
}<br/>
<br/>
void ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::Clear()<br/>
{<br/>
&nbsp;&nbsp;KalmanFilterCalculationElements::Clear();<br/>
<br/>
&nbsp;&nbsp;//Others, e.g.<br/>
&nbsp;&nbsp;//m_updated_covariance = boost::numeric::ublas::matrix&lt;double&gt;();<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::KalmanFilterCalculationElements&gt; ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::Clone() const<br/>
{<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; p;<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
<br/>
bool ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::IsComplete() const<br/>
{<br/>
&nbsp;&nbsp;const std::size_t sz = GetMeasurement().size();<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sz != 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Others, e.g.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&amp;&amp; sz == m_innovation.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&amp;&amp; sz == m_innovation_covariance.size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&amp;&amp; sz == m_innovation_covariance.size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&amp;&amp; sz == m_innovation_covariance.size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetMeasurement().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetPredictedState().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetPreviousState().size();<br/>
}<br/>
<br/>
void ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::SetStandardCalculationElement(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterCalculationElements&gt;&amp; standard_calculation)<br/>
{<br/>
&nbsp;&nbsp;assert(!m_standard_calculation);<br/>
&nbsp;&nbsp;assert(standard_calculation);<br/>
&nbsp;&nbsp;m_standard_calculation = standard_calculation;<br/>
&nbsp;&nbsp;assert(m_standard_calculation);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.h" border = "1"><tr><td><code>
#ifndef FIXEDLAGSMOOTHERKALMANFILTERCALCULATIONELEMENTS_H<br/>
#define FIXEDLAGSMOOTHERKALMANFILTERCALCULATIONELEMENTS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfiltercalculationelements.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct StandardKalmanFilterCalculationElements;<br/>
<br/>
struct FixedLagSmootherKalmanFilterCalculationElements : public KalmanFilterCalculationElements<br/>
{<br/>
&nbsp;&nbsp;explicit FixedLagSmootherKalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state = boost::numeric::ublas::vector&lt;double&gt;());<br/>
<br/>
&nbsp;&nbsp;///Clear the calculation, will set IsComplete to false<br/>
&nbsp;&nbsp;void Clear();<br/>
<br/>
&nbsp;&nbsp;///Produce a deep copy of the derived class<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; Clone() const;<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const { return KalmanFilterType::fixed_lag_smoother; }<br/>
<br/>
&nbsp;&nbsp;///Checks if the state is complete and valid<br/>
&nbsp;&nbsp;bool IsComplete() const;<br/>
<br/>
&nbsp;&nbsp;void SetStandardCalculationElement(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterCalculationElements&gt;&amp; standard_calculation);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;const StandardKalmanFilterCalculationElements&gt; m_standard_calculation;<br/>
<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~FixedLagSmootherKalmanFilterCalculationElements() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(FixedLagSmootherKalmanFilterCalculationElements*);<br/>
<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // FIXEDLAGSMOOTHERKALMANFILTERCALCULATIONELEMENTS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "fixedlagsmootherkalmanfilterfactory.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::FixedLagSmootherKalmanFilter&gt; ribi::kalman::FixedLagSmootherKalmanFilterFactory::Create(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;assert(parameters-&gt;GetType() == KalmanFilterType::fixed_lag_smoother);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FixedLagSmootherKalmanFilterCalculationElements&gt; calculation {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new FixedLagSmootherKalmanFilterCalculationElements<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;assert(calculation);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FixedLagSmootherKalmanFilter&gt; kalman_filter {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new FixedLagSmootherKalmanFilter(calculation,parameters)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(kalman_filter);<br/>
&nbsp;&nbsp;assert(kalman_filter-&gt;GetType() == KalmanFilterType::fixed_lag_smoother);<br/>
&nbsp;&nbsp;return kalman_filter;<br/>
}<br/>
<br/>
<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.h" border = "1"><tr><td><code>
#ifndef FIXEDLAGSMOOTHERKALMANFILTERFACTORY_H<br/>
#define FIXEDLAGSMOOTHERKALMANFILTERFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "fixedlagsmootherkalmanfilter.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Factory for FixedLagSmootherKalmanFilter<br/>
struct FixedLagSmootherKalmanFilterFactory<br/>
{<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;FixedLagSmootherKalmanFilter&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // FIXEDLAGSMOOTHERKALMANFILTERFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "fixedlagsmootherkalmanfilterparameters.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include "standardkalmanfilterparameters.h"<br/>
<br/>
ribi::kalman::FixedLagSmootherKalmanFilterParameters::FixedLagSmootherKalmanFilterParameters(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterParameters&gt;&amp; standard_parameters,<br/>
&nbsp;&nbsp;const int lag)<br/>
&nbsp;&nbsp;: KalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetControl(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetInitialStateEstimate(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetObservation(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetStateTransition()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_lag{lag},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_standard_parameters{standard_parameters}<br/>
{<br/>
&nbsp;&nbsp;assert(lag &gt;= 0);<br/>
&nbsp;&nbsp;assert(m_standard_parameters);<br/>
}<br/>
<br/>
bool ribi::kalman::FixedLagSmootherKalmanFilterParameters::HasParameterType(const KalmanFilterParameterType type)<br/>
{<br/>
&nbsp;&nbsp;return StandardKalmanFilterParameters::HasParameterType(type);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.h" border = "1"><tr><td><code>
#ifndef FIXEDLAGSMOOTHERKALMANFILTERPARAMETERS_H<br/>
#define FIXEDLAGSMOOTHERKALMANFILTERPARAMETERS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfilterparameters.h"<br/>
#include "kalmanfiltertype.h"<br/>
#include "standardkalmanfilterparameters.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct FixedLagSmootherKalmanFilterParameters : public KalmanFilterParameters<br/>
{<br/>
&nbsp;&nbsp;explicit FixedLagSmootherKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterParameters&gt;&amp; standard_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag);<br/>
<br/>
&nbsp;&nbsp;///Obtain the lag in timesteps<br/>
&nbsp;&nbsp;int GetLag() const { return m_lag; }<br/>
<br/>
&nbsp;&nbsp;///The parameters from a standard Kalman filter<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; GetStandardParameters() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_standard_parameters; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const { return KalmanFilterType::fixed_lag_smoother; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Check if this parameter set has a certain type of KalmanFilterParameter<br/>
&nbsp;&nbsp;static bool HasParameterType(const KalmanFilterParameterType type);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~FixedLagSmootherKalmanFilterParameters() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(FixedLagSmootherKalmanFilterParameters*);<br/>
<br/>
&nbsp;&nbsp;///The lag in timesteps<br/>
&nbsp;&nbsp;const int m_lag;<br/>
<br/>
&nbsp;&nbsp;///The parameters from a standard Kalman filter<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; m_standard_parameters;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // FIXEDLAGSMOOTHERKALMANFILTERPARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/gapsfilledwhitenoisesystem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/gapsfilledwhitenoisesystem.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "gapsfilledwhitenoisesystem.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
<br/>
#include "matrix.h"<br/>
#include "trace.h"<br/>
#include "gapsfilledwhitenoisesystem.h"<br/>
#include "gapsfilledwhitenoisesystemfactory.h"<br/>
#include "gapsfilledwhitenoisesystemparameters.h"<br/>
<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::kalman::GapsFilledWhiteNoiseSystem::GapsFilledWhiteNoiseSystem(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; parameters)<br/>
&nbsp;&nbsp;: WhiteNoiseSystem{parameters},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_last_measument{parameters-&gt;GetInitialState().size(),0.0},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_parameters{boost::dynamic_pointer_cast&lt;const GapsFilledWhiteNoiseSystemParameters&gt;(parameters)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_timestep{0}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;assert(m_parameters);<br/>
&nbsp;&nbsp;//Check measuring frequecies<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const auto v = m_parameters-&gt;GetMeasurementFrequency();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::size_t sz = v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (std::size_t i=0; i!=sz; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int x = v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(x &gt;= 1 &amp;&amp; "At least one out of one measurements is a real measurement");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
const std::string ribi::kalman::GapsFilledWhiteNoiseSystem::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.0";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::GapsFilledWhiteNoiseSystem::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-06-25: version 1.0: initial version"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
void ribi::kalman::GapsFilledWhiteNoiseSystem::GoToNextState(const boost::numeric::ublas::vector&lt;double&gt;&amp; input)<br/>
{<br/>
&nbsp;&nbsp;//Standard transition<br/>
&nbsp;&nbsp;assert(input.size() == GetCurrentState().size());<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetStateTransition().size1() == GetCurrentState().size());<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetStateTransition().size2() == GetCurrentState().size());<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetControl().size1() == input.size());<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetControl().size2() == input.size());<br/>
<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; new_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(m_parameters-&gt;GetStateTransition(),GetCurrentState())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ Matrix::Prod(m_parameters-&gt;GetControl(),input);<br/>
&nbsp;&nbsp;//Add process noise<br/>
&nbsp;&nbsp;const auto sz = new_state.size();<br/>
&nbsp;&nbsp;assert(new_state.size() == m_parameters-&gt;GetProcessNoise().size());<br/>
&nbsp;&nbsp;for (std::size_t i = 0; i!=sz; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new_state(i) = GetRandomNormal(new_state(i),m_parameters-&gt;GetProcessNoise()(i));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;SetNewCurrentState(new_state);<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt; ribi::kalman::GapsFilledWhiteNoiseSystem::Measure() const<br/>
{<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;int&gt;&amp; fs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= this-&gt;GetGapsFilledWhiteNoiseSystemParameters()-&gt;GetMeasurementFrequency();<br/>
<br/>
&nbsp;&nbsp;assert(fs.size() == m_last_measument.size());<br/>
&nbsp;&nbsp;assert(fs.size() == GetCurrentState().size());<br/>
&nbsp;&nbsp;assert(fs.size() == m_parameters-&gt;GetMeasurementNoise().size());<br/>
<br/>
&nbsp;&nbsp;const std::size_t n_states = fs.size();<br/>
&nbsp;&nbsp;for (std::size_t state=0; state!=n_states; ++state)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(state &lt; fs.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int f = fs[state];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f &gt;= 1);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (m_timestep % f == 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(state &lt; m_last_measument.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(state &lt; GetCurrentState().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(state &lt; m_parameters-&gt;GetMeasurementNoise().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_last_measument(state) = GetRandomNormal(GetCurrentState()(state),m_parameters-&gt;GetMeasurementNoise()(state));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Should get here<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;++m_timestep;<br/>
<br/>
&nbsp;&nbsp;return m_last_measument;<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt;&amp;<br/>
&nbsp;&nbsp;ribi::kalman::GapsFilledWhiteNoiseSystem::PeekAtRealState() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return this-&gt;GetCurrentState();<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::kalman::GapsFilledWhiteNoiseSystem::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::kalman::GapsFilledWhiteNoiseSystem::Test()")<br/>
&nbsp;&nbsp;//Check if measurements are indeed lagged:<br/>
&nbsp;&nbsp;//The system's real value should update immediatly, but this fresh measurement<br/>
&nbsp;&nbsp;//must only be accessible after lag timesteps<br/>
&nbsp;&nbsp;//Context: measuring the position of an object with constant velocity<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int f = 5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;GapsFilledWhiteNoiseSystem&gt; my_system<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= GapsFilledWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateMatrix(1,1, { 1.0 } ), //control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateVector(&nbsp;&nbsp;&nbsp;&nbsp; { 0.0 } ), //initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateVector(&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp; f } ), //measurement frequencies<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateVector(&nbsp;&nbsp;&nbsp;&nbsp; { 0.0000001 } ), //real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateVector(&nbsp;&nbsp;&nbsp;&nbsp; { 0.0000001 } ), //real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateMatrix(1,1, { 1.0 } )&nbsp;&nbsp;//state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(my_system);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Context: airhockey puck<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; input = Matrix::CreateVector( { 1.0 } );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!= 3*f; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; measurements = my_system-&gt;Measure();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!measurements.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(measurements.size() == 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(measurements.size() == my_system-&gt;PeekAtRealState().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double expected = static_cast&lt;double&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double measured = measurements(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double real = my_system-&gt;PeekAtRealState()(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Matrix::IsAboutEqual(real,expected));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i % f == 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Matrix::IsAboutEqual(measured,expected));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!Matrix::IsAboutEqual(measured,expected));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_system-&gt;GoToNextState(input);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::kalman::GapsFilledWhiteNoiseSystem::Test()")<br/>
}<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/gapsfilledwhitenoisesystem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/gapsfilledwhitenoisesystem.h" border = "1"><tr><td><code>
#ifndef GAPSFILLEDWHITENOISESYSTEM_H<br/>
#define GAPSFILLEDWHITENOISESYSTEM_H<br/>
<br/>
#include &lt;queue&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "whitenoisesystem.h"<br/>
#include "whitenoisesystemparameters.h"<br/>
#include "gapsfilledwhitenoisesystemparameters.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///A gaps-filled white noise system is a system that does not have a measurement every timestep.<br/>
///Instead, it has for example 1 measurement and then 4 non-measurements (which is a gap of 5)<br/>
///During the 4 non-measurements the 1 measurement is repeated<br/>
struct GapsFilledWhiteNoiseSystem : public WhiteNoiseSystem<br/>
{<br/>
&nbsp;&nbsp;///Obtain the gaps-filled white noise system parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const GapsFilledWhiteNoiseSystemParameters&gt;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;GetGapsFilledWhiteNoiseSystemParameters() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return m_parameters; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the type as an enum<br/>
&nbsp;&nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::gaps_filled; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state<br/>
&nbsp;&nbsp;void GoToNextState(const boost::numeric::ublas::vector&lt;double&gt;&amp; input);<br/>
<br/>
&nbsp;&nbsp;///Measure a value from this system with normally distributed noise<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; Measure() const;<br/>
<br/>
&nbsp;&nbsp;///Peek what the real value is<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; PeekAtRealState() const noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///GapsFilledWhiteNoiseSystem must be created with a GapsFilledWhiteNoiseSystemFactory<br/>
&nbsp;&nbsp;explicit GapsFilledWhiteNoiseSystem(const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; white_noise_system_parameters);<br/>
&nbsp;&nbsp;friend class GapsFilledWhiteNoiseSystemFactory;<br/>
<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~GapsFilledWhiteNoiseSystem() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(GapsFilledWhiteNoiseSystem*);<br/>
<br/>
&nbsp;&nbsp;///The last successfull measurement<br/>
&nbsp;&nbsp;mutable boost::numeric::ublas::vector&lt;double&gt; m_last_measument;<br/>
<br/>
&nbsp;&nbsp;///The gaps-filled white noise system parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const GapsFilledWhiteNoiseSystemParameters&gt; m_parameters;<br/>
<br/>
&nbsp;&nbsp;///The current timestep: zero denotes a measurement will be done<br/>
&nbsp;&nbsp;mutable int m_timestep;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;///Test this class<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // GAPSFILLEDWHITENOISESYSTEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/gapsfilledwhitenoisesystemfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/gapsfilledwhitenoisesystemfactory.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "gapsfilledwhitenoisesystemfactory.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::GapsFilledWhiteNoiseSystem&gt; ribi::kalman::GapsFilledWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;int&gt;&amp; measurement_frequency,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt; parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new GapsFilledWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;measurement_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_transition));<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;assert(parameters-&gt;GetType() == WhiteNoiseSystemType::gaps_filled);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;GapsFilledWhiteNoiseSystem&gt; system(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new GapsFilledWhiteNoiseSystem(parameters));<br/>
&nbsp;&nbsp;assert(system);<br/>
&nbsp;&nbsp;assert(system-&gt;GetType() == WhiteNoiseSystemType::gaps_filled);<br/>
&nbsp;&nbsp;return system;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::GapsFilledWhiteNoiseSystem&gt; ribi::kalman::GapsFilledWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystemParameters&gt;&amp; general_parameters)<br/>
{<br/>
&nbsp;&nbsp;assert(general_parameters);<br/>
&nbsp;&nbsp;assert(general_parameters-&gt;GetType() == WhiteNoiseSystemType::gaps_filled);<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;GapsFilledWhiteNoiseSystemParameters&gt; parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::dynamic_pointer_cast&lt;GapsFilledWhiteNoiseSystemParameters&gt;(general_parameters);<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;assert(parameters-&gt;GetType() == WhiteNoiseSystemType::gaps_filled);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;GapsFilledWhiteNoiseSystem&gt; my_system<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetControl(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetInitialState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetMeasurementFrequency(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetMeasurementNoise(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetProcessNoise(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetStateTransition());<br/>
&nbsp;&nbsp;assert(my_system);<br/>
&nbsp;&nbsp;assert(my_system-&gt;GetType() == WhiteNoiseSystemType::gaps_filled);<br/>
<br/>
&nbsp;&nbsp;return my_system;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/gapsfilledwhitenoisesystemfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/gapsfilledwhitenoisesystemfactory.h" border = "1"><tr><td><code>
#ifndef GAPSFILLEDWHITENOISESYSTEMFACTORY_H<br/>
#define GAPSFILLEDWHITENOISESYSTEMFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "gapsfilledwhitenoisesystem.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Factory for GapsFilledWhiteNoiseSystem<br/>
struct GapsFilledWhiteNoiseSystemFactory<br/>
{<br/>
&nbsp;&nbsp;///Create a GapsFilledWhiteNoiseSystem from the loose parameters<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;GapsFilledWhiteNoiseSystem&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;int&gt;&amp; measurement_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition);<br/>
<br/>
&nbsp;&nbsp;///Create a GapsFilledWhiteNoiseSystem from the parameters<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;GapsFilledWhiteNoiseSystem&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystemParameters&gt;&amp; parameters);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // GAPSFILLEDWHITENOISESYSTEMFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/gapsfilledwhitenoisesystemparameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/gapsfilledwhitenoisesystemparameters.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "gapsfilledwhitenoisesystemparameters.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include "standardwhitenoisesystemparameters.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::kalman::GapsFilledWhiteNoiseSystemParameters::GapsFilledWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;int&gt;&amp; measurement_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
&nbsp;&nbsp;: WhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_measurement_frequency{measurement_frequency}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;assert(m_measurement_frequency.size() == initial_state.size());<br/>
&nbsp;&nbsp;//Check measuring frequecies<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const auto v = m_measurement_frequency;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::size_t sz = v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (std::size_t i=0; i!=sz; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int x = v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt; 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(x);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("BREAK");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(x &gt;= 1 &amp;&amp; "At least one out of one measurements is a real measurement");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::kalman::GapsFilledWhiteNoiseSystemParameters::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;}<br/>
}<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/gapsfilledwhitenoisesystemparameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/gapsfilledwhitenoisesystemparameters.h" border = "1"><tr><td><code>
#ifndef GAPSFILLEDWHITENOISESYSTEMPARAMETERS_H<br/>
#define GAPSFILLEDWHITENOISESYSTEMPARAMETERS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "whitenoisesystemparameters.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct GapsFilledWhiteNoiseSystemParameters : public WhiteNoiseSystemParameters<br/>
{<br/>
&nbsp;&nbsp;explicit GapsFilledWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;int&gt;&amp; measurement_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition);<br/>
<br/>
&nbsp;&nbsp;///The number of timesteps after which a real measurement is acquired<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;int&gt;&amp; GetMeasurementFrequency() const noexcept { return m_measurement_frequency; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the type as an enum<br/>
&nbsp;&nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::gaps_filled; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~GapsFilledWhiteNoiseSystemParameters() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(GapsFilledWhiteNoiseSystemParameters*);<br/>
<br/>
&nbsp;&nbsp;///The gaps (in timesteps) is the number of measurements of which only one real measurement is acquired<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;int&gt; m_measurement_frequency;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // GAPSFILLEDWHITENOISESYSTEMPARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilter.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilter.cpp" border = "1"><tr><td><code>
#include "kalmanfilter.h"<br/>
<br/>
const std::string ribi::kalman::KalmanFilter::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.1";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::KalmanFilter::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-06: version 1.0: initial version",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-09-09: version 1.1: removed data members"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilter.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilter.h" border = "1"><tr><td><code>
#ifndef KALMANFILTER_H<br/>
#define KALMANFILTER_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#include "kalmanfiltertype.h"<br/>
#include "kalmanfilterparameters.h"<br/>
#include "kalmanfiltercalculationelements.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Kalman filter base class<br/>
struct KalmanFilter<br/>
{<br/>
&nbsp;&nbsp;KalmanFilter(const KalmanFilter&amp;) = delete;<br/>
&nbsp;&nbsp;KalmanFilter&amp; operator=(const KalmanFilter&amp;) = delete;<br/>
&nbsp;&nbsp;virtual ~KalmanFilter() noexcept {}<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;virtual KalmanFilterType GetType() const = 0;<br/>
<br/>
&nbsp;&nbsp;///Get the Kalman filter last calculation elements<br/>
&nbsp;&nbsp;virtual const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; GetLastCalculation() const = 0;<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter parameters<br/>
&nbsp;&nbsp;virtual const boost::shared_ptr&lt;const KalmanFilterParameters&gt; GetParameters() const = 0;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;virtual void SupplyMeasurementAndInput(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurements,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input) = 0;<br/>
<br/>
&nbsp;&nbsp;protected:<br/>
&nbsp;&nbsp;explicit KalmanFilter() {}<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;///An ABC can only be constructed by derived classes<br/>
&nbsp;&nbsp;explicit KalmanFilter(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt;&amp; calculation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;///The Kalman filter last calculation elements<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; m_last_calculation;<br/>
<br/>
&nbsp;&nbsp;///The Kalman filter parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt; m_parameters;<br/>
&nbsp;&nbsp;*/<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfiltercalculationelements.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfiltercalculationelements.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfiltercalculationelements.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
ribi::kalman::KalmanFilterCalculationElements::KalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state)<br/>
&nbsp;&nbsp;: m_measurement{measurement},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_predicted_state{predicted_state},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_previous_state_estimate{previous_state_estimate},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_updated_state{updated_state}<br/>
{<br/>
&nbsp;&nbsp;//Size may be zero<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;const std::size_t sz = m_measurement.size();<br/>
&nbsp;&nbsp;assert(sz == m_measurement.size());<br/>
&nbsp;&nbsp;assert(sz == m_predicted_state.size());<br/>
&nbsp;&nbsp;assert(sz == m_previous_state_estimate.size());<br/>
&nbsp;&nbsp;assert(sz == m_updated_state.size());<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
void ribi::kalman::KalmanFilterCalculationElements::Clear()<br/>
{<br/>
&nbsp;&nbsp;m_measurement = boost::numeric::ublas::vector&lt;double&gt;();<br/>
&nbsp;&nbsp;m_predicted_state = boost::numeric::ublas::vector&lt;double&gt;();<br/>
&nbsp;&nbsp;m_previous_state_estimate = boost::numeric::ublas::vector&lt;double&gt;();<br/>
&nbsp;&nbsp;m_updated_state = boost::numeric::ublas::vector&lt;double&gt;();<br/>
&nbsp;&nbsp;assert(m_measurement.size() == 0);<br/>
&nbsp;&nbsp;assert(!ribi::kalman::KalmanFilterCalculationElements::IsComplete());<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt;&amp; ribi::kalman::KalmanFilterCalculationElements::GetMeasurement() const<br/>
{<br/>
&nbsp;&nbsp;return m_measurement;<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt;&amp; ribi::kalman::KalmanFilterCalculationElements::GetPredictedState() const<br/>
{<br/>
&nbsp;&nbsp;return m_predicted_state;<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt;&amp; ribi::kalman::KalmanFilterCalculationElements::GetPreviousState() const<br/>
{<br/>
&nbsp;&nbsp;return m_previous_state_estimate;<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt;&amp; ribi::kalman::KalmanFilterCalculationElements::GetUpdatedState() const<br/>
{<br/>
&nbsp;&nbsp;return m_updated_state;<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterCalculationElements::IsComplete() const<br/>
{<br/>
&nbsp;&nbsp;const std::size_t sz = m_measurement.size();<br/>
&nbsp;&nbsp;return sz != 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_measurement.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_predicted_state.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_previous_state_estimate.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_updated_state.size();<br/>
}<br/>
<br/>
<br/>
void ribi::kalman::KalmanFilterCalculationElements::SetMeasurement(const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement)<br/>
{<br/>
&nbsp;&nbsp;assert(m_measurement.empty());<br/>
&nbsp;&nbsp;m_measurement = measurement;<br/>
}<br/>
<br/>
void ribi::kalman::KalmanFilterCalculationElements::SetPredictedState(const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state)<br/>
{<br/>
&nbsp;&nbsp;assert(m_predicted_state.empty());<br/>
&nbsp;&nbsp;m_predicted_state = predicted_state;<br/>
}<br/>
<br/>
void ribi::kalman::KalmanFilterCalculationElements::SetPreviousStateEstimate(const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate)<br/>
{<br/>
&nbsp;&nbsp;assert(m_previous_state_estimate.empty());<br/>
&nbsp;&nbsp;m_previous_state_estimate = previous_state_estimate;<br/>
}<br/>
<br/>
void ribi::kalman::KalmanFilterCalculationElements::SetUpdatedState(const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state)<br/>
{<br/>
&nbsp;&nbsp;assert(m_updated_state.empty());<br/>
&nbsp;&nbsp;m_updated_state = updated_state;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfiltercalculationelements.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfiltercalculationelements.h" border = "1"><tr><td><code>
#ifndef KALMANFILTERCALCULATIONELEMENTS_H<br/>
#define KALMANFILTERCALCULATIONELEMENTS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfiltertype.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///The elements of a steady-state Kalman filter calculation<br/>
struct KalmanFilterCalculationElements<br/>
{<br/>
&nbsp;&nbsp;KalmanFilterCalculationElements(const KalmanFilterCalculationElements&amp;) = delete;<br/>
&nbsp;&nbsp;KalmanFilterCalculationElements&amp; operator=(const KalmanFilterCalculationElements&amp;) = delete;<br/>
<br/>
<br/>
&nbsp;&nbsp;virtual ~KalmanFilterCalculationElements() noexcept {}<br/>
<br/>
&nbsp;&nbsp;///Clear the calculation, will set IsComplete to false<br/>
&nbsp;&nbsp;virtual void Clear();<br/>
<br/>
&nbsp;&nbsp;///Obtain the measurement ('z_n')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetMeasurement() const;<br/>
<br/>
&nbsp;&nbsp;///Get the predicted state ('x_predicted')<br/>
&nbsp;&nbsp;///Is calculated at step 1 of the algorithm:<br/>
&nbsp;&nbsp;///x_predicted = [...] x_n-1 [...]<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetPredictedState() const;<br/>
<br/>
&nbsp;&nbsp;///Obtain the previous_state_estimate ('x_prev')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetPreviousState() const;<br/>
<br/>
&nbsp;&nbsp;///Obtain the updated state ('x_n')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetUpdatedState() const;<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;virtual KalmanFilterType GetType() const = 0;<br/>
<br/>
&nbsp;&nbsp;///Checks if the state is complete and valid<br/>
&nbsp;&nbsp;virtual bool IsComplete() const;<br/>
<br/>
&nbsp;&nbsp;///Set the measurement ('z_n')<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetMeasurement(const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement);<br/>
<br/>
&nbsp;&nbsp;///Set the predicted state ('x_predicted')<br/>
&nbsp;&nbsp;///Is calculated at step 1 of the algorithm:<br/>
&nbsp;&nbsp;///x_predicted = [...] x_n-1 [...]<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetPredictedState(const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state);<br/>
<br/>
&nbsp;&nbsp;///Set the previous_state_estimate ('x_prev'/'x_n-1')<br/>
&nbsp;&nbsp;///Is read at step 1 of the algorithm:<br/>
&nbsp;&nbsp;///x_predicted = [...] x_n-1 [...]<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetPreviousStateEstimate(const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate);<br/>
<br/>
&nbsp;&nbsp;///Set the updated state ('x_n')<br/>
&nbsp;&nbsp;///Is calculated at step 6 of the algorithm:<br/>
&nbsp;&nbsp;///x_n = x_predicted + [...]<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetUpdatedState(const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state);<br/>
<br/>
&nbsp;&nbsp;protected:<br/>
&nbsp;&nbsp;///An ABC can only be constructed by derived classes<br/>
&nbsp;&nbsp;explicit KalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Produce a deep copy of the derived class<br/>
&nbsp;&nbsp;virtual const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; Clone() const = 0;<br/>
&nbsp;&nbsp;friend class KalmanFilterCalculationElementsFactory;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///The measurement ('z_n')<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_measurement;<br/>
<br/>
&nbsp;&nbsp;///The predicted state ('x_predicted')<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_predicted_state;<br/>
<br/>
&nbsp;&nbsp;///The previous_state_estimate ('x_prev')<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_previous_state_estimate;<br/>
<br/>
&nbsp;&nbsp;///The updated state ('x_n')<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_updated_state;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTERCALCULATIONELEMENTS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfiltercalculationelementsfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfiltercalculationelementsfactory.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfiltercalculationelementsfactory.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include "standardkalmanfiltercalculationelements.h"<br/>
#include "steadystatekalmanfiltercalculationelements.h"<br/>
#include "fixedlagsmootherkalmanfiltercalculationelements.h"<br/>
<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::KalmanFilterCalculationElements&gt;<br/>
&nbsp;&nbsp;ribi::kalman::KalmanFilterCalculationElementsFactory::Create(<br/>
&nbsp;&nbsp;const KalmanFilterType type)<br/>
{<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; p;<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterType::fixed_lag_smoother:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.reset(new FixedLagSmootherKalmanFilterCalculationElements);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterType::standard:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.reset(new StandardKalmanFilterCalculationElements);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterType::steady_state:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.reset(new SteadyStateKalmanFilterCalculationElements);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterType::n_types:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented KalmanFilterType");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;assert(p-&gt;GetType() == type);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::KalmanFilterCalculationElements&gt; ribi::kalman::KalmanFilterCalculationElementsFactory::DeepCopy(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt;&amp; original)<br/>
{<br/>
&nbsp;&nbsp;assert(original);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; my_copy = original-&gt;Clone();<br/>
<br/>
&nbsp;&nbsp;assert(my_copy);<br/>
&nbsp;&nbsp;assert(original-&gt;GetType() == my_copy-&gt;GetType());<br/>
<br/>
&nbsp;&nbsp;return my_copy;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfiltercalculationelementsfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfiltercalculationelementsfactory.h" border = "1"><tr><td><code>
#ifndef KALMANFILTERCALCULATIONELEMENTSFACTORY_H<br/>
#define KALMANFILTERCALCULATIONELEMENTSFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfiltercalculationelements.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct KalmanFilterCalculationElementsFactory<br/>
{<br/>
&nbsp;&nbsp;///Create a KalmanFilterCalculationElements of a certain type<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const KalmanFilterType type);<br/>
<br/>
&nbsp;&nbsp;///Deep copy<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; DeepCopy(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt;&amp; elements);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTERCALCULATIONELEMENTSFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterexample.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterexample.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include "kalmanfilterexample.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include &lt;boost/math/constants/constants.hpp&gt;<br/>
<br/>
#include &lt;memory&gt;<br/>
<br/>
<br/>
#include &lt;boost/lexical_cast.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/io.hpp&gt;<br/>
#include "matrix.h"<br/>
#include "trace.h"<br/>
<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::kalman::KalmanFilterExample::KalmanFilterExample(<br/>
&nbsp;&nbsp;const std::string&amp; title,<br/>
&nbsp;&nbsp;const std::string&amp; context,<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; inputs,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt;&amp; kalman_filter_parameters,<br/>
&nbsp;&nbsp;const int number_of_timesteps,<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; state_names,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt;&amp; white_noise_system_parameters)<br/>
&nbsp;&nbsp;: m_context{context},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_inputs{inputs},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_kalman_filter_parameters{kalman_filter_parameters},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_number_of_timesteps{number_of_timesteps},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_state_names{state_names},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_title{title},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_white_noise_system_parameters{white_noise_system_parameters}<br/>
{<br/>
&nbsp;&nbsp;assert(!m_state_names.empty());<br/>
&nbsp;&nbsp;assert(m_state_names.size() == m_inputs.size());<br/>
&nbsp;&nbsp;assert(m_state_names.size() == m_kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(m_state_names.size() == m_white_noise_system_parameters-&gt;GetInitialState().size());<br/>
&nbsp;&nbsp;assert(number_of_timesteps &gt;= 0);<br/>
<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;ribi::kalman::KalmanFilterExample&gt; &gt; ribi::kalman::KalmanFilterExample::CreateExamples()<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;KalmanFilterExample&gt; &gt; v;<br/>
&nbsp;&nbsp;for (int i=0; ; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; p(CreateExample(i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!p) return v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterExample&gt; q(p.release());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(q);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(q.use_count() == 1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(q);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Cannot get here: must return in for loop above");<br/>
}<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample(const int i)<br/>
{<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; p;<br/>
&nbsp;&nbsp;switch (i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0: p = CreateExample0(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1: p = CreateExample1(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 2: p = CreateExample2(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 3: p = CreateExample3(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 4: p = CreateExample4(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 5: p = CreateExample5(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 6: p = CreateExample6(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 7: p = CreateExample7(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 8: p = CreateExample8(); break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: break;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//When p is nullptr, this indicates that there are no more examples<br/>
<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample0()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Constant voltage";<br/>
<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 0.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 0.1 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 0.0001 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 1.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 3.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 1.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, {1.0} );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 1.25 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.1 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.00001 } );<br/>
<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs = { "0.0" };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "V" };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
<br/>
&nbsp;&nbsp;std::stringstream context_stream;<br/>
&nbsp;&nbsp;context_stream<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;h1&gt;" &lt;&lt; title &lt;&lt; "&lt;/h1&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;This is an example from &lt;a href=\"http://greg.czerniak.info/guides/kalman1\"&gt;Greg Czerniak's tutorial&lt;/a&gt;&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;The context is the noisy measurement of a constant voltage.&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;ul&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State names: " &lt;&lt; DisplayAsUblasVector(state_names) &lt;&lt; ": the voltage&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, real: " &lt;&lt; initial_state &lt;&lt; ": just some voltage&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, estimate: " &lt;&lt; initial_state_estimate &lt;&lt; ": set this value off on purpose, to see the Kalman filter converge&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Input: " &lt;&lt; DisplayAsUblasVector(inputs) &lt;&lt; ": the state (that is, the voltage) will not be changed&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Control: " &lt;&lt; control &lt;&lt; ": any input (albeit none) will have no effect&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Observation: " &lt;&lt; observation &lt;&lt; ": the voltage is measured directly (that is: as a voltage)&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State transition: " &lt;&lt; state_transition &lt;&lt; ": the voltage remains constant&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, real: " &lt;&lt; real_measurement_noise &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, estimate: " &lt;&lt; estimated_measurement_noise &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, real: " &lt;&lt; real_process_noise &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, estimated covariance: " &lt;&lt; estimated_process_noise_covariance &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial covariance estimate: " &lt;&lt; initial_covariance_estimate &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/ul&gt;";<br/>
&nbsp;&nbsp;const std::string context = context_stream.str();<br/>
<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample1()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Accelerating car (two states)";<br/>
&nbsp;&nbsp;const int n = 2;<br/>
&nbsp;&nbsp;const double acceleration = 1.0;<br/>
&nbsp;&nbsp;const double measurement_noise = 10.0; //Called 'measnoise'<br/>
&nbsp;&nbsp;const double accelnoise = 0.2; //Called 'accelnoise'<br/>
&nbsp;&nbsp;const double dt = 0.1; //Timestep<br/>
<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 0.0,0.0,0.0,dt } );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 1.0,0.0,0.0,1.0 } );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 10.0,1.0 } );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0,0.0 } );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 10.0 * measurement_noise,0.0,0.0,1000000.0 } );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 1.0,0.0,0.0,0.0 } );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.0 * accelnoise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.0 * accelnoise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.0 * accelnoise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.0 * accelnoise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { measurement_noise, 1000000.0 } );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.5&nbsp;&nbsp;* accelnoise * dt * dt, accelnoise * dt} );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 1.0, 0.0, dt, 1.0 } );<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs = { "0.0", boost::lexical_cast&lt;std::string&gt;(acceleration) };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "x", "v" };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(control.size1() &gt; 0);<br/>
&nbsp;&nbsp;assert(control.size2() &gt; 0);<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetControl(),white_noise_system_parameters-&gt;GetControl()));<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetStateTransition(),white_noise_system_parameters-&gt;GetStateTransition()));<br/>
<br/>
&nbsp;&nbsp;std::stringstream context_stream;<br/>
&nbsp;&nbsp;context_stream<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;h1&gt;" &lt;&lt; title &lt;&lt; "&lt;/h1&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;This is an example from D. Simon's article 'Kalman Filtering', published in 'Embedded Systems Programming' (June 2001).&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;The context is an accelerating car with a GPS and a defect speedometer&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;ul&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State names: " &lt;&lt; DisplayAsUblasVector(state_names) &lt;&lt; ": position (e.g. meter) and velocity (e.g. meter per second)&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, real: " &lt;&lt; initial_state &lt;&lt; ": car starts from standstill&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, estimate: " &lt;&lt; initial_state_estimate &lt;&lt; ": set this value off on purpose, to see the Kalman filter converge&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Input: " &lt;&lt; DisplayAsUblasVector(inputs) &lt;&lt; ": a gas pedal is pushed to a certain acceleration value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Control: " &lt;&lt; control &lt;&lt; ": a gas pedal has an influence on the velocity&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Observation: " &lt;&lt; observation &lt;&lt; ": only observe position, which can be observed directly with a GPS&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State transition: " &lt;&lt; state_transition &lt;&lt; ": the position is increased by a velocity, the velocity stays constant without input&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, real: " &lt;&lt; real_measurement_noise &lt;&lt; ": GPS works, speedometer does not&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, estimate: " &lt;&lt; estimated_measurement_noise &lt;&lt; ": just some pessimistic value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, real: " &lt;&lt; real_process_noise &lt;&lt; ": noise caused by acceleration&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, estimated covariance: " &lt;&lt; estimated_process_noise_covariance &lt;&lt; ": a more pessimistic value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial covariance estimate: " &lt;&lt; initial_covariance_estimate &lt;&lt; ": just a guess&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/ul&gt;";<br/>
&nbsp;&nbsp;const std::string context = context_stream.str();<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample2()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Cannonball";<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;const int n = 4; //Size of all vectors and matrices<br/>
&nbsp;&nbsp;const double dt = 0.1; //Timestep<br/>
&nbsp;&nbsp;const double g = 9.81; //Gravity<br/>
<br/>
&nbsp;&nbsp;const double pi = boost::math::constants::pi&lt;double&gt;();<br/>
&nbsp;&nbsp;const double angle = pi / 4.0; //Radians. 45 degrees = pi / 4.0 radians<br/>
<br/>
<br/>
&nbsp;&nbsp;//Gravity influences y and Vy<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 1.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Just a guess<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 1.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 1.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Initial state estimates are a bit off on purpose<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0, 100.0 * std::cos(angle), 500.0, 100.0 * sin(angle) } );<br/>
<br/>
&nbsp;&nbsp;//Shot from the cannon with velocity 100.0 at an angle<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0, 100.0 * std::cos(angle), 0.0, 100.0 * sin(angle) } );<br/>
<br/>
&nbsp;&nbsp;//Gravity influences position and velocity in the vertical direction<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::lexical_cast&lt;std::string&gt;( 0.0 ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::lexical_cast&lt;std::string&gt;( 0.0 ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::lexical_cast&lt;std::string&gt;( -0.5*g*dt*dt ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::lexical_cast&lt;std::string&gt;( -&nbsp;&nbsp;&nbsp;&nbsp;g*dt&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;//ust an estimation<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.2, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.2, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.2, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 0.2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Can observe all positions and speeds<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 1.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 1.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Due to this being a simulation, one can safely assume no process noise<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 0.0, 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Noise in GPS and speedometer in cannonball<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 30.0, 30.0, 30.0, 30.0 } );<br/>
<br/>
&nbsp;&nbsp;//Due to this being a simulation, put in no process noise<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0, 0.0, 0.0, 0.0 } );<br/>
<br/>
<br/>
&nbsp;&nbsp;//Velocities influence positions<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Beware: appears as transposition of real matrix<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0, 0.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt, 1.0, 0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, 1.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0, dt , 1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "x", "Vx", "y", "Vy" };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
<br/>
&nbsp;&nbsp;std::stringstream context_stream;<br/>
&nbsp;&nbsp;context_stream<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;h1&gt;" &lt;&lt; title &lt;&lt; "&lt;/h1&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;This is an example from &lt;a href=\"http://greg.czerniak.info/guides/kalman1\"&gt;Greg Czerniak's tutorial&lt;/a&gt;&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;The context is a cannonball lauched from a cannon.&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;ul&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State names: " &lt;&lt; DisplayAsUblasVector(state_names) &lt;&lt; ": horizontal position (m), horizontal velocity (m/s), vertical position (m), vertical velocity (m)&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, real: " &lt;&lt; initial_state &lt;&lt; ": the cannon shoots the ball from an angle of 45 degrees at an initial speed of 100 m/s&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, estimate: " &lt;&lt; initial_state_estimate &lt;&lt; ": set this value off on purpose, to see the Kalman filter converge&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Input: " &lt;&lt; DisplayAsUblasVector(inputs) &lt;&lt; ": gravity will change the vertical velocity by 9.81 m/(s^2)&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Control: " &lt;&lt; control &lt;&lt; ": gravity influences the vertical velocity only&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Observation: " &lt;&lt; observation &lt;&lt; ": all states are observed directly with a GPS and an internal speedometer&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State transition: " &lt;&lt; state_transition &lt;&lt; ": positions are increased by their velocities. Velocities remain constant without input&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, real: " &lt;&lt; real_measurement_noise &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, estimate: " &lt;&lt; estimated_measurement_noise &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, real: " &lt;&lt; real_process_noise &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, estimated covariance: " &lt;&lt; estimated_process_noise_covariance &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial covariance estimate: " &lt;&lt; initial_covariance_estimate &lt;&lt; ": just some low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/ul&gt;";<br/>
&nbsp;&nbsp;const std::string context = context_stream.str();<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample3()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Spring";<br/>
&nbsp;&nbsp;const std::string context<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= "&lt;h1&gt;" + title + "&lt;/h1&gt;";<br/>
<br/>
&nbsp;&nbsp;//Use spring system: a mass is lying on a frictionless surface and is connected to two horizontal springs<br/>
&nbsp;&nbsp;const int n = 2; //Size of vectors and matrices<br/>
&nbsp;&nbsp;const double dt = 0.1; //Timestep<br/>
&nbsp;&nbsp;const double k = 1.0; //Spring constant<br/>
&nbsp;&nbsp;const double mass = 1.0; //Mass<br/>
<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;//No input used, so control matrix can be zeroes only<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Just a guess<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Initial state estimates are a bit off on purpose<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { -10.0, -1.0 } );<br/>
<br/>
&nbsp;&nbsp;//From a perfect standstill at a certain position<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 10.0, 0.0 } );<br/>
<br/>
&nbsp;&nbsp;//There is no input supplied<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::lexical_cast&lt;std::string&gt;( 0.0 ),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::lexical_cast&lt;std::string&gt;( 0.0 )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Observe the position of the spring only<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0, 0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Some noise<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 1.0, 1.0 } );<br/>
<br/>
&nbsp;&nbsp;//Simulation, so process noise is zero<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0, 0.0 } );<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "x", "v" };<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //As on paper<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,&nbsp;&nbsp; -dt*k/mass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dt , 0.99<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;));<br/>
<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample4()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Airhockey puck";<br/>
&nbsp;&nbsp;const std::string context<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= "&lt;h1&gt;" + title + "&lt;/h1&gt;";<br/>
<br/>
&nbsp;&nbsp;//Context: airhockey puck with a constant speed<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 1.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 0.0000001 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 0.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 0.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, { 1.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(1,1, {1.0} );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0 } );<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0 } );<br/>
<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::lexical_cast&lt;std::string&gt;( 1.0 )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "x" };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample5()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Accelerating car (3 states)";<br/>
&nbsp;&nbsp;const std::string context<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= "&lt;h1&gt;" + title + "&lt;/h1&gt;";<br/>
<br/>
&nbsp;&nbsp;//Another accelerating car<br/>
&nbsp;&nbsp;const int n = 3;<br/>
&nbsp;&nbsp;const double force =&nbsp;&nbsp;1000.0; //Newton<br/>
&nbsp;&nbsp;const double mass&nbsp;&nbsp;= 10000.0; //kilogram<br/>
&nbsp;&nbsp;const double dt = 0.1; //Timestep<br/>
&nbsp;&nbsp;const double acc = dt * force / mass;<br/>
<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;//A gas pedal only influences acceleration<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,0.0,0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,0.0,0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,0.0,acc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} );<br/>
<br/>
&nbsp;&nbsp;//Just a guess<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,0.0,0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,1.0,0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,0.0,1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} );<br/>
<br/>
&nbsp;&nbsp;//Initial state estimates are a bit off on purpose<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 10.0,1.0,-1.0 } );<br/>
<br/>
&nbsp;&nbsp;//From exact standstill<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0,0.0,0.0 } );<br/>
<br/>
&nbsp;&nbsp;//Only (pessimistic) normal noise in GPS, speedometer and accelerometer<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100.0,&nbsp;&nbsp;0.0,&nbsp;&nbsp;0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,100.0,&nbsp;&nbsp;0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,&nbsp;&nbsp;0.0,100.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} );<br/>
<br/>
&nbsp;&nbsp;//Observe all: GPS, speedometer, accelerometer<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,0.0,0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,1.0,0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,0.0,1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.1,0.0,0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,0.1,0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0,0.0,0.1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} ); //Pessimistic estimate<br/>
<br/>
&nbsp;&nbsp;//Only normal noise in GPS, speedometer has enormous noise as if defect (yet cannot be 0.0)<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 10.0, 10.0, 10.0 } );<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.01, 0.01, 0.01 } );<br/>
<br/>
&nbsp;&nbsp;//x(t+1) = x(t) + dt*v(t) + 0.5*(dt^2)*a(t)<br/>
&nbsp;&nbsp;//v(t+1) =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v(t) +&nbsp;&nbsp;&nbsp;&nbsp; (dt&nbsp;&nbsp;)*a(t)<br/>
&nbsp;&nbsp;//a(t+1) =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a(t)<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ //Shown as on paper<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0,&nbsp;&nbsp;dt, 0.5*dt*dt,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 1.0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dt,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ));<br/>
<br/>
&nbsp;&nbsp;//A gas pedal only influences acceleration<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs = { "0.0", "0.0", "1.0" };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "x", "v", "a" };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(control.size1() &gt; 0);<br/>
&nbsp;&nbsp;assert(control.size2() &gt; 0);<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetControl(),white_noise_system_parameters-&gt;GetControl()));<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetStateTransition(),white_noise_system_parameters-&gt;GetStateTransition()));<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample6()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Exponential decay";<br/>
&nbsp;&nbsp;//One state<br/>
&nbsp;&nbsp;const int n = 1;<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const double epsilon = 0.00000000001;<br/>
&nbsp;&nbsp;//Reach a 10% value after 1000 timesteps with the closed-form solution<br/>
&nbsp;&nbsp;const double gamma = -std::log(0.1)/1000.0;<br/>
&nbsp;&nbsp;//Reach a 10% value after 1000 timesteps with the recurrence equation<br/>
<br/>
&nbsp;&nbsp;const double e = boost::math::constants::e&lt;double&gt;();<br/>
&nbsp;&nbsp;const double tau = std::pow(e,std::log(0.1) / 1000.0);<br/>
<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;//Just a variable name<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "x" };<br/>
<br/>
&nbsp;&nbsp;//Input does not change state<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 0.0 } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { epsilon } );<br/>
<br/>
&nbsp;&nbsp;//From 100%<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 1.0 } );<br/>
<br/>
&nbsp;&nbsp;//Initial state estimate is correct on purpose<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate = initial_state;<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { epsilon } );<br/>
<br/>
&nbsp;&nbsp;//Observe directly<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 1.0 } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { epsilon } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { epsilon } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { epsilon } );<br/>
<br/>
&nbsp;&nbsp;//Reach a 10% value after 1000 timesteps with the recurrence equation<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n, { tau } ));<br/>
<br/>
&nbsp;&nbsp;//Reach a 10% value after 1000 timesteps with the closed-form solution<br/>
&nbsp;&nbsp;const std::string input = std::string("exp(-") + boost::lexical_cast&lt;std::string&gt;(gamma) + "*(t+1))";<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs = { input };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(control.size1() &gt; 0);<br/>
&nbsp;&nbsp;assert(control.size2() &gt; 0);<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetControl(),white_noise_system_parameters-&gt;GetControl()));<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetStateTransition(),white_noise_system_parameters-&gt;GetStateTransition()));<br/>
<br/>
&nbsp;&nbsp;std::stringstream context_stream;<br/>
&nbsp;&nbsp;context_stream<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;h1&gt;" &lt;&lt; title &lt;&lt; "&lt;/h1&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;&amp;nbsp;&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;This is more of a mathematical example. It shows that" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;a recurrence equation and its closed-form solution for exponential" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;decay are equivalent" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The closed-form solution of exponential decay is:" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;f(t) = e^(-gamma*t)" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;Where t is the time step and gamma a constant, which is equal to -ln(0.1)/1000 = 0.0023025850929940454." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;This value of gamma lets the exponential decay reach 10% after 1000 timesteps." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The recurrence equation of exponential decay is:" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;f(t+1) = tau * f(t)" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;Where t is the time step and tau a constant, which is equal to e^(ln(0.1)/1000) = 0.99770006382255327." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;This value of tau lets the exponential decay reach 10% after 1000 timesteps." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The closed-form solution is plotted as the input, the recurrence equation as the state." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;Because the control matrix contains a zero only, the input has no influence on the state." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;For the cleanest look, all noise was set to a low value." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;&amp;nbsp;&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;ul&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State names: " &lt;&lt; DisplayAsUblasVector(state_names) &lt;&lt; ": just a variable without meaning&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, real: " &lt;&lt; initial_state &lt;&lt; ": decay starting from 1.0&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, estimate: " &lt;&lt; initial_state_estimate &lt;&lt; ": set this value to the real value, there is no need to do estimation&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Input: " &lt;&lt; DisplayAsUblasVector(inputs) &lt;&lt; ": the closed-form solution of exponential decay. t must be increased by one timestep, because a Kalman Filter estimates after an update&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Control: " &lt;&lt; control &lt;&lt; ": input must have no effect in changing the state to do a valid comparison&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Observation: " &lt;&lt; observation &lt;&lt; ": the value is observed directly&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State transition: " &lt;&lt; state_transition &lt;&lt; ": the recurrence equation of exponential decay&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, real: " &lt;&lt; real_measurement_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, estimate: " &lt;&lt; estimated_measurement_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, real: " &lt;&lt; real_process_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, estimated covariance: " &lt;&lt; estimated_process_noise_covariance &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial covariance estimate: " &lt;&lt; initial_covariance_estimate &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/ul&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;const std::string context = context_stream.str();<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample7()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Harmonic oscillation (two states)";<br/>
&nbsp;&nbsp;//Two states<br/>
&nbsp;&nbsp;const int n = 2;<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const double e = 0.00000000001;<br/>
&nbsp;&nbsp;//Period of 100 timesteps<br/>
<br/>
&nbsp;&nbsp;const double pi = boost::math::constants::pi&lt;double&gt;();<br/>
&nbsp;&nbsp;const double angular_frequency = 2.0 * pi / 100.0;<br/>
<br/>
&nbsp;&nbsp;//Correct for floating point rounding errors that will increase the amplitude.<br/>
&nbsp;&nbsp;//This value is found by experimenting<br/>
&nbsp;&nbsp;const double correction = 0.998026148;<br/>
<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;//Name of the functions<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "sin", "cos" };<br/>
<br/>
&nbsp;&nbsp;//Input does not change state<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 0.0, 0.0, 0.0, 0.0 } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,e } );<br/>
<br/>
&nbsp;&nbsp;//Correct<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0, 1.0 } );<br/>
<br/>
&nbsp;&nbsp;//Initial state estimate is correct on purpose<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate = initial_state;<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,e } );<br/>
<br/>
&nbsp;&nbsp;//Observe directly<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 1.0,0.0,0.0,1.0 } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,e } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { e,e } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { e,e } );<br/>
<br/>
&nbsp;&nbsp;//Reach a 10% value after 1000 timesteps with the recurrence equation<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;correction, angular_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-angular_frequency,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;correction<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ));<br/>
<br/>
&nbsp;&nbsp;//Reach a 10% value after 1000 timesteps with the closed-form solution<br/>
&nbsp;&nbsp;const std::string input1 = std::string("sin(") + boost::lexical_cast&lt;std::string&gt;(angular_frequency) + "*(t+1))";<br/>
&nbsp;&nbsp;const std::string input2 = std::string("cos(") + boost::lexical_cast&lt;std::string&gt;(angular_frequency) + "*(t+1))";<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs = { input1, input2 };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(control.size1() &gt; 0);<br/>
&nbsp;&nbsp;assert(control.size2() &gt; 0);<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetControl(),white_noise_system_parameters-&gt;GetControl()));<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetStateTransition(),white_noise_system_parameters-&gt;GetStateTransition()));<br/>
<br/>
&nbsp;&nbsp;std::stringstream context_stream;<br/>
&nbsp;&nbsp;context_stream<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;h1&gt;" &lt;&lt; title &lt;&lt; "&lt;/h1&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;&amp;nbsp;&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;This is more of a mathematical example. It shows that" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;a recurrence equation and its closed-form solution for a harmonic" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;oscillation are equivalent" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The closed-form solution of a harmonic oscillation is:" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;code&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "x(t) = sin(angular_frequency*t)&lt;br/&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "v(t) = cos(angular_frequency*t)&lt;br/&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/code&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The period is set to 100 timesteps," &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;so the angular frequency equals 2*pi radian per period = 2 * pi / 100 = 0.0628." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The recurrence equation of a harmonic oscillation is" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;code&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "x(t+1) = c * x(t) + angular_frequency * v(t)&lt;br/&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "v(t+1) = c * v(t) - angular_frequency * x(t)&lt;br/&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/code&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;Where c is a correction close to 1.0, to prevent the amplitude from increasing beyond 1" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;(probably due to rounding errors)" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The closed-form solution is plotted as the input, the recurrence equation as the state." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;Because the control matrix contains a zero only, the input has no influence on the state." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;For the cleanest look, all noise was set to a low value." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;&amp;nbsp;&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;ul&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State names: " &lt;&lt; DisplayAsUblasVector(state_names) &lt;&lt; ": position (e.g. meters) and velocity (e.g. meters per second)&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, real: " &lt;&lt; initial_state &lt;&lt; ": a sine starts at 0.0, a cosine starts at 1.0&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, estimate: " &lt;&lt; initial_state_estimate &lt;&lt; ": set this value to the real value, there is no need to do estimation&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Input: " &lt;&lt; DisplayAsUblasVector(inputs) &lt;&lt; ": the closed-form solution of a harmonic oscillation. t must be increased by one timestep, because a Kalman Filter estimates after an update&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Control: " &lt;&lt; control &lt;&lt; ": input must have no effect in changing the state to do a valid comparison&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Observation: " &lt;&lt; observation &lt;&lt; ": the value is observed directly&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State transition: " &lt;&lt; state_transition &lt;&lt; ": the recurrence equation of a harmonic oscillation&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, real: " &lt;&lt; real_measurement_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, estimate: " &lt;&lt; estimated_measurement_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, real: " &lt;&lt; real_process_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, estimated covariance: " &lt;&lt; estimated_process_noise_covariance &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial covariance estimate: " &lt;&lt; initial_covariance_estimate &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/ul&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;const std::string context = context_stream.str();<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
std::unique_ptr&lt;ribi::kalman::KalmanFilterExample&gt; ribi::kalman::KalmanFilterExample::CreateExample8()<br/>
{<br/>
&nbsp;&nbsp;const std::string title = "Harmonic oscillation (three states)";<br/>
&nbsp;&nbsp;//Two states<br/>
&nbsp;&nbsp;const int n = 3;<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const double e = 0.00000000001;<br/>
&nbsp;&nbsp;//Period of 100 timesteps<br/>
<br/>
&nbsp;&nbsp;const double pi = boost::math::constants::pi&lt;double&gt;();<br/>
&nbsp;&nbsp;const double angular_frequency = 2.0 * pi / 100.0;<br/>
&nbsp;&nbsp;//Correct for floating point rounding errors that will increase the amplitude.<br/>
&nbsp;&nbsp;//This value is found by experimenting<br/>
&nbsp;&nbsp;const double correction = 0.998026148;<br/>
<br/>
&nbsp;&nbsp;const int number_of_timesteps = 1000;<br/>
<br/>
&nbsp;&nbsp;//Name of the functions<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; state_names = { "x", "v", "a" };<br/>
<br/>
&nbsp;&nbsp;//Input does not change state<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n,std::vector&lt;double&gt;(n*n,0.0));<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,0.0,e,0.0,0.0,0.0,e } );<br/>
<br/>
&nbsp;&nbsp;//Correct<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { 0.0, angular_frequency, -angular_frequency*angular_frequency } );<br/>
<br/>
&nbsp;&nbsp;//Initial state estimate is correct on purpose<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; initial_state_estimate = initial_state;<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,0.0,e,0.0,0.0,0.0,e } );<br/>
<br/>
&nbsp;&nbsp;//Observe directly<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { 1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0 } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,0.0,e,0.0,0.0,0.0,e } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { e,e,e } );<br/>
<br/>
&nbsp;&nbsp;//As small as possible<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::CreateVector( { e,e,e } );<br/>
<br/>
&nbsp;&nbsp;//Reach a 10% value after 1000 timesteps with the recurrence equation<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;correction, angular_frequency,angular_frequency*angular_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-angular_frequency,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;correction,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angular_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-angular_frequency*angular_frequency,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ));<br/>
<br/>
&nbsp;&nbsp;//Reach a 10% value after 1000 timesteps with the closed-form solution<br/>
&nbsp;&nbsp;const std::string input1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= std::string("sin(") + boost::lexical_cast&lt;std::string&gt;(angular_frequency) + "*(t+1))";<br/>
&nbsp;&nbsp;const std::string input2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::lexical_cast&lt;std::string&gt;(angular_frequency)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ std::string("*cos(") + boost::lexical_cast&lt;std::string&gt;(angular_frequency)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "*(t+1))";<br/>
&nbsp;&nbsp;const std::string input3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= std::string("-")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ boost::lexical_cast&lt;std::string&gt;(angular_frequency)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ std::string("*")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ boost::lexical_cast&lt;std::string&gt;(angular_frequency)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ std::string("*sin(") + boost::lexical_cast&lt;std::string&gt;(angular_frequency) + "*(t+1))";<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; inputs = { input1, input2, input3 };<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; kalman_filter_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; white_noise_system_parameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;assert(control.size1() &gt; 0);<br/>
&nbsp;&nbsp;assert(control.size2() &gt; 0);<br/>
&nbsp;&nbsp;assert(state_names.size() == inputs.size());<br/>
&nbsp;&nbsp;assert(state_names.size() == kalman_filter_parameters-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;assert(state_names.size() == white_noise_system_parameters-&gt;GetInitialState().size());<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetControl(),white_noise_system_parameters-&gt;GetControl()));<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&gt;GetStateTransition(),white_noise_system_parameters-&gt;GetStateTransition()));<br/>
<br/>
&nbsp;&nbsp;std::stringstream context_stream;<br/>
&nbsp;&nbsp;context_stream<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;h1&gt;" &lt;&lt; title &lt;&lt; "&lt;/h1&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;&amp;nbsp;&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;This is more of a mathematical example. It shows that" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;a recurrence equation and its closed-form solution for a harmonic" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;oscillation (three states) are equivalent" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The closed-form solution of a harmonic oscillation is:" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;code&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "x(t) = sin(angular_frequency*t)&lt;br/&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "v(t) = cos(angular_frequency*t)&lt;br/&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/code&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The period is set to 100 timesteps," &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;so the angular frequency equals 2*pi radian per period = 2 * pi / 100 = 0.0628." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The recurrence equation of a harmonic oscillation is" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;code&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "x(t+1) = c * x(t) + angular_frequency * v(t)&lt;br/&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "v(t+1) = c * v(t) - angular_frequency * x(t)&lt;br/&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/code&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;Where c is a correction close to 1.0, to prevent the amplitude from increasing beyond 1" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;(probably due to rounding errors)" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;The closed-form solution is plotted as the input, the recurrence equation as the state." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;Because the control matrix contains a zero only, the input has no influence on the state." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;For the cleanest look, all noise was set to a low value." &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;p&gt;&amp;nbsp;&lt;/p&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;ul&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State names: " &lt;&lt; DisplayAsUblasVector(state_names) &lt;&lt; ": position (e.g. meters) and velocity (e.g. meters per second)&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, real: " &lt;&lt; initial_state &lt;&lt; ": a sine starts at 0.0, a cosine starts at 1.0&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial state, estimate: " &lt;&lt; initial_state_estimate &lt;&lt; ": set this value to the real value, there is no need to do estimation&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Input: " &lt;&lt; DisplayAsUblasVector(inputs) &lt;&lt; ": the closed-form solution of a harmonic oscillation. t must be increased by one timestep, because a Kalman Filter estimates after an update&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Control: " &lt;&lt; control &lt;&lt; ": input must have no effect in changing the state to do a valid comparison&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Observation: " &lt;&lt; observation &lt;&lt; ": the value is observed directly&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;State transition: " &lt;&lt; state_transition &lt;&lt; ": the recurrence equation of a harmonic oscillation&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, real: " &lt;&lt; real_measurement_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Measurement noise, estimate: " &lt;&lt; estimated_measurement_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, real: " &lt;&lt; real_process_noise &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Process noise, estimated covariance: " &lt;&lt; estimated_process_noise_covariance &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&lt;li&gt;Initial covariance estimate: " &lt;&lt; initial_covariance_estimate &lt;&lt; ": some very low value&lt;/li&gt;" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&lt;/ul&gt;"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;const std::string context = context_stream.str();<br/>
<br/>
&nbsp;&nbsp;std::unique_ptr&lt;KalmanFilterExample&gt; example(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;white_noise_system_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(example);<br/>
&nbsp;&nbsp;return example;<br/>
}<br/>
<br/>
const std::string ribi::kalman::KalmanFilterExample::DisplayAsUblasVector(const std::vector&lt;std::string&gt;&amp; v)<br/>
{<br/>
&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;s &lt;&lt; "[" &lt;&lt; v.size() &lt;&lt; "](";<br/>
&nbsp;&nbsp;for(const std::string&amp; str: v) { s &lt;&lt; str &lt;&lt; ","; }<br/>
&nbsp;&nbsp;//Replace trailing comma with a closing bracket<br/>
&nbsp;&nbsp;std::string str = s.str();<br/>
&nbsp;&nbsp;str[str.size() - 1] = ')';<br/>
&nbsp;&nbsp;return str;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterexample.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterexample.h" border = "1"><tr><td><code>
#ifndef KALMANFILTEREXAMPLE_H<br/>
#define KALMANFILTEREXAMPLE_H<br/>
<br/>
#include &lt;memory&gt;<br/>
#include &lt;vector&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/checked_delete.hpp&gt;<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "standardkalmanfilterparameters.h"<br/>
#include "standardwhitenoisesystemparameters.h"<br/>
<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///KalmanFilterExample contains an example set of variables<br/>
struct KalmanFilterExample<br/>
{<br/>
&nbsp;&nbsp;explicit KalmanFilterExample(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; title,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; inputs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt;&amp; kalman_filter_parameters,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int number_of_timesteps,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt;&amp; white_noise_system_parameters);<br/>
<br/>
&nbsp;&nbsp;static const std::vector&lt;boost::shared_ptr&lt;KalmanFilterExample&gt; &gt; CreateExamples();<br/>
<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample(const int i);<br/>
<br/>
&nbsp;&nbsp;const std::string&amp; GetContext() const { return m_context; }<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; GetInputs() const { return m_inputs; }<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt;&amp; GetKalmanFilterParameters() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_kalman_filter_parameters; }<br/>
&nbsp;&nbsp;int GetNumberOfTimesteps() const { return m_number_of_timesteps; }<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; GetStateNames() const { return m_state_names; }<br/>
&nbsp;&nbsp;const std::string&amp; GetTitle() const { return m_title; }<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt;&amp; GetWhiteNoiseSystemParameters() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return&nbsp;&nbsp;m_white_noise_system_parameters; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~KalmanFilterExample() noexcept {}<br/>
&nbsp;&nbsp;///Can only be deleted by smart pointers: boost::checked_delete and std::unique_ptr<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(KalmanFilterExample*);<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(const KalmanFilterExample*);<br/>
&nbsp;&nbsp;friend struct std::default_delete&lt;KalmanFilterExample&gt;;<br/>
<br/>
&nbsp;&nbsp;const std::string m_context;<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; m_inputs;<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; m_kalman_filter_parameters;<br/>
&nbsp;&nbsp;const int m_number_of_timesteps;<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; m_state_names;<br/>
&nbsp;&nbsp;const std::string m_title;<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; m_white_noise_system_parameters;<br/>
<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample0();<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample1();<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample2();<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample3();<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample4();<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample5();<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample6();<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample7();<br/>
&nbsp;&nbsp;static std::unique_ptr&lt;KalmanFilterExample&gt; CreateExample8();<br/>
<br/>
&nbsp;&nbsp;static const std::string DisplayAsUblasVector(const std::vector&lt;std::string&gt;&amp; v);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTEREXAMPLE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterexperiment.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterexperiment.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfilterexperiment.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
<br/>
#include "kalmanfiltercalculationelementsfactory.h"<br/>
#include "modelfunctionparser.h"<br/>
#include "matrix.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::kalman::KalmanFilterExperiment::KalmanFilterExperiment(<br/>
&nbsp;&nbsp;const int time,<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; input_functions,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilter&gt; m_kalman_filter,<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; state_names,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystem&gt;&amp; m_white_noise_system,<br/>
&nbsp;&nbsp;const std::string&amp; context<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_calculation_elements{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_context{context},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_inputs{ribi::kalman::KalmanFilterExperiment::ParseInput(input_functions,time)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_kalman_filter{m_kalman_filter},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_real_states{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_state_names{state_names},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_white_noise_system{m_white_noise_system}<br/>
{<br/>
&nbsp;&nbsp;assert(m_kalman_filter);<br/>
&nbsp;&nbsp;assert(this-&gt;GetKalmanFilter());<br/>
&nbsp;&nbsp;assert(this-&gt;GetKalmanFilter()-&gt;GetParameters());<br/>
&nbsp;&nbsp;assert(m_white_noise_system);<br/>
&nbsp;&nbsp;assert(this-&gt;GetWhiteNoiseSystem());<br/>
&nbsp;&nbsp;assert(this-&gt;GetWhiteNoiseSystem()-&gt;GetParameters());<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::size_t sz = state_names.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == state_names.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == this-&gt;GetKalmanFilter()-&gt;GetParameters()-&gt;GetControl().size1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == this-&gt;GetKalmanFilter()-&gt;GetParameters()-&gt;GetControl().size2());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == this-&gt;GetKalmanFilter()-&gt;GetParameters()-&gt;GetInitialStateEstimate().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == this-&gt;GetKalmanFilter()-&gt;GetParameters()-&gt;GetObservation().size1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == this-&gt;GetKalmanFilter()-&gt;GetParameters()-&gt;GetObservation().size2());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == this-&gt;GetKalmanFilter()-&gt;GetParameters()-&gt;GetStateTransition().size1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == this-&gt;GetKalmanFilter()-&gt;GetParameters()-&gt;GetStateTransition().size2());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == GetWhiteNoiseSystem()-&gt;GetParameters()-&gt;GetControl().size1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == GetWhiteNoiseSystem()-&gt;GetParameters()-&gt;GetControl().size2());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == GetWhiteNoiseSystem()-&gt;GetParameters()-&gt;GetInitialState().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == GetWhiteNoiseSystem()-&gt;GetParameters()-&gt;GetMeasurementNoise().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == GetWhiteNoiseSystem()-&gt;GetParameters()-&gt;GetProcessNoise().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == GetWhiteNoiseSystem()-&gt;GetParameters()-&gt;GetStateTransition().size1());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == GetWhiteNoiseSystem()-&gt;PeekAtRealState().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(sz == input_functions.size());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreAboutEqual(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_kalman_filter-&gt;GetParameters()-&gt;GetControl(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_white_noise_system-&gt;GetParameters()-&gt;GetControl()));<br/>
&nbsp;&nbsp;assert(Matrix::MatricesAreAboutEqual(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_kalman_filter-&gt;GetParameters()-&gt;GetStateTransition(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_white_noise_system-&gt;GetParameters()-&gt;GetStateTransition()));<br/>
<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;for (int i=0;i!=time;++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Update reality, that is, let the real system (i.e. reality) go to its next state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; boost::numeric_cast&lt;int&gt;(GetInputs().size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input = GetInputs()[i];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//assert(m_white_noise_system-&gt;GetCurrentState().size() == input.size());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_white_noise_system-&gt;GoToNextState(input);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Perform a noisy measurement<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; z_measured = m_white_noise_system-&gt;Measure();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Pass this measurement to the filter<br/>
&nbsp;&nbsp;&nbsp;&nbsp;try<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_kalman_filter-&gt;SupplyMeasurementAndInput(z_measured,input);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;catch (std::runtime_error&amp; e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Happens when innovation covariance becomes degenerate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//(that is, its determinant is zero)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(this-&gt;IsValid() &amp;&amp; "The experiment must end in a valid state");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;catch (...)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Should never get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;AppendRealState(m_white_noise_system-&gt;PeekAtRealState());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Store<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; last_calculation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= KalmanFilterCalculationElementsFactory::DeepCopy(m_kalman_filter-&gt;GetLastCalculation());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_calculation_elements.push_back(last_calculation);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(time == boost::numeric_cast&lt;int&gt;(m_calculation_elements.size()));<br/>
&nbsp;&nbsp;assert(this-&gt;IsValid() &amp;&amp; "The experiment must end in a valid state");<br/>
}<br/>
<br/>
void ribi::kalman::KalmanFilterExperiment::AppendRealState(const boost::numeric::ublas::vector&lt;double&gt;&amp; real_state)<br/>
{<br/>
&nbsp;&nbsp;this-&gt;m_real_states.push_back(real_state);<br/>
}<br/>
<br/>
const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; ribi::kalman::KalmanFilterExperiment::GetMeasuredStates() const<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; v;<br/>
&nbsp;&nbsp;v.reserve(m_calculation_elements.size());<br/>
&nbsp;&nbsp;const auto j = m_calculation_elements.end();<br/>
&nbsp;&nbsp;for (auto i = m_calculation_elements.begin(); i!=j; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back( (*i)-&gt;GetMeasurement() );<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; ribi::kalman::KalmanFilterExperiment::GetPredictedStates() const<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; v;<br/>
&nbsp;&nbsp;v.reserve(m_calculation_elements.size());<br/>
&nbsp;&nbsp;const auto j = m_calculation_elements.end();<br/>
&nbsp;&nbsp;for (auto i = m_calculation_elements.begin(); i!=j; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; element = *i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back( element-&gt;GetPredictedState() );<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterExperiment::IsValid() const<br/>
{<br/>
&nbsp;&nbsp;//Do not count the inputs: these are created at startup of the experiment<br/>
&nbsp;&nbsp;//and always have the maximum size (of n_timesteps)<br/>
&nbsp;&nbsp;//const int n_inputs = boost::numeric_cast&lt;int&gt;(GetInputs().size());<br/>
&nbsp;&nbsp;const int n_real_states = boost::numeric_cast&lt;int&gt;(GetRealStates().size());<br/>
&nbsp;&nbsp;const int n_predicted_states = boost::numeric_cast&lt;int&gt;(GetPredictedStates().size());<br/>
&nbsp;&nbsp;const int n_measured_states = boost::numeric_cast&lt;int&gt;(GetMeasuredStates().size());<br/>
&nbsp;&nbsp;//Does the experiment produce an equal amount of real, estimated and measured states?<br/>
&nbsp;&nbsp;return n_real_states == n_predicted_states<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; n_real_states == n_measured_states;<br/>
}<br/>
<br/>
const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; ribi::kalman::KalmanFilterExperiment::ParseInput(<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; input,<br/>
&nbsp;&nbsp;const int n_timesteps)<br/>
{<br/>
&nbsp;&nbsp;const int n_rows = n_timesteps;<br/>
&nbsp;&nbsp;const int n_cols = input.size();<br/>
&nbsp;&nbsp;std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; m(n_rows,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt;(n_cols));<br/>
<br/>
&nbsp;&nbsp;for (int row=0; row!=n_rows; ++row)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int col=0; col!=n_cols; ++col)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(col &lt; boost::numeric_cast&lt;int&gt;(input.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; s = input[col];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ModelFunctionParser f(s.empty() ? "0.0" : s, "t");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double y = f.Evaluate( boost::numeric_cast&lt;double&gt;(row) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(row &lt; boost::numeric_cast&lt;int&gt;(m.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(col &lt; boost::numeric_cast&lt;int&gt;(m[row].size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m[row](col) = y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch (std::runtime_error&amp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("Unparsable function (will be parsed against 't'):");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Parsing the function should have succeeded, as the GUI takes this out");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(n_timesteps == boost::numeric_cast&lt;int&gt;(m.size()));<br/>
&nbsp;&nbsp;assert(m.empty() || input.size() == m[0].size());<br/>
&nbsp;&nbsp;return m;<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterexperiment.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterexperiment.h" border = "1"><tr><td><code>
#ifndef KALMANFILTEREXPERIMENT_H<br/>
#define KALMANFILTEREXPERIMENT_H<br/>
<br/>
#include &lt;vector&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/checked_delete.hpp&gt;<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
<br/>
#include "steadystatekalmanfilterparameters.h"<br/>
#include "steadystatekalmanfiltercalculationelements.h"<br/>
//#include "standardwhitenoisesystemparameters.h"<br/>
#include "kalmanfilter.h"<br/>
#include "whitenoisesystem.h"<br/>
<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///A KalmanFilterExperiment<br/>
struct KalmanFilterExperiment<br/>
{<br/>
&nbsp;&nbsp;KalmanFilterExperiment(const KalmanFilterExperiment&amp;) = delete;<br/>
&nbsp;&nbsp;KalmanFilterExperiment&amp; operator=(const KalmanFilterExperiment&amp;) = delete;<br/>
<br/>
&nbsp;&nbsp;explicit KalmanFilterExperiment(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int time,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; input,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilter&gt; kalman_filter,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; state_names,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystem&gt;&amp; white_noise_system,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; context = ""<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;///Obtain the calculation elements of each timestep<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; &gt;&amp; GetCalculationElements() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_calculation_elements; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the HTML description of the context of this experiment<br/>
&nbsp;&nbsp;const std::string&amp; GetContext() const { return m_context; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the predicted states<br/>
&nbsp;&nbsp;///The states are stored as a chronological collection (the std::vector) of states (the ublas::vector)<br/>
&nbsp;&nbsp;const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; GetPredictedStates() const;<br/>
<br/>
&nbsp;&nbsp;///Obtain the inputs of each timestep<br/>
&nbsp;&nbsp;///The states are stored as a chronological collection (the std::vector) of inputs (the ublas::vector)<br/>
&nbsp;&nbsp;const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt;&amp; GetInputs() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_inputs; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilter&gt;&amp; GetKalmanFilter() const { return m_kalman_filter; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the measured states, that is, measured with noise<br/>
&nbsp;&nbsp;///The states are stored as a chronological collection (the std::vector) of states (the ublas::vector)<br/>
&nbsp;&nbsp;const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; GetMeasuredStates() const;<br/>
<br/>
&nbsp;&nbsp;///Obtain the real states, that is, the values that would be measured without noise<br/>
&nbsp;&nbsp;///The states are stored as a chronological collection (the std::vector) of states (the ublas::vector)<br/>
&nbsp;&nbsp;const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt;&amp; GetRealStates() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_real_states; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the state names<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; GetStateNames() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_state_names; }<br/>
<br/>
&nbsp;&nbsp;///The white noise system<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystem&gt;&amp; GetWhiteNoiseSystem() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_white_noise_system; }<br/>
<br/>
&nbsp;&nbsp;///Check if the state of the class is valid<br/>
&nbsp;&nbsp;bool IsValid() const;<br/>
<br/>
&nbsp;&nbsp;protected:<br/>
<br/>
&nbsp;&nbsp;///Append a real state<br/>
&nbsp;&nbsp;void AppendRealState(const boost::numeric::ublas::vector&lt;double&gt;&amp; real_state);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~KalmanFilterExperiment() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(KalmanFilterExperiment*);<br/>
<br/>
&nbsp;&nbsp;static const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; ParseInput(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;std::string&gt;&amp; input,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_timesteps);<br/>
<br/>
&nbsp;&nbsp;///The calculation elements of each timestep<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; &gt; m_calculation_elements;<br/>
<br/>
&nbsp;&nbsp;///The HTML description of the context of this experiment<br/>
&nbsp;&nbsp;const std::string m_context;<br/>
<br/>
&nbsp;&nbsp;///The inputs of each timestep<br/>
&nbsp;&nbsp;const std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; m_inputs;<br/>
<br/>
&nbsp;&nbsp;///The Kalman filter<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilter&gt; m_kalman_filter;<br/>
<br/>
&nbsp;&nbsp;///The real state, that is, the values that would be measured without noise<br/>
&nbsp;&nbsp;std::vector&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; m_real_states;<br/>
<br/>
&nbsp;&nbsp;///State names<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; m_state_names;<br/>
<br/>
&nbsp;&nbsp;///The white noise system<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystem&gt; m_white_noise_system;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTEREXPERIMENT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterexperimentparameter.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterexperimentparameter.cpp" border = "1"><tr><td><code>
#include "kalmanfilterexperimentparameter.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfilterparameter.h"<br/>
#include "whitenoisesystemparameter.h"<br/>
#include "trace.h"<br/>
<br/>
const std::vector&lt;std::pair&lt;ribi::kalman::KalmanFilterParameterType,ribi::kalman::KalmanFilterExperimentParameterType&gt; &gt;<br/>
&nbsp;&nbsp;ribi::kalman::KalmanFilterExperimentParameter::m_map_kalman_filter = CreateMapKalmanFilter();<br/>
<br/>
const std::vector&lt;std::pair&lt;ribi::kalman::WhiteNoiseSystemParameterType,ribi::kalman::KalmanFilterExperimentParameterType&gt; &gt;<br/>
&nbsp;&nbsp;ribi::kalman::KalmanFilterExperimentParameter::m_map_white_noise_system = CreateMapWhiteNoiseSystem();<br/>
<br/>
bool ribi::kalman::KalmanFilterExperimentParameter::CanConvertToKalmanFilterParameter(<br/>
&nbsp;&nbsp;const KalmanFilterExperimentParameterType parameter)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;const auto j = m_map_kalman_filter.end();<br/>
&nbsp;&nbsp;for (auto i = m_map_kalman_filter.begin(); i!=j ;++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((*i).second == parameter) return true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return false;<br/>
}<br/>
<br/>
<br/>
bool ribi::kalman::KalmanFilterExperimentParameter::CanConvertToWhiteNoiseSystemParameter(<br/>
&nbsp;&nbsp;const KalmanFilterExperimentParameterType parameter)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;const auto j = m_map_white_noise_system.end();<br/>
&nbsp;&nbsp;for (auto i = m_map_white_noise_system.begin(); i!=j ;++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((*i).second == parameter) return true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return false;<br/>
}<br/>
<br/>
ribi::kalman::KalmanFilterExperimentParameterType ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterExperimentParameter(<br/>
&nbsp;&nbsp;const KalmanFilterParameterType parameter)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;const auto j = m_map_kalman_filter.end();<br/>
&nbsp;&nbsp;for (auto i = m_map_kalman_filter.begin(); i!=j ;++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((*i).first == parameter) return (*i).second;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Should never get here");<br/>
&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;//throw std::logic_error(<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;"ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterExperimentParameter(const KalmanFilterParameterType parameter)");<br/>
}<br/>
<br/>
ribi::kalman::KalmanFilterExperimentParameterType ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterExperimentParameter(<br/>
&nbsp;&nbsp;const WhiteNoiseSystemParameterType parameter)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;const auto j = m_map_white_noise_system.end();<br/>
&nbsp;&nbsp;for (auto i = m_map_white_noise_system.begin(); i!=j ;++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((*i).first == parameter) return (*i).second;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Should never get here");<br/>
&nbsp;&nbsp;throw std::logic_error(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterExperimentParameter(const WhiteNoiseSystemParameterType parameter)");<br/>
}<br/>
<br/>
ribi::kalman::KalmanFilterParameterType ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterParameter(<br/>
&nbsp;&nbsp;const KalmanFilterExperimentParameterType parameter)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;assert(CanConvertToKalmanFilterParameter(parameter));<br/>
&nbsp;&nbsp;const auto j = m_map_kalman_filter.end();<br/>
&nbsp;&nbsp;for (auto i = m_map_kalman_filter.begin(); i!=j ;++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((*i).second == parameter) return (*i).first;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Should never get here");<br/>
&nbsp;&nbsp;throw std::logic_error(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterParameter");<br/>
}<br/>
<br/>
ribi::kalman::WhiteNoiseSystemParameterType ribi::kalman::KalmanFilterExperimentParameter::ConvertToWhiteNoiseSystemParameter(<br/>
&nbsp;&nbsp;const KalmanFilterExperimentParameterType parameter)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(CanConvertToWhiteNoiseSystemParameter(parameter));<br/>
&nbsp;&nbsp;const auto j = m_map_white_noise_system.end();<br/>
&nbsp;&nbsp;for (auto i = m_map_white_noise_system.begin(); i!=j ;++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ((*i).second == parameter) return (*i).first;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Should never get here");<br/>
&nbsp;&nbsp;throw std::logic_error(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"ribi::kalman::KalmanFilterExperimentParameter::ConvertToWhiteNoiseSystemParameter");<br/>
}<br/>
<br/>
const std::vector&lt;std::pair&lt;ribi::kalman::KalmanFilterParameterType,ribi::kalman::KalmanFilterExperimentParameterType&gt; &gt;<br/>
&nbsp;&nbsp;ribi::kalman::KalmanFilterExperimentParameter::CreateMapKalmanFilter()<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;std::pair&lt;KalmanFilterParameterType,KalmanFilterExperimentParameterType&gt; &gt; v;<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::control<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::estimated_measurement_noise<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::estimated_optimal_kalman_gain,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::estimated_process_noise_covariance<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::initial_covariance_estimate<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::initial_state_estimate<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::observation<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::state_transition,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::state_transition<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size()) == static_cast&lt;int&gt;(KalmanFilterParameterType::n_parameters));<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const std::vector&lt;std::pair&lt;ribi::kalman::WhiteNoiseSystemParameterType,ribi::kalman::KalmanFilterExperimentParameterType&gt; &gt;<br/>
&nbsp;&nbsp;ribi::kalman::KalmanFilterExperimentParameter::CreateMapWhiteNoiseSystem()<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;std::pair&lt;WhiteNoiseSystemParameterType,KalmanFilterExperimentParameterType&gt; &gt; v;<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::control<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::initial_state_real,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::initial_state_real<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::measurement_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::measurement_frequency<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::real_measurement_noise<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::real_process_noise<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;v.push_back(std::make_pair(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::state_transition,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::state_transition<br/>
&nbsp;&nbsp;));<br/>
&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size()) == static_cast&lt;int&gt;(WhiteNoiseSystemParameterType::n_parameters));<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const std::vector&lt;ribi::kalman::KalmanFilterExperimentParameterType&gt; ribi::kalman::KalmanFilterExperimentParameter::GetAll()<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;const std::vector&lt;KalmanFilterExperimentParameterType&gt; v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::control,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K W<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::estimated_measurement_noise,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::estimated_process_noise_covariance, //E K<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::initial_covariance_estimate,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::initial_state_estimate,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E K<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::measurement_frequency,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E&nbsp;&nbsp; W<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::initial_state_real,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E&nbsp;&nbsp; W<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::real_measurement_noise,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E&nbsp;&nbsp; W<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::real_process_noise,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E&nbsp;&nbsp; W<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::input,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::observation,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::state_names,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterExperimentParameterType::state_transition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K W<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size()) == static_cast&lt;int&gt;(KalmanFilterExperimentParameterType::n_parameters)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "All parameters must be in");<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
bool ribi::kalman::KalmanFilterExperimentParameter::IsDouble(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::control:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::observation:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_names:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_transition:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"n_parameters is not implemented to be used");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsDouble: use of n_parameters");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type");<br/>
&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsDouble: use of unimplemented type");<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterExperimentParameter::IsFunction(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::control:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::observation:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_names:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_transition:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"n_parameters is not implemented to be used");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsFunction: use of n_parameters");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type");<br/>
&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsFunction: use of unimplemented type");<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterExperimentParameter::IsInt(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::control:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::observation:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_names:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_transition:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"n_parameters is not implemented to be used");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsInt: use of n_parameters");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type");<br/>
&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsInt: use of unimplemented type");<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterExperimentParameter::IsString(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::control:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::observation:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_names:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_transition:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"n_parameters is not implemented to be used");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsString: use of n_parameters");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type");<br/>
&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsString: use of unimplemented type");<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterExperimentParameter::IsMatrix(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;return !ribi::kalman::KalmanFilterExperimentParameter::IsVector(type);<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterExperimentParameter::IsVector(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::control:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::input:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::observation:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_names:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_transition:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"n_parameters is not implemented to be used");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsVector: use of n_parameters");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type");<br/>
&nbsp;&nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsVector: use of unimplemented type");<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::kalman::KalmanFilterExperimentParameter::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Started ribi::kalman::KalmanFilterExperimentParameter::Test");<br/>
&nbsp;&nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::control));<br/>
&nbsp;&nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::estimated_measurement_noise));<br/>
&nbsp;&nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));<br/>
&nbsp;&nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));<br/>
&nbsp;&nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::initial_covariance_estimate));<br/>
&nbsp;&nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::initial_state_estimate));<br/>
&nbsp;&nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::initial_state_real));<br/>
&nbsp;&nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::measurement_frequency));<br/>
&nbsp;&nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::real_measurement_noise));<br/>
&nbsp;&nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::real_process_noise));<br/>
&nbsp;&nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::input));<br/>
&nbsp;&nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::observation));<br/>
&nbsp;&nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::state_names));<br/>
&nbsp;&nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::state_transition));<br/>
<br/>
&nbsp;&nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::control));<br/>
&nbsp;&nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::estimated_measurement_noise));<br/>
&nbsp;&nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));<br/>
&nbsp;&nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));<br/>
&nbsp;&nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::initial_covariance_estimate));<br/>
&nbsp;&nbsp;assert( IsVector(KalmanFilterExperimentParameterType::initial_state_estimate));<br/>
&nbsp;&nbsp;assert( IsVector(KalmanFilterExperimentParameterType::initial_state_real));<br/>
&nbsp;&nbsp;assert( IsVector(KalmanFilterExperimentParameterType::measurement_frequency));<br/>
&nbsp;&nbsp;assert( IsVector(KalmanFilterExperimentParameterType::real_measurement_noise));<br/>
&nbsp;&nbsp;assert( IsVector(KalmanFilterExperimentParameterType::real_process_noise));<br/>
&nbsp;&nbsp;assert( IsVector(KalmanFilterExperimentParameterType::input));<br/>
&nbsp;&nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::observation));<br/>
&nbsp;&nbsp;assert( IsVector(KalmanFilterExperimentParameterType::state_names));<br/>
&nbsp;&nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::state_transition));<br/>
<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::control));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::estimated_measurement_noise));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::initial_covariance_estimate));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::initial_state_estimate));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::initial_state_real));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::measurement_frequency));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::real_measurement_noise));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::real_process_noise));<br/>
&nbsp;&nbsp;assert( IsString(KalmanFilterExperimentParameterType::input));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::observation));<br/>
&nbsp;&nbsp;assert( IsString(KalmanFilterExperimentParameterType::state_names));<br/>
&nbsp;&nbsp;assert(!IsString(KalmanFilterExperimentParameterType::state_transition));<br/>
<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::control));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::estimated_measurement_noise));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::initial_covariance_estimate));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::initial_state_estimate));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::initial_state_real));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::measurement_frequency));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::real_measurement_noise));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::real_process_noise));<br/>
&nbsp;&nbsp;assert( IsFunction(KalmanFilterExperimentParameterType::input));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::observation));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::state_names));<br/>
&nbsp;&nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::state_transition));<br/>
<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::control));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::estimated_measurement_noise));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::initial_covariance_estimate));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::initial_state_estimate));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::initial_state_real));<br/>
&nbsp;&nbsp;assert(!IsDouble(KalmanFilterExperimentParameterType::measurement_frequency));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::real_measurement_noise));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::real_process_noise));<br/>
&nbsp;&nbsp;assert(!IsDouble(KalmanFilterExperimentParameterType::input));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::observation));<br/>
&nbsp;&nbsp;assert(!IsDouble(KalmanFilterExperimentParameterType::state_names));<br/>
&nbsp;&nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::state_transition));<br/>
<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::control));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::estimated_measurement_noise));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::initial_covariance_estimate));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::initial_state_estimate));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::initial_state_real));<br/>
&nbsp;&nbsp;assert( IsInt(KalmanFilterExperimentParameterType::measurement_frequency));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::real_measurement_noise));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::real_process_noise));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::input));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::observation));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::state_names));<br/>
&nbsp;&nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::state_transition));<br/>
<br/>
&nbsp;&nbsp;TRACE("Finished ribi::kalman::KalmanFilterExperimentParameter::Test");<br/>
}<br/>
#endif<br/>
<br/>
const std::string ribi::kalman::KalmanFilterExperimentParameter::ToDescription(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;//Check for the subset<br/>
&nbsp;&nbsp;if (CanConvertToKalmanFilterParameter(type))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const KalmanFilterParameterType sub_type = ConvertToKalmanFilterParameter(type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return KalmanFilterParameter::ToDescription(sub_type);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (CanConvertToWhiteNoiseSystemParameter(type))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const WhiteNoiseSystemParameterType sub_type = ConvertToWhiteNoiseSystemParameter(type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return WhiteNoiseSystemParameter::ToDescription(sub_type);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Check the unique types<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::input:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Vector of inputs");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_names:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Vector of the state element names");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unimplemented type of KalmanFilterExperimentParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
const std::string ribi::kalman::KalmanFilterExperimentParameter::ToName(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;//Check for the subset<br/>
&nbsp;&nbsp;if (CanConvertToKalmanFilterParameter(type))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const KalmanFilterParameterType sub_type = ConvertToKalmanFilterParameter(type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return KalmanFilterParameter::ToName(sub_type);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (CanConvertToWhiteNoiseSystemParameter(type))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const WhiteNoiseSystemParameterType sub_type = ConvertToWhiteNoiseSystemParameter(type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return WhiteNoiseSystemParameter::ToName(sub_type);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Check the unique types<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::input:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Input");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_names:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("State names");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unimplemented type of KalmanFilterExperimentParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
const std::string ribi::kalman::KalmanFilterExperimentParameter::ToSymbol(const KalmanFilterExperimentParameterType type)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;//Check for the subset<br/>
&nbsp;&nbsp;if (CanConvertToKalmanFilterParameter(type))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const KalmanFilterParameterType sub_type = ConvertToKalmanFilterParameter(type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return KalmanFilterParameter::ToSymbol(sub_type);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (CanConvertToWhiteNoiseSystemParameter(type))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const WhiteNoiseSystemParameterType sub_type = ConvertToWhiteNoiseSystemParameter(type);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return WhiteNoiseSystemParameter::ToSymbol(sub_type);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Check the unique types<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::input:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("y");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterExperimentParameterType::state_names:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string(""); //State names has no symbol<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Unimplemented type of KalmanFilterExperimentParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterexperimentparameter.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterexperimentparameter.h" border = "1"><tr><td><code>
#ifndef KALMANFILTEREXPERIMENTPARAMETER_H<br/>
#define KALMANFILTEREXPERIMENTPARAMETER_H<br/>
<br/>
#include &lt;map&gt;<br/>
#include &lt;string&gt;<br/>
<br/>
#include "kalmanfilterparametertype.h"<br/>
#include "kalmanfilterexperimentparametertype.h"<br/>
#include "whitenoisesystemparametertype.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///A parameter used in a KalmanFilterExperiment<br/>
///Note that a KalmanFilterExperiment uses a KalmanFilter,<br/>
///which has its own parameter type called KalmanFilterParameter, which is<br/>
///a subset of these<br/>
struct KalmanFilterExperimentParameter<br/>
{<br/>
&nbsp;&nbsp;///Check if a convert from KalmanFilterExperimentParameter to a KalmanFilterParameter will succeed<br/>
&nbsp;&nbsp;static bool CanConvertToKalmanFilterParameter(const KalmanFilterExperimentParameterType parameter);<br/>
<br/>
&nbsp;&nbsp;///Check if a convert from KalmanFilterExperimentParameter to a WhiteNoiseSystemParameter will succeed<br/>
&nbsp;&nbsp;static bool CanConvertToWhiteNoiseSystemParameter(const KalmanFilterExperimentParameterType parameter);<br/>
<br/>
&nbsp;&nbsp;///Convert a KalmanFilterParameter to a KalmanFilterExperimentParameter,<br/>
&nbsp;&nbsp;///which will always succeed<br/>
&nbsp;&nbsp;static KalmanFilterExperimentParameterType ConvertToKalmanFilterExperimentParameter(const KalmanFilterParameterType parameter);<br/>
<br/>
&nbsp;&nbsp;///Convert a KalmanFilterParameter to a KalmanFilterExperimentParameter,<br/>
&nbsp;&nbsp;///which will always succeed<br/>
&nbsp;&nbsp;static KalmanFilterExperimentParameterType ConvertToKalmanFilterExperimentParameter(const WhiteNoiseSystemParameterType parameter);<br/>
<br/>
&nbsp;&nbsp;///Convert a KalmanFilterExperimentParameter to a KalmanFilterParameter,<br/>
&nbsp;&nbsp;///assumes CanConvertToKalmanFilterParameter succeeds<br/>
&nbsp;&nbsp;static KalmanFilterParameterType ConvertToKalmanFilterParameter(const KalmanFilterExperimentParameterType parameter);<br/>
<br/>
&nbsp;&nbsp;///Convert a KalmanFilterExperimentParameter to a WhiteNoiseSystemParameterType,<br/>
&nbsp;&nbsp;///assumes CanConvertToWhiteNoiseSystemParameter succeeds<br/>
&nbsp;&nbsp;static WhiteNoiseSystemParameterType ConvertToWhiteNoiseSystemParameter(const KalmanFilterExperimentParameterType parameter);<br/>
<br/>
&nbsp;&nbsp;///Get all KalmanFilterExperimentParameterType values<br/>
&nbsp;&nbsp;static const std::vector&lt;KalmanFilterExperimentParameterType&gt; GetAll();<br/>
<br/>
&nbsp;&nbsp;///Is this parameter a matrix/vector of type double?<br/>
&nbsp;&nbsp;static bool IsDouble(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Is this parameter a matrix/vector of type std::string for a function?<br/>
&nbsp;&nbsp;static bool IsFunction(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Is this parameter a matrix/vector of type integer?<br/>
&nbsp;&nbsp;static bool IsInt(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Is this parameter a matrix/vector of type std::string?<br/>
&nbsp;&nbsp;static bool IsString(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Is this parameter a matrix?<br/>
&nbsp;&nbsp;static bool IsMatrix(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Is this parameter a vector?<br/>
&nbsp;&nbsp;static bool IsVector(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the full name of a type, e.g. 'Matrix to capture the physics of the system'<br/>
&nbsp;&nbsp;static const std::string ToDescription(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the full name of a type, e.g. 'State transition'<br/>
&nbsp;&nbsp;static const std::string ToName(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the symbol of a type, e.g. 'A'<br/>
&nbsp;&nbsp;static const std::string ToSymbol(const KalmanFilterExperimentParameterType type);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;///Test this class<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;static const std::vector&lt;std::pair&lt;KalmanFilterParameterType,KalmanFilterExperimentParameterType&gt; &gt; m_map_kalman_filter;<br/>
&nbsp;&nbsp;static const std::vector&lt;std::pair&lt;WhiteNoiseSystemParameterType,KalmanFilterExperimentParameterType&gt; &gt; m_map_white_noise_system;<br/>
&nbsp;&nbsp;static const std::vector&lt;std::pair&lt;KalmanFilterParameterType,KalmanFilterExperimentParameterType&gt; &gt; CreateMapKalmanFilter();<br/>
&nbsp;&nbsp;static const std::vector&lt;std::pair&lt;WhiteNoiseSystemParameterType,KalmanFilterExperimentParameterType&gt; &gt; CreateMapWhiteNoiseSystem();<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTEREXPERIMENTPARAMETER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterexperimentparametertype.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterexperimentparametertype.cpp" border = "1"><tr><td><code>
<br/>
<br/>
#include "kalmanfilterexperimentparametertype.h"<br/>
<br/>
//#include &lt;cassert&gt;<br/>
//#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
<br/>
bool ribi::kalman::operator&lt;(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) &lt; static_cast&lt;int&gt;(rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator==(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) == static_cast&lt;int&gt;(rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator!=(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterexperimentparametertype.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterexperimentparametertype.h" border = "1"><tr><td><code>
#ifndef KALMANFILTEREXPERIMENTPARAMETERTYPE_H<br/>
#define KALMANFILTEREXPERIMENTPARAMETERTYPE_H<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
//#include &lt;vector&gt;<br/>
<br/>
///These parameters overlap<br/>
///E: Experiment<br/>
///K: Kalman filter<br/>
///W: White noise system parameter<br/>
enum class KalmanFilterExperimentParameterType<br/>
{<br/>
&nbsp;&nbsp;control,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K W<br/>
&nbsp;&nbsp;estimated_measurement_noise,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K<br/>
&nbsp;&nbsp;estimated_optimal_kalman_gain,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K<br/>
&nbsp;&nbsp;estimated_process_noise_covariance, //E K<br/>
&nbsp;&nbsp;initial_covariance_estimate,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K<br/>
&nbsp;&nbsp;initial_state_estimate,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E K<br/>
&nbsp;&nbsp;initial_state_real,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E&nbsp;&nbsp; W<br/>
&nbsp;&nbsp;measurement_frequency,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E&nbsp;&nbsp; W<br/>
&nbsp;&nbsp;real_measurement_noise,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E&nbsp;&nbsp; W<br/>
&nbsp;&nbsp;real_process_noise,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E&nbsp;&nbsp; W<br/>
&nbsp;&nbsp;input,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E<br/>
&nbsp;&nbsp;observation,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E K<br/>
&nbsp;&nbsp;state_names,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E<br/>
&nbsp;&nbsp;state_transition,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E K W<br/>
&nbsp;&nbsp;n_parameters&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E<br/>
};<br/>
<br/>
bool operator&lt;(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs);<br/>
bool operator==(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs);<br/>
bool operator!=(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs);<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTEREXPERIMENTPARAMETERTYPE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterfactory.cpp" border = "1"><tr><td><code>
<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfilterfactory.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include "standardkalmanfilterfactory.h"<br/>
#include "steadystatekalmanfilterfactory.h"<br/>
#include "fixedlagsmootherkalmanfilterfactory.h"<br/>
<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::KalmanFilter&gt; ribi::kalman::KalmanFilterFactory::Create(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;assert(parameters);<br/>
<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;KalmanFilter&gt; kalman_filter;<br/>
<br/>
&nbsp;&nbsp;switch(parameters-&gt;GetType())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterType::standard:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter = StandardKalmanFilterFactory::Create(parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterType::steady_state:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter = SteadyStateKalmanFilterFactory::Create(parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterType::fixed_lag_smoother:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kalman_filter = FixedLagSmootherKalmanFilterFactory::Create(parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterType::n_types:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented Kalman filter type");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;assert(kalman_filter-&gt;GetType() == parameters-&gt;GetType());<br/>
&nbsp;&nbsp;return kalman_filter;<br/>
}<br/>
<br/>
<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterfactory.h" border = "1"><tr><td><code>
#ifndef KALMANFILTERFACTORY_H<br/>
#define KALMANFILTERFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfilter.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Factory for KalmanFilter<br/>
struct KalmanFilterFactory<br/>
{<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;KalmanFilter&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTERFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterparameter.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterparameter.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfilterparameter.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;stdexcept&gt;<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
const std::vector&lt;ribi::kalman::KalmanFilterParameterType&gt; ribi::kalman::KalmanFilterParameter::GetAll()<br/>
{<br/>
&nbsp;&nbsp;const std::vector&lt;KalmanFilterParameterType&gt; v {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::estimated_optimal_kalman_gain,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterParameterType::state_transition<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size()) == static_cast&lt;int&gt;(KalmanFilterParameterType::n_parameters)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "All parameters must be in");<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterParameter::IsMatrix(const KalmanFilterParameterType type)<br/>
{<br/>
&nbsp;&nbsp;return !ribi::kalman::KalmanFilterParameter::IsVector(type);<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterParameter::IsVector(const KalmanFilterParameterType type)<br/>
{<br/>
&nbsp;&nbsp;return type == KalmanFilterParameterType::initial_state_estimate;<br/>
}<br/>
<br/>
const std::string ribi::kalman::KalmanFilterParameter::ToDescription(const KalmanFilterParameterType type)<br/>
{<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::control:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix for converting input to state change");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_measurement_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix that has an estimated measurement noise covariance");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_optimal_kalman_gain:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix with the estimated optimal Kalman gain");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_process_noise_covariance:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix with the estimated process noise covariance");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::initial_covariance_estimate:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix with the initial covariance estimate");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::initial_state_estimate:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Vector with the initial state estimate");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::observation:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix that with effect of a measurement on a state change");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::state_transition:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix that contains the internal physics of the system; the effect of current state on the next state");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");<br/>
&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
}<br/>
<br/>
const std::string ribi::kalman::KalmanFilterParameter::ToName(const KalmanFilterParameterType type)<br/>
{<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::control:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Control");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_measurement_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Estimated measurement error covariance");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_optimal_kalman_gain:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Estimated optimal Kalman gain");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_process_noise_covariance:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Estimated process noise covariance");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::initial_covariance_estimate:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Initial covariance estimate");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::initial_state_estimate:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Initial state estimate");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::observation:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Observation");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::state_transition:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("State transition");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");<br/>
&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
}<br/>
<br/>
const std::string ribi::kalman::KalmanFilterParameter::ToSymbol(const KalmanFilterParameterType type)<br/>
{<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::control:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("B");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_measurement_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("R");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_optimal_kalman_gain:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("K");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::estimated_process_noise_covariance:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Q");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::initial_covariance_estimate:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("P");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::initial_state_estimate:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("x");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::observation:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("H");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::state_transition:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("A");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case KalmanFilterParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");<br/>
&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterparameter.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterparameter.h" border = "1"><tr><td><code>
#ifndef KALMANFILTERPARAMETER_H<br/>
#define KALMANFILTERPARAMETER_H<br/>
<br/>
#include &lt;string&gt;<br/>
#include "kalmanfilterparametertype.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///A single KalmanFilterParameter<br/>
///for example, the state transition matrix<br/>
/// - is a matrix<br/>
/// - is not a vector<br/>
/// - has a description like 'Matrix that [...]'<br/>
/// - has the name 'State transition matrix'<br/>
/// - has the symbol 'A'<br/>
struct KalmanFilterParameter<br/>
{<br/>
&nbsp;&nbsp;///Obtain all KalmanFilterParameterType values, except n_parameters<br/>
&nbsp;&nbsp;static const std::vector&lt;KalmanFilterParameterType&gt; GetAll();<br/>
<br/>
&nbsp;&nbsp;///Is the type a matrix?<br/>
&nbsp;&nbsp;static bool IsMatrix(const KalmanFilterParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Is the type a vector?<br/>
&nbsp;&nbsp;static bool IsVector(const KalmanFilterParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the full name of a type, e.g. 'Matrix to capture the physics of the system'<br/>
&nbsp;&nbsp;static const std::string ToDescription(const KalmanFilterParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the full name of a type, e.g. 'State transition'<br/>
&nbsp;&nbsp;static const std::string ToName(const KalmanFilterParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the symbol of a type, e.g. 'A'<br/>
&nbsp;&nbsp;static const std::string ToSymbol(const KalmanFilterParameterType type);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTERPARAMETER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterparameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterparameters.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfilterparameters.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include "trace.h"<br/>
<br/>
ribi::kalman::KalmanFilterParameters::KalmanFilterParameters(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; observation,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
&nbsp;&nbsp;: m_control{control},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_initial_state_estimate{initial_state_estimate},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_observation{observation},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_state_transition{state_transition}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;//Check for correct dimensionality<br/>
&nbsp;&nbsp;const std::size_t sz = GetInitialStateEstimate().size();<br/>
&nbsp;&nbsp;//assert(sz &gt;= 0); //Inevitable for std::size_t<br/>
&nbsp;&nbsp;assert(GetControl().size1() == sz);<br/>
&nbsp;&nbsp;assert(GetControl().size2() == sz);<br/>
&nbsp;&nbsp;assert(GetObservation().size1() == sz);<br/>
&nbsp;&nbsp;assert(GetObservation().size2() == sz);<br/>
&nbsp;&nbsp;assert(GetStateTransition().size1() == sz);<br/>
&nbsp;&nbsp;assert(GetStateTransition().size2() == sz);<br/>
&nbsp;&nbsp;assert(GetInitialStateEstimate().size() == sz);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
bool ribi::kalman::KalmanFilterParameters::HasParameterType(const KalmanFilterParameterType type)<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type == KalmanFilterParameterType::control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::state_transition;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterparameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterparameters.h" border = "1"><tr><td><code>
#ifndef KALMANFILTERPARAMETERS_H<br/>
#define KALMANFILTERPARAMETERS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfiltertype.h"<br/>
#include "kalmanfilterparametertype.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///ABC for the parameters every Kalman filter needs at least<br/>
struct KalmanFilterParameters<br/>
{<br/>
&nbsp;&nbsp;KalmanFilterParameters(const KalmanFilterParameters&amp;) = delete;<br/>
&nbsp;&nbsp;KalmanFilterParameters&amp; operator=(const KalmanFilterParameters&amp;) = delete;<br/>
&nbsp;&nbsp;virtual ~KalmanFilterParameters() noexcept {}<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;virtual KalmanFilterType GetType() const = 0;<br/>
<br/>
&nbsp;&nbsp;///Obtain the control matrix ('B'): the effect of inputs on the current states<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetControl() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_control; }<br/>
<br/>
&nbsp;&nbsp;///x: The initial state estimate<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetInitialStateEstimate() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_initial_state_estimate; }<br/>
<br/>
&nbsp;&nbsp;///Obtain how the states are observed ('H')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetObservation() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_observation; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the state transition matrix ('F'), containing the physics of the system<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetStateTransition() const { return m_state_transition; }<br/>
<br/>
&nbsp;&nbsp;///Check if this parameter set has a certain type of KalmanFilterParameter<br/>
&nbsp;&nbsp;static bool HasParameterType(const KalmanFilterParameterType type);<br/>
<br/>
&nbsp;&nbsp;protected:<br/>
&nbsp;&nbsp;///An ABC can only be constructed by derived classes<br/>
&nbsp;&nbsp;explicit KalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///B: control matrix: the effect of inputs on the current states<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_control;<br/>
<br/>
&nbsp;&nbsp;///x: The initial state estimate<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; m_initial_state_estimate;<br/>
<br/>
&nbsp;&nbsp;///H: How the states are observed<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_observation;<br/>
<br/>
&nbsp;&nbsp;///F: state transition matrix, containing the physics of the system<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_state_transition;<br/>
<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTERPARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterparametertype.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterparametertype.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfilterparametertype.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
bool ribi::kalman::operator&lt;(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) &lt; static_cast&lt;int&gt;(rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator==(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) == static_cast&lt;int&gt;(rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfilterparametertype.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfilterparametertype.h" border = "1"><tr><td><code>
#ifndef KALMANFILTERPARAMETERTYPE_H<br/>
#define KALMANFILTERPARAMETERTYPE_H<br/>
<br/>
#include &lt;vector&gt;<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///The matrix/vector types/names of Kalman filter parameters<br/>
enum class KalmanFilterParameterType<br/>
{<br/>
&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;estimated_measurement_noise,<br/>
&nbsp;&nbsp;estimated_optimal_kalman_gain,<br/>
&nbsp;&nbsp;estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;initial_covariance_estimate,<br/>
&nbsp;&nbsp;initial_state_estimate,<br/>
&nbsp;&nbsp;observation,<br/>
&nbsp;&nbsp;state_transition,<br/>
&nbsp;&nbsp;n_parameters //Must be last element, used in debugging<br/>
};<br/>
<br/>
bool operator&lt;(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs);<br/>
bool operator==(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs);<br/>
bool operator!=(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs);<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTERPARAMETERTYPE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfiltertype.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfiltertype.cpp" border = "1"><tr><td><code>
#include "kalmanfiltertype.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
bool ribi::kalman::operator==(const KalmanFilterType lhs, const KalmanFilterType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) == static_cast&lt;int&gt;(rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator!=(const KalmanFilterType lhs, const KalmanFilterType rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator&lt;(const KalmanFilterType lhs, const KalmanFilterType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) &lt; static_cast&lt;int&gt;(rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfiltertype.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfiltertype.h" border = "1"><tr><td><code>
#ifndef KALMANFILTERTYPE_H<br/>
#define KALMANFILTERTYPE_H<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
enum class KalmanFilterType<br/>
{<br/>
&nbsp;&nbsp;//ensemble,<br/>
&nbsp;&nbsp;//extended,<br/>
&nbsp;&nbsp;fixed_lag_smoother,<br/>
&nbsp;&nbsp;//hybrid<br/>
&nbsp;&nbsp;//kalman_bucy<br/>
&nbsp;&nbsp;//minimum_variance_smoother<br/>
&nbsp;&nbsp;//modified_Bryson_Frazier_smoother<br/>
&nbsp;&nbsp;//rauch_tung_striebel_smoother<br/>
&nbsp;&nbsp;standard, //Also called: 'discrete'<br/>
&nbsp;&nbsp;steady_state,<br/>
&nbsp;&nbsp;//unscented,<br/>
&nbsp;&nbsp;n_types //Must be last value, used in debugging<br/>
};<br/>
<br/>
<br/>
bool operator==(const KalmanFilterType lhs, const KalmanFilterType rhs);<br/>
bool operator!=(const KalmanFilterType lhs, const KalmanFilterType rhs);<br/>
bool operator&lt;(const KalmanFilterType lhs, const KalmanFilterType rhs);<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTERTYPE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfiltertypes.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfiltertypes.cpp" border = "1"><tr><td><code>
#include "kalmanfiltertypes.h"<br/>
<br/>
boost::bimap&lt;ribi::kalman::KalmanFilterType,std::string&gt; ribi::kalman::KalmanFilterTypes::m_map;<br/>
<br/>
const boost::bimap&lt;ribi::kalman::KalmanFilterType,std::string&gt; ribi::kalman::KalmanFilterTypes::CreateMap()<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;boost::bimap&lt;KalmanFilterType,std::string&gt; m;<br/>
&nbsp;&nbsp;m.insert(boost::bimap&lt;KalmanFilterType,std::string&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterType::fixed_lag_smoother,std::string("fixed lag smoother")));<br/>
&nbsp;&nbsp;m.insert(boost::bimap&lt;KalmanFilterType,std::string&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterType::standard,std::string("discrete")));<br/>
&nbsp;&nbsp;m.insert(boost::bimap&lt;KalmanFilterType,std::string&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterType::steady_state,std::string("steady state")));<br/>
&nbsp;&nbsp;return m;<br/>
}<br/>
<br/>
const std::vector&lt;ribi::kalman::KalmanFilterType&gt; ribi::kalman::KalmanFilterTypes::GetAllTypes()<br/>
{<br/>
&nbsp;&nbsp;const std::vector&lt;KalmanFilterType&gt; v<br/>
&nbsp;&nbsp;=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterType::fixed_lag_smoother,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterType::standard,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterType::steady_state<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(static_cast&lt;int&gt;(v.size()) == static_cast&lt;int&gt;(KalmanFilterType::n_types));<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::kalman::KalmanFilterTypes::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const std::vector&lt;KalmanFilterType&gt; v = GetAllTypes();<br/>
&nbsp;&nbsp;const std::size_t sz = v.size();<br/>
&nbsp;&nbsp;for (std::size_t i=0; i!=sz; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const KalmanFilterType t = v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string s = ToStr(t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!s.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const KalmanFilterType u = ToType(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(u == t);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
#endif<br/>
<br/>
const std::string ribi::kalman::KalmanFilterTypes::ToStr(const KalmanFilterType type)<br/>
{<br/>
&nbsp;&nbsp;if (m_map.left.empty()) m_map = CreateMap();<br/>
&nbsp;&nbsp;assert(!m_map.left.empty());<br/>
&nbsp;&nbsp;assert(m_map.left.count(type));<br/>
&nbsp;&nbsp;const std::string s = m_map.left.find(type)-&gt;second;<br/>
&nbsp;&nbsp;return s;<br/>
}<br/>
<br/>
ribi::kalman::KalmanFilterType ribi::kalman::KalmanFilterTypes::ToType(const std::string&amp; s)<br/>
{<br/>
&nbsp;&nbsp;if (m_map.right.empty()) m_map = CreateMap();<br/>
&nbsp;&nbsp;assert(!m_map.right.empty());<br/>
&nbsp;&nbsp;assert(m_map.right.count(s) == 1);<br/>
&nbsp;&nbsp;const KalmanFilterType t = m_map.right.find(s)-&gt;second;<br/>
&nbsp;&nbsp;return t;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/kalmanfiltertypes.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/kalmanfiltertypes.h" border = "1"><tr><td><code>
#ifndef KALMANFILTERTYPES_H<br/>
#define KALMANFILTERTYPES_H<br/>
<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/bimap.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfiltertype.h"<br/>
<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Class to work on one or more KalmanFilterType instances<br/>
struct KalmanFilterTypes<br/>
{<br/>
&nbsp;&nbsp;static const std::vector&lt;KalmanFilterType&gt; GetAllTypes();<br/>
&nbsp;&nbsp;static const std::string ToStr(const KalmanFilterType type);<br/>
&nbsp;&nbsp;static KalmanFilterType ToType(const std::string&amp; s);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;static boost::bimap&lt;KalmanFilterType,std::string&gt; m_map;<br/>
&nbsp;&nbsp;static const boost::bimap&lt;KalmanFilterType,std::string&gt; CreateMap();<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // KALMANFILTERTYPES_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/laggedwhitenoisesystem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/laggedwhitenoisesystem.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "laggedwhitenoisesystem.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "matrix.h"<br/>
#include "trace.h"<br/>
#include "laggedwhitenoisesystem.h"<br/>
#include "laggedwhitenoisesystemfactory.h"<br/>
#include "laggedwhitenoisesystemparameters.h"<br/>
#include "standardwhitenoisesystemparameters.h"<br/>
#include "standardwhitenoisesystemfactory.h"<br/>
<br/>
ribi::kalman::LaggedWhiteNoiseSystem::LaggedWhiteNoiseSystem(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; parameters)<br/>
&nbsp;&nbsp;: WhiteNoiseSystem{parameters},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_measuments{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_parameters{boost::dynamic_pointer_cast&lt;const LaggedWhiteNoiseSystemParameters&gt;(parameters)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_system{StandardWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetControl(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetInitialState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetMeasurementNoise(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetProcessNoise(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameters-&gt;GetStateTransition())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(m_parameters);<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetLag() &gt;= 0);<br/>
&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(m_measuments.size()) &lt;= m_parameters-&gt;GetLag());<br/>
&nbsp;&nbsp;assert(m_system);<br/>
<br/>
&nbsp;&nbsp;const int lag = m_parameters-&gt;GetLag();<br/>
&nbsp;&nbsp;while (lag != boost::numeric_cast&lt;int&gt;(m_measuments.size()))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_measuments.push(m_system-&gt;Measure());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(lag == boost::numeric_cast&lt;int&gt;(m_measuments.size()));<br/>
}<br/>
<br/>
const std::string ribi::kalman::LaggedWhiteNoiseSystem::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.0";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::LaggedWhiteNoiseSystem::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-03: version 1.0: initial version"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
void ribi::kalman::LaggedWhiteNoiseSystem::GoToNextState(const boost::numeric::ublas::vector&lt;double&gt;&amp; input)<br/>
{<br/>
&nbsp;&nbsp;m_system-&gt;GoToNextState(input);<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt; ribi::kalman::LaggedWhiteNoiseSystem::Measure() const noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetLag() == boost::numeric_cast&lt;int&gt;(m_measuments.size()));<br/>
&nbsp;&nbsp;m_measuments.push(m_system-&gt;Measure());<br/>
<br/>
&nbsp;&nbsp;//Result is copied now, to also work for m_lag == 0<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; result = m_measuments.front();<br/>
<br/>
&nbsp;&nbsp;m_measuments.pop();<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetLag() == boost::numeric_cast&lt;int&gt;(m_measuments.size()));<br/>
&nbsp;&nbsp;return result;<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt;&amp; ribi::kalman::LaggedWhiteNoiseSystem::PeekAtRealState() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return m_system-&gt;PeekAtRealState();<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::kalman::LaggedWhiteNoiseSystem::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::kalman::LaggedWhiteNoiseSystem::Test()")<br/>
&nbsp;&nbsp;//Check if measurements are indeed lagged:<br/>
&nbsp;&nbsp;//The system's real value should update immediatly, but this fresh measurement<br/>
&nbsp;&nbsp;//must only be accessible after lag timesteps<br/>
&nbsp;&nbsp;//Context: measuring the position of an object with constant velocity<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag = 5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;LaggedWhiteNoiseSystem&gt; my_system<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= LaggedWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateMatrix(1,1, { 1.0 } ), //control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateVector(&nbsp;&nbsp;&nbsp;&nbsp; { 0.0 } ), //initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateVector(&nbsp;&nbsp;&nbsp;&nbsp; { 0.0 } ), //real_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateVector(&nbsp;&nbsp;&nbsp;&nbsp; { 0.0 } ), //real_process_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix::CreateMatrix(1,1, { 1.0 } )&nbsp;&nbsp;//state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; input = Matrix::CreateVector( { 1.0 } );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=lag; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Matrix::IsAboutEqual( my_system-&gt;Measure()(0), 0.0));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Matrix::IsAboutEqual( my_system-&gt;PeekAtRealState()(0), boost::numeric_cast&lt;double&gt;(i) ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_system-&gt;GoToNextState(input);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=10; ++i) //10 = just some value<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const double expected = boost::numeric_cast&lt;double&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Matrix::IsAboutEqual( my_system-&gt;Measure()(0), expected));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Matrix::IsAboutEqual( my_system-&gt;PeekAtRealState()(0), boost::numeric_cast&lt;double&gt;(lag + i) ) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_system-&gt;GoToNextState(input);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::kalman::LaggedWhiteNoiseSystem::Test()")<br/>
}<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/laggedwhitenoisesystem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/laggedwhitenoisesystem.h" border = "1"><tr><td><code>
#ifndef LAGGEDWHITENOISESYSTEM_H<br/>
#define LAGGEDWHITENOISESYSTEM_H<br/>
<br/>
#include &lt;queue&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "whitenoisesystem.h"<br/>
#include "whitenoisesystemparameters.h"<br/>
#include "laggedwhitenoisesystemparameters.h"<br/>
#include "standardwhitenoisesystem.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///A lagged white noise system is a system that can be measured only after a certain number<br/>
///of periods.<br/>
struct LaggedWhiteNoiseSystem : public WhiteNoiseSystem<br/>
{<br/>
&nbsp;&nbsp;///Obtain the lagged white noise system parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const LaggedWhiteNoiseSystemParameters&gt;&amp; GetLaggedWhiteNoiseSystemParameters() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_parameters; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the type as an enum<br/>
&nbsp;&nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::lagged; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state<br/>
&nbsp;&nbsp;void GoToNextState(const boost::numeric::ublas::vector&lt;double&gt;&amp; input);<br/>
<br/>
&nbsp;&nbsp;///Measure a value from this system with normally distributed noise<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; Measure() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Peek what the real value is<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; PeekAtRealState() const noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///LaggedWhiteNoiseSystem must be created with a LaggedWhiteNoiseSystemFactory<br/>
&nbsp;&nbsp;explicit LaggedWhiteNoiseSystem(const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; white_noise_system_parameters);<br/>
&nbsp;&nbsp;friend class LaggedWhiteNoiseSystemFactory;<br/>
<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~LaggedWhiteNoiseSystem() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(LaggedWhiteNoiseSystem*);<br/>
<br/>
&nbsp;&nbsp;///The front one is the one that can be read,<br/>
&nbsp;&nbsp;///the back one is the freshest measurement<br/>
&nbsp;&nbsp;mutable std::queue&lt;boost::numeric::ublas::vector&lt;double&gt; &gt; m_measuments;<br/>
<br/>
&nbsp;&nbsp;///The lagged white noise system parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const LaggedWhiteNoiseSystemParameters&gt; m_parameters;<br/>
<br/>
&nbsp;&nbsp;///The standard white noise system used as an engine<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;StandardWhiteNoiseSystem&gt; m_system;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;///Test this class<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // LAGGEDWHITENOISESYSTEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/laggedwhitenoisesystemfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/laggedwhitenoisesystemfactory.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "laggedwhitenoisesystemfactory.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::LaggedWhiteNoiseSystem&gt; ribi::kalman::LaggedWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt; parameters{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new LaggedWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(parameters);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;LaggedWhiteNoiseSystem&gt; system{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new LaggedWhiteNoiseSystem(parameters)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(system);<br/>
&nbsp;&nbsp;return system;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::LaggedWhiteNoiseSystem&gt; ribi::kalman::LaggedWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystemParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;assert(parameters-&gt;GetType() == WhiteNoiseSystemType::lagged);<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;LaggedWhiteNoiseSystemParameters&gt; lagged_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::dynamic_pointer_cast&lt;LaggedWhiteNoiseSystemParameters&gt;(parameters);<br/>
&nbsp;&nbsp;assert(lagged_parameters);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;LaggedWhiteNoiseSystem&gt; my_system<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lagged_parameters-&gt;GetControl(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lagged_parameters-&gt;GetInitialState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lagged_parameters-&gt;GetLag(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lagged_parameters-&gt;GetMeasurementNoise(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lagged_parameters-&gt;GetProcessNoise(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lagged_parameters-&gt;GetStateTransition());<br/>
&nbsp;&nbsp;assert(my_system);<br/>
&nbsp;&nbsp;return my_system;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/laggedwhitenoisesystemfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/laggedwhitenoisesystemfactory.h" border = "1"><tr><td><code>
#ifndef LAGGEDWHITENOISESYSTEMFACTORY_H<br/>
#define LAGGEDWHITENOISESYSTEMFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "laggedwhitenoisesystem.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Factory for LaggedWhiteNoiseSystem<br/>
struct LaggedWhiteNoiseSystemFactory<br/>
{<br/>
&nbsp;&nbsp;///Create a LaggedWhiteNoiseSystem from the loose parameters<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;LaggedWhiteNoiseSystem&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition);<br/>
<br/>
&nbsp;&nbsp;///Create a LaggedWhiteNoiseSystem from the parameters<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;LaggedWhiteNoiseSystem&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystemParameters&gt;&amp; parameters);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // LAGGEDWHITENOISESYSTEMFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/laggedwhitenoisesystemparameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/laggedwhitenoisesystemparameters.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "laggedwhitenoisesystemparameters.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include "standardwhitenoisesystemparameters.h"<br/>
<br/>
ribi::kalman::LaggedWhiteNoiseSystemParameters::LaggedWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
&nbsp;&nbsp;: WhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_lag{lag}<br/>
{<br/>
&nbsp;&nbsp;assert(lag &gt;= 0);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/laggedwhitenoisesystemparameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/laggedwhitenoisesystemparameters.h" border = "1"><tr><td><code>
#ifndef LAGGEDWHITENOISESYSTEMPARAMETERS_H<br/>
#define LAGGEDWHITENOISESYSTEMPARAMETERS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "whitenoisesystemparameters.h"<br/>
#include "standardwhitenoisesystemparameters.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct LaggedWhiteNoiseSystemParameters : public WhiteNoiseSystemParameters<br/>
{<br/>
&nbsp;&nbsp;explicit LaggedWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int lag,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition);<br/>
<br/>
&nbsp;&nbsp;///The lag (in timesteps) the lagged white noise system has<br/>
&nbsp;&nbsp;int GetLag() const noexcept { return m_lag; }<br/>
<br/>
&nbsp;&nbsp;///The white noise system parameters of unlagged behavior<br/>
&nbsp;&nbsp;//const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt;&amp; GetStandardWhiteNoiseSystemParameters() const<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;{ return m_standard_parameters; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the type as an enum<br/>
&nbsp;&nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::lagged; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~LaggedWhiteNoiseSystemParameters() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(LaggedWhiteNoiseSystemParameters*);<br/>
<br/>
&nbsp;&nbsp;///The lag (in timesteps) the lagged white noise system has<br/>
&nbsp;&nbsp;const int m_lag;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // LAGGEDWHITENOISESYSTEMPARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/Licence.txt</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/Licence.txt" border = "1"><tr><td><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GNU GENERAL PUBLIC LICENSE<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Version 3, 29 June 2007<br/>
<br/>
 Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;<br/>
 Everyone is permitted to copy and distribute verbatim copies<br/>
 of this license document, but changing it is not allowed.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preamble<br/>
<br/>
&nbsp;&nbsp;The GNU General Public License is a free, copyleft license for<br/>
software and other kinds of works.<br/>
<br/>
&nbsp;&nbsp;The licenses for most software and other practical works are designed<br/>
to take away your freedom to share and change the works.&nbsp;&nbsp;By contrast,<br/>
the GNU General Public License is intended to guarantee your freedom to<br/>
share and change all versions of a program--to make sure it remains free<br/>
software for all its users.&nbsp;&nbsp;We, the Free Software Foundation, use the<br/>
GNU General Public License for most of our software; it applies also to<br/>
any other work released this way by its authors.&nbsp;&nbsp;You can apply it to<br/>
your programs, too.<br/>
<br/>
&nbsp;&nbsp;When we speak of free software, we are referring to freedom, not<br/>
price.&nbsp;&nbsp;Our General Public Licenses are designed to make sure that you<br/>
have the freedom to distribute copies of free software (and charge for<br/>
them if you wish), that you receive source code or can get it if you<br/>
want it, that you can change the software or use pieces of it in new<br/>
free programs, and that you know you can do these things.<br/>
<br/>
&nbsp;&nbsp;To protect your rights, we need to prevent others from denying you<br/>
these rights or asking you to surrender the rights.&nbsp;&nbsp;Therefore, you have<br/>
certain responsibilities if you distribute copies of the software, or if<br/>
you modify it: responsibilities to respect the freedom of others.<br/>
<br/>
&nbsp;&nbsp;For example, if you distribute copies of such a program, whether<br/>
gratis or for a fee, you must pass on to the recipients the same<br/>
freedoms that you received.&nbsp;&nbsp;You must make sure that they, too, receive<br/>
or can get the source code.&nbsp;&nbsp;And you must show them these terms so they<br/>
know their rights.<br/>
<br/>
&nbsp;&nbsp;Developers that use the GNU GPL protect your rights with two steps:<br/>
(1) assert copyright on the software, and (2) offer you this License<br/>
giving you legal permission to copy, distribute and/or modify it.<br/>
<br/>
&nbsp;&nbsp;For the developers' and authors' protection, the GPL clearly explains<br/>
that there is no warranty for this free software.&nbsp;&nbsp;For both users' and<br/>
authors' sake, the GPL requires that modified versions be marked as<br/>
changed, so that their problems will not be attributed erroneously to<br/>
authors of previous versions.<br/>
<br/>
&nbsp;&nbsp;Some devices are designed to deny users access to install or run<br/>
modified versions of the software inside them, although the manufacturer<br/>
can do so.&nbsp;&nbsp;This is fundamentally incompatible with the aim of<br/>
protecting users' freedom to change the software.&nbsp;&nbsp;The systematic<br/>
pattern of such abuse occurs in the area of products for individuals to<br/>
use, which is precisely where it is most unacceptable.&nbsp;&nbsp;Therefore, we<br/>
have designed this version of the GPL to prohibit the practice for those<br/>
products.&nbsp;&nbsp;If such problems arise substantially in other domains, we<br/>
stand ready to extend this provision to those domains in future versions<br/>
of the GPL, as needed to protect the freedom of users.<br/>
<br/>
&nbsp;&nbsp;Finally, every program is threatened constantly by software patents.<br/>
States should not allow patents to restrict development and use of<br/>
software on general-purpose computers, but in those that do, we wish to<br/>
avoid the special danger that patents applied to a free program could<br/>
make it effectively proprietary.&nbsp;&nbsp;To prevent this, the GPL assures that<br/>
patents cannot be used to render the program non-free.<br/>
<br/>
&nbsp;&nbsp;The precise terms and conditions for copying, distribution and<br/>
modification follow.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TERMS AND CONDITIONS<br/>
<br/>
&nbsp;&nbsp;0. Definitions.<br/>
<br/>
&nbsp;&nbsp;"This License" refers to version 3 of the GNU General Public License.<br/>
<br/>
&nbsp;&nbsp;"Copyright" also means copyright-like laws that apply to other kinds of<br/>
works, such as semiconductor masks.<br/>
<br/>
&nbsp;&nbsp;"The Program" refers to any copyrightable work licensed under this<br/>
License.&nbsp;&nbsp;Each licensee is addressed as "you".&nbsp;&nbsp;"Licensees" and<br/>
"recipients" may be individuals or organizations.<br/>
<br/>
&nbsp;&nbsp;To "modify" a work means to copy from or adapt all or part of the work<br/>
in a fashion requiring copyright permission, other than the making of an<br/>
exact copy.&nbsp;&nbsp;The resulting work is called a "modified version" of the<br/>
earlier work or a work "based on" the earlier work.<br/>
<br/>
&nbsp;&nbsp;A "covered work" means either the unmodified Program or a work based<br/>
on the Program.<br/>
<br/>
&nbsp;&nbsp;To "propagate" a work means to do anything with it that, without<br/>
permission, would make you directly or secondarily liable for<br/>
infringement under applicable copyright law, except executing it on a<br/>
computer or modifying a private copy.&nbsp;&nbsp;Propagation includes copying,<br/>
distribution (with or without modification), making available to the<br/>
public, and in some countries other activities as well.<br/>
<br/>
&nbsp;&nbsp;To "convey" a work means any kind of propagation that enables other<br/>
parties to make or receive copies.&nbsp;&nbsp;Mere interaction with a user through<br/>
a computer network, with no transfer of a copy, is not conveying.<br/>
<br/>
&nbsp;&nbsp;An interactive user interface displays "Appropriate Legal Notices"<br/>
to the extent that it includes a convenient and prominently visible<br/>
feature that (1) displays an appropriate copyright notice, and (2)<br/>
tells the user that there is no warranty for the work (except to the<br/>
extent that warranties are provided), that licensees may convey the<br/>
work under this License, and how to view a copy of this License.&nbsp;&nbsp;If<br/>
the interface presents a list of user commands or options, such as a<br/>
menu, a prominent item in the list meets this criterion.<br/>
<br/>
&nbsp;&nbsp;1. Source Code.<br/>
<br/>
&nbsp;&nbsp;The "source code" for a work means the preferred form of the work<br/>
for making modifications to it.&nbsp;&nbsp;"Object code" means any non-source<br/>
form of a work.<br/>
<br/>
&nbsp;&nbsp;A "Standard Interface" means an interface that either is an official<br/>
standard defined by a recognized standards body, or, in the case of<br/>
interfaces specified for a particular programming language, one that<br/>
is widely used among developers working in that language.<br/>
<br/>
&nbsp;&nbsp;The "System Libraries" of an executable work include anything, other<br/>
than the work as a whole, that (a) is included in the normal form of<br/>
packaging a Major Component, but which is not part of that Major<br/>
Component, and (b) serves only to enable use of the work with that<br/>
Major Component, or to implement a Standard Interface for which an<br/>
implementation is available to the public in source code form.&nbsp;&nbsp;A<br/>
"Major Component", in this context, means a major essential component<br/>
(kernel, window system, and so on) of the specific operating system<br/>
(if any) on which the executable work runs, or a compiler used to<br/>
produce the work, or an object code interpreter used to run it.<br/>
<br/>
&nbsp;&nbsp;The "Corresponding Source" for a work in object code form means all<br/>
the source code needed to generate, install, and (for an executable<br/>
work) run the object code and to modify the work, including scripts to<br/>
control those activities.&nbsp;&nbsp;However, it does not include the work's<br/>
System Libraries, or general-purpose tools or generally available free<br/>
programs which are used unmodified in performing those activities but<br/>
which are not part of the work.&nbsp;&nbsp;For example, Corresponding Source<br/>
includes interface definition files associated with source files for<br/>
the work, and the source code for shared libraries and dynamically<br/>
linked subprograms that the work is specifically designed to require,<br/>
such as by intimate data communication or control flow between those<br/>
subprograms and other parts of the work.<br/>
<br/>
&nbsp;&nbsp;The Corresponding Source need not include anything that users<br/>
can regenerate automatically from other parts of the Corresponding<br/>
Source.<br/>
<br/>
&nbsp;&nbsp;The Corresponding Source for a work in source code form is that<br/>
same work.<br/>
<br/>
&nbsp;&nbsp;2. Basic Permissions.<br/>
<br/>
&nbsp;&nbsp;All rights granted under this License are granted for the term of<br/>
copyright on the Program, and are irrevocable provided the stated<br/>
conditions are met.&nbsp;&nbsp;This License explicitly affirms your unlimited<br/>
permission to run the unmodified Program.&nbsp;&nbsp;The output from running a<br/>
covered work is covered by this License only if the output, given its<br/>
content, constitutes a covered work.&nbsp;&nbsp;This License acknowledges your<br/>
rights of fair use or other equivalent, as provided by copyright law.<br/>
<br/>
&nbsp;&nbsp;You may make, run and propagate covered works that you do not<br/>
convey, without conditions so long as your license otherwise remains<br/>
in force.&nbsp;&nbsp;You may convey covered works to others for the sole purpose<br/>
of having them make modifications exclusively for you, or provide you<br/>
with facilities for running those works, provided that you comply with<br/>
the terms of this License in conveying all material for which you do<br/>
not control copyright.&nbsp;&nbsp;Those thus making or running the covered works<br/>
for you must do so exclusively on your behalf, under your direction<br/>
and control, on terms that prohibit them from making any copies of<br/>
your copyrighted material outside their relationship with you.<br/>
<br/>
&nbsp;&nbsp;Conveying under any other circumstances is permitted solely under<br/>
the conditions stated below.&nbsp;&nbsp;Sublicensing is not allowed; section 10<br/>
makes it unnecessary.<br/>
<br/>
&nbsp;&nbsp;3. Protecting Users' Legal Rights From Anti-Circumvention Law.<br/>
<br/>
&nbsp;&nbsp;No covered work shall be deemed part of an effective technological<br/>
measure under any applicable law fulfilling obligations under article<br/>
11 of the WIPO copyright treaty adopted on 20 December 1996, or<br/>
similar laws prohibiting or restricting circumvention of such<br/>
measures.<br/>
<br/>
&nbsp;&nbsp;When you convey a covered work, you waive any legal power to forbid<br/>
circumvention of technological measures to the extent such circumvention<br/>
is effected by exercising rights under this License with respect to<br/>
the covered work, and you disclaim any intention to limit operation or<br/>
modification of the work as a means of enforcing, against the work's<br/>
users, your or third parties' legal rights to forbid circumvention of<br/>
technological measures.<br/>
<br/>
&nbsp;&nbsp;4. Conveying Verbatim Copies.<br/>
<br/>
&nbsp;&nbsp;You may convey verbatim copies of the Program's source code as you<br/>
receive it, in any medium, provided that you conspicuously and<br/>
appropriately publish on each copy an appropriate copyright notice;<br/>
keep intact all notices stating that this License and any<br/>
non-permissive terms added in accord with section 7 apply to the code;<br/>
keep intact all notices of the absence of any warranty; and give all<br/>
recipients a copy of this License along with the Program.<br/>
<br/>
&nbsp;&nbsp;You may charge any price or no price for each copy that you convey,<br/>
and you may offer support or warranty protection for a fee.<br/>
<br/>
&nbsp;&nbsp;5. Conveying Modified Source Versions.<br/>
<br/>
&nbsp;&nbsp;You may convey a work based on the Program, or the modifications to<br/>
produce it from the Program, in the form of source code under the<br/>
terms of section 4, provided that you also meet all of these conditions:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a) The work must carry prominent notices stating that you modified<br/>
&nbsp;&nbsp;&nbsp;&nbsp;it, and giving a relevant date.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b) The work must carry prominent notices stating that it is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;released under this License and any conditions added under section<br/>
&nbsp;&nbsp;&nbsp;&nbsp;7.&nbsp;&nbsp;This requirement modifies the requirement in section 4 to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"keep intact all notices".<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c) You must license the entire work, as a whole, under this<br/>
&nbsp;&nbsp;&nbsp;&nbsp;License to anyone who comes into possession of a copy.&nbsp;&nbsp;This<br/>
&nbsp;&nbsp;&nbsp;&nbsp;License will therefore apply, along with any applicable section 7<br/>
&nbsp;&nbsp;&nbsp;&nbsp;additional terms, to the whole of the work, and all its parts,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;regardless of how they are packaged.&nbsp;&nbsp;This License gives no<br/>
&nbsp;&nbsp;&nbsp;&nbsp;permission to license the work in any other way, but it does not<br/>
&nbsp;&nbsp;&nbsp;&nbsp;invalidate such permission if you have separately received it.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;d) If the work has interactive user interfaces, each must display<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Appropriate Legal Notices; however, if the Program has interactive<br/>
&nbsp;&nbsp;&nbsp;&nbsp;interfaces that do not display Appropriate Legal Notices, your<br/>
&nbsp;&nbsp;&nbsp;&nbsp;work need not make them do so.<br/>
<br/>
&nbsp;&nbsp;A compilation of a covered work with other separate and independent<br/>
works, which are not by their nature extensions of the covered work,<br/>
and which are not combined with it such as to form a larger program,<br/>
in or on a volume of a storage or distribution medium, is called an<br/>
"aggregate" if the compilation and its resulting copyright are not<br/>
used to limit the access or legal rights of the compilation's users<br/>
beyond what the individual works permit.&nbsp;&nbsp;Inclusion of a covered work<br/>
in an aggregate does not cause this License to apply to the other<br/>
parts of the aggregate.<br/>
<br/>
&nbsp;&nbsp;6. Conveying Non-Source Forms.<br/>
<br/>
&nbsp;&nbsp;You may convey a covered work in object code form under the terms<br/>
of sections 4 and 5, provided that you also convey the<br/>
machine-readable Corresponding Source under the terms of this License,<br/>
in one of these ways:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a) Convey the object code in, or embodied in, a physical product<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(including a physical distribution medium), accompanied by the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Corresponding Source fixed on a durable physical medium<br/>
&nbsp;&nbsp;&nbsp;&nbsp;customarily used for software interchange.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b) Convey the object code in, or embodied in, a physical product<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(including a physical distribution medium), accompanied by a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;written offer, valid for at least three years and valid for as<br/>
&nbsp;&nbsp;&nbsp;&nbsp;long as you offer spare parts or customer support for that product<br/>
&nbsp;&nbsp;&nbsp;&nbsp;model, to give anyone who possesses the object code either (1) a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;copy of the Corresponding Source for all the software in the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;product that is covered by this License, on a durable physical<br/>
&nbsp;&nbsp;&nbsp;&nbsp;medium customarily used for software interchange, for a price no<br/>
&nbsp;&nbsp;&nbsp;&nbsp;more than your reasonable cost of physically performing this<br/>
&nbsp;&nbsp;&nbsp;&nbsp;conveying of source, or (2) access to copy the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Corresponding Source from a network server at no charge.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c) Convey individual copies of the object code with a copy of the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;written offer to provide the Corresponding Source.&nbsp;&nbsp;This<br/>
&nbsp;&nbsp;&nbsp;&nbsp;alternative is allowed only occasionally and noncommercially, and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;only if you received the object code with such an offer, in accord<br/>
&nbsp;&nbsp;&nbsp;&nbsp;with subsection 6b.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;d) Convey the object code by offering access from a designated<br/>
&nbsp;&nbsp;&nbsp;&nbsp;place (gratis or for a charge), and offer equivalent access to the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Corresponding Source in the same way through the same place at no<br/>
&nbsp;&nbsp;&nbsp;&nbsp;further charge.&nbsp;&nbsp;You need not require recipients to copy the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Corresponding Source along with the object code.&nbsp;&nbsp;If the place to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;copy the object code is a network server, the Corresponding Source<br/>
&nbsp;&nbsp;&nbsp;&nbsp;may be on a different server (operated by you or a third party)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;that supports equivalent copying facilities, provided you maintain<br/>
&nbsp;&nbsp;&nbsp;&nbsp;clear directions next to the object code saying where to find the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Corresponding Source.&nbsp;&nbsp;Regardless of what server hosts the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Corresponding Source, you remain obligated to ensure that it is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;available for as long as needed to satisfy these requirements.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e) Convey the object code using peer-to-peer transmission, provided<br/>
&nbsp;&nbsp;&nbsp;&nbsp;you inform other peers where the object code and Corresponding<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Source of the work are being offered to the general public at no<br/>
&nbsp;&nbsp;&nbsp;&nbsp;charge under subsection 6d.<br/>
<br/>
&nbsp;&nbsp;A separable portion of the object code, whose source code is excluded<br/>
from the Corresponding Source as a System Library, need not be<br/>
included in conveying the object code work.<br/>
<br/>
&nbsp;&nbsp;A "User Product" is either (1) a "consumer product", which means any<br/>
tangible personal property which is normally used for personal, family,<br/>
or household purposes, or (2) anything designed or sold for incorporation<br/>
into a dwelling.&nbsp;&nbsp;In determining whether a product is a consumer product,<br/>
doubtful cases shall be resolved in favor of coverage.&nbsp;&nbsp;For a particular<br/>
product received by a particular user, "normally used" refers to a<br/>
typical or common use of that class of product, regardless of the status<br/>
of the particular user or of the way in which the particular user<br/>
actually uses, or expects or is expected to use, the product.&nbsp;&nbsp;A product<br/>
is a consumer product regardless of whether the product has substantial<br/>
commercial, industrial or non-consumer uses, unless such uses represent<br/>
the only significant mode of use of the product.<br/>
<br/>
&nbsp;&nbsp;"Installation Information" for a User Product means any methods,<br/>
procedures, authorization keys, or other information required to install<br/>
and execute modified versions of a covered work in that User Product from<br/>
a modified version of its Corresponding Source.&nbsp;&nbsp;The information must<br/>
suffice to ensure that the continued functioning of the modified object<br/>
code is in no case prevented or interfered with solely because<br/>
modification has been made.<br/>
<br/>
&nbsp;&nbsp;If you convey an object code work under this section in, or with, or<br/>
specifically for use in, a User Product, and the conveying occurs as<br/>
part of a transaction in which the right of possession and use of the<br/>
User Product is transferred to the recipient in perpetuity or for a<br/>
fixed term (regardless of how the transaction is characterized), the<br/>
Corresponding Source conveyed under this section must be accompanied<br/>
by the Installation Information.&nbsp;&nbsp;But this requirement does not apply<br/>
if neither you nor any third party retains the ability to install<br/>
modified object code on the User Product (for example, the work has<br/>
been installed in ROM).<br/>
<br/>
&nbsp;&nbsp;The requirement to provide Installation Information does not include a<br/>
requirement to continue to provide support service, warranty, or updates<br/>
for a work that has been modified or installed by the recipient, or for<br/>
the User Product in which it has been modified or installed.&nbsp;&nbsp;Access to a<br/>
network may be denied when the modification itself materially and<br/>
adversely affects the operation of the network or violates the rules and<br/>
protocols for communication across the network.<br/>
<br/>
&nbsp;&nbsp;Corresponding Source conveyed, and Installation Information provided,<br/>
in accord with this section must be in a format that is publicly<br/>
documented (and with an implementation available to the public in<br/>
source code form), and must require no special password or key for<br/>
unpacking, reading or copying.<br/>
<br/>
&nbsp;&nbsp;7. Additional Terms.<br/>
<br/>
&nbsp;&nbsp;"Additional permissions" are terms that supplement the terms of this<br/>
License by making exceptions from one or more of its conditions.<br/>
Additional permissions that are applicable to the entire Program shall<br/>
be treated as though they were included in this License, to the extent<br/>
that they are valid under applicable law.&nbsp;&nbsp;If additional permissions<br/>
apply only to part of the Program, that part may be used separately<br/>
under those permissions, but the entire Program remains governed by<br/>
this License without regard to the additional permissions.<br/>
<br/>
&nbsp;&nbsp;When you convey a copy of a covered work, you may at your option<br/>
remove any additional permissions from that copy, or from any part of<br/>
it.&nbsp;&nbsp;(Additional permissions may be written to require their own<br/>
removal in certain cases when you modify the work.)&nbsp;&nbsp;You may place<br/>
additional permissions on material, added by you to a covered work,<br/>
for which you have or can give appropriate copyright permission.<br/>
<br/>
&nbsp;&nbsp;Notwithstanding any other provision of this License, for material you<br/>
add to a covered work, you may (if authorized by the copyright holders of<br/>
that material) supplement the terms of this License with terms:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;a) Disclaiming warranty or limiting liability differently from the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;terms of sections 15 and 16 of this License; or<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b) Requiring preservation of specified reasonable legal notices or<br/>
&nbsp;&nbsp;&nbsp;&nbsp;author attributions in that material or in the Appropriate Legal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Notices displayed by works containing it; or<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c) Prohibiting misrepresentation of the origin of that material, or<br/>
&nbsp;&nbsp;&nbsp;&nbsp;requiring that modified versions of such material be marked in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;reasonable ways as different from the original version; or<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;d) Limiting the use for publicity purposes of names of licensors or<br/>
&nbsp;&nbsp;&nbsp;&nbsp;authors of the material; or<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e) Declining to grant rights under trademark law for use of some<br/>
&nbsp;&nbsp;&nbsp;&nbsp;trade names, trademarks, or service marks; or<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f) Requiring indemnification of licensors and authors of that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;material by anyone who conveys the material (or modified versions of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;it) with contractual assumptions of liability to the recipient, for<br/>
&nbsp;&nbsp;&nbsp;&nbsp;any liability that these contractual assumptions directly impose on<br/>
&nbsp;&nbsp;&nbsp;&nbsp;those licensors and authors.<br/>
<br/>
&nbsp;&nbsp;All other non-permissive additional terms are considered "further<br/>
restrictions" within the meaning of section 10.&nbsp;&nbsp;If the Program as you<br/>
received it, or any part of it, contains a notice stating that it is<br/>
governed by this License along with a term that is a further<br/>
restriction, you may remove that term.&nbsp;&nbsp;If a license document contains<br/>
a further restriction but permits relicensing or conveying under this<br/>
License, you may add to a covered work material governed by the terms<br/>
of that license document, provided that the further restriction does<br/>
not survive such relicensing or conveying.<br/>
<br/>
&nbsp;&nbsp;If you add terms to a covered work in accord with this section, you<br/>
must place, in the relevant source files, a statement of the<br/>
additional terms that apply to those files, or a notice indicating<br/>
where to find the applicable terms.<br/>
<br/>
&nbsp;&nbsp;Additional terms, permissive or non-permissive, may be stated in the<br/>
form of a separately written license, or stated as exceptions;<br/>
the above requirements apply either way.<br/>
<br/>
&nbsp;&nbsp;8. Termination.<br/>
<br/>
&nbsp;&nbsp;You may not propagate or modify a covered work except as expressly<br/>
provided under this License.&nbsp;&nbsp;Any attempt otherwise to propagate or<br/>
modify it is void, and will automatically terminate your rights under<br/>
this License (including any patent licenses granted under the third<br/>
paragraph of section 11).<br/>
<br/>
&nbsp;&nbsp;However, if you cease all violation of this License, then your<br/>
license from a particular copyright holder is reinstated (a)<br/>
provisionally, unless and until the copyright holder explicitly and<br/>
finally terminates your license, and (b) permanently, if the copyright<br/>
holder fails to notify you of the violation by some reasonable means<br/>
prior to 60 days after the cessation.<br/>
<br/>
&nbsp;&nbsp;Moreover, your license from a particular copyright holder is<br/>
reinstated permanently if the copyright holder notifies you of the<br/>
violation by some reasonable means, this is the first time you have<br/>
received notice of violation of this License (for any work) from that<br/>
copyright holder, and you cure the violation prior to 30 days after<br/>
your receipt of the notice.<br/>
<br/>
&nbsp;&nbsp;Termination of your rights under this section does not terminate the<br/>
licenses of parties who have received copies or rights from you under<br/>
this License.&nbsp;&nbsp;If your rights have been terminated and not permanently<br/>
reinstated, you do not qualify to receive new licenses for the same<br/>
material under section 10.<br/>
<br/>
&nbsp;&nbsp;9. Acceptance Not Required for Having Copies.<br/>
<br/>
&nbsp;&nbsp;You are not required to accept this License in order to receive or<br/>
run a copy of the Program.&nbsp;&nbsp;Ancillary propagation of a covered work<br/>
occurring solely as a consequence of using peer-to-peer transmission<br/>
to receive a copy likewise does not require acceptance.&nbsp;&nbsp;However,<br/>
nothing other than this License grants you permission to propagate or<br/>
modify any covered work.&nbsp;&nbsp;These actions infringe copyright if you do<br/>
not accept this License.&nbsp;&nbsp;Therefore, by modifying or propagating a<br/>
covered work, you indicate your acceptance of this License to do so.<br/>
<br/>
&nbsp;&nbsp;10. Automatic Licensing of Downstream Recipients.<br/>
<br/>
&nbsp;&nbsp;Each time you convey a covered work, the recipient automatically<br/>
receives a license from the original licensors, to run, modify and<br/>
propagate that work, subject to this License.&nbsp;&nbsp;You are not responsible<br/>
for enforcing compliance by third parties with this License.<br/>
<br/>
&nbsp;&nbsp;An "entity transaction" is a transaction transferring control of an<br/>
organization, or substantially all assets of one, or subdividing an<br/>
organization, or merging organizations.&nbsp;&nbsp;If propagation of a covered<br/>
work results from an entity transaction, each party to that<br/>
transaction who receives a copy of the work also receives whatever<br/>
licenses to the work the party's predecessor in interest had or could<br/>
give under the previous paragraph, plus a right to possession of the<br/>
Corresponding Source of the work from the predecessor in interest, if<br/>
the predecessor has it or can get it with reasonable efforts.<br/>
<br/>
&nbsp;&nbsp;You may not impose any further restrictions on the exercise of the<br/>
rights granted or affirmed under this License.&nbsp;&nbsp;For example, you may<br/>
not impose a license fee, royalty, or other charge for exercise of<br/>
rights granted under this License, and you may not initiate litigation<br/>
(including a cross-claim or counterclaim in a lawsuit) alleging that<br/>
any patent claim is infringed by making, using, selling, offering for<br/>
sale, or importing the Program or any portion of it.<br/>
<br/>
&nbsp;&nbsp;11. Patents.<br/>
<br/>
&nbsp;&nbsp;A "contributor" is a copyright holder who authorizes use under this<br/>
License of the Program or a work on which the Program is based.&nbsp;&nbsp;The<br/>
work thus licensed is called the contributor's "contributor version".<br/>
<br/>
&nbsp;&nbsp;A contributor's "essential patent claims" are all patent claims<br/>
owned or controlled by the contributor, whether already acquired or<br/>
hereafter acquired, that would be infringed by some manner, permitted<br/>
by this License, of making, using, or selling its contributor version,<br/>
but do not include claims that would be infringed only as a<br/>
consequence of further modification of the contributor version.&nbsp;&nbsp;For<br/>
purposes of this definition, "control" includes the right to grant<br/>
patent sublicenses in a manner consistent with the requirements of<br/>
this License.<br/>
<br/>
&nbsp;&nbsp;Each contributor grants you a non-exclusive, worldwide, royalty-free<br/>
patent license under the contributor's essential patent claims, to<br/>
make, use, sell, offer for sale, import and otherwise run, modify and<br/>
propagate the contents of its contributor version.<br/>
<br/>
&nbsp;&nbsp;In the following three paragraphs, a "patent license" is any express<br/>
agreement or commitment, however denominated, not to enforce a patent<br/>
(such as an express permission to practice a patent or covenant not to<br/>
sue for patent infringement).&nbsp;&nbsp;To "grant" such a patent license to a<br/>
party means to make such an agreement or commitment not to enforce a<br/>
patent against the party.<br/>
<br/>
&nbsp;&nbsp;If you convey a covered work, knowingly relying on a patent license,<br/>
and the Corresponding Source of the work is not available for anyone<br/>
to copy, free of charge and under the terms of this License, through a<br/>
publicly available network server or other readily accessible means,<br/>
then you must either (1) cause the Corresponding Source to be so<br/>
available, or (2) arrange to deprive yourself of the benefit of the<br/>
patent license for this particular work, or (3) arrange, in a manner<br/>
consistent with the requirements of this License, to extend the patent<br/>
license to downstream recipients.&nbsp;&nbsp;"Knowingly relying" means you have<br/>
actual knowledge that, but for the patent license, your conveying the<br/>
covered work in a country, or your recipient's use of the covered work<br/>
in a country, would infringe one or more identifiable patents in that<br/>
country that you have reason to believe are valid.<br/>
<br/>
&nbsp;&nbsp;If, pursuant to or in connection with a single transaction or<br/>
arrangement, you convey, or propagate by procuring conveyance of, a<br/>
covered work, and grant a patent license to some of the parties<br/>
receiving the covered work authorizing them to use, propagate, modify<br/>
or convey a specific copy of the covered work, then the patent license<br/>
you grant is automatically extended to all recipients of the covered<br/>
work and works based on it.<br/>
<br/>
&nbsp;&nbsp;A patent license is "discriminatory" if it does not include within<br/>
the scope of its coverage, prohibits the exercise of, or is<br/>
conditioned on the non-exercise of one or more of the rights that are<br/>
specifically granted under this License.&nbsp;&nbsp;You may not convey a covered<br/>
work if you are a party to an arrangement with a third party that is<br/>
in the business of distributing software, under which you make payment<br/>
to the third party based on the extent of your activity of conveying<br/>
the work, and under which the third party grants, to any of the<br/>
parties who would receive the covered work from you, a discriminatory<br/>
patent license (a) in connection with copies of the covered work<br/>
conveyed by you (or copies made from those copies), or (b) primarily<br/>
for and in connection with specific products or compilations that<br/>
contain the covered work, unless you entered into that arrangement,<br/>
or that patent license was granted, prior to 28 March 2007.<br/>
<br/>
&nbsp;&nbsp;Nothing in this License shall be construed as excluding or limiting<br/>
any implied license or other defenses to infringement that may<br/>
otherwise be available to you under applicable patent law.<br/>
<br/>
&nbsp;&nbsp;12. No Surrender of Others' Freedom.<br/>
<br/>
&nbsp;&nbsp;If conditions are imposed on you (whether by court order, agreement or<br/>
otherwise) that contradict the conditions of this License, they do not<br/>
excuse you from the conditions of this License.&nbsp;&nbsp;If you cannot convey a<br/>
covered work so as to satisfy simultaneously your obligations under this<br/>
License and any other pertinent obligations, then as a consequence you may<br/>
not convey it at all.&nbsp;&nbsp;For example, if you agree to terms that obligate you<br/>
to collect a royalty for further conveying from those to whom you convey<br/>
the Program, the only way you could satisfy both those terms and this<br/>
License would be to refrain entirely from conveying the Program.<br/>
<br/>
&nbsp;&nbsp;13. Use with the GNU Affero General Public License.<br/>
<br/>
&nbsp;&nbsp;Notwithstanding any other provision of this License, you have<br/>
permission to link or combine any covered work with a work licensed<br/>
under version 3 of the GNU Affero General Public License into a single<br/>
combined work, and to convey the resulting work.&nbsp;&nbsp;The terms of this<br/>
License will continue to apply to the part which is the covered work,<br/>
but the special requirements of the GNU Affero General Public License,<br/>
section 13, concerning interaction through a network will apply to the<br/>
combination as such.<br/>
<br/>
&nbsp;&nbsp;14. Revised Versions of this License.<br/>
<br/>
&nbsp;&nbsp;The Free Software Foundation may publish revised and/or new versions of<br/>
the GNU General Public License from time to time.&nbsp;&nbsp;Such new versions will<br/>
be similar in spirit to the present version, but may differ in detail to<br/>
address new problems or concerns.<br/>
<br/>
&nbsp;&nbsp;Each version is given a distinguishing version number.&nbsp;&nbsp;If the<br/>
Program specifies that a certain numbered version of the GNU General<br/>
Public License "or any later version" applies to it, you have the<br/>
option of following the terms and conditions either of that numbered<br/>
version or of any later version published by the Free Software<br/>
Foundation.&nbsp;&nbsp;If the Program does not specify a version number of the<br/>
GNU General Public License, you may choose any version ever published<br/>
by the Free Software Foundation.<br/>
<br/>
&nbsp;&nbsp;If the Program specifies that a proxy can decide which future<br/>
versions of the GNU General Public License can be used, that proxy's<br/>
public statement of acceptance of a version permanently authorizes you<br/>
to choose that version for the Program.<br/>
<br/>
&nbsp;&nbsp;Later license versions may give you additional or different<br/>
permissions.&nbsp;&nbsp;However, no additional obligations are imposed on any<br/>
author or copyright holder as a result of your choosing to follow a<br/>
later version.<br/>
<br/>
&nbsp;&nbsp;15. Disclaimer of Warranty.<br/>
<br/>
&nbsp;&nbsp;THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY<br/>
APPLICABLE LAW.&nbsp;&nbsp;EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT<br/>
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY<br/>
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,<br/>
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR<br/>
PURPOSE.&nbsp;&nbsp;THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM<br/>
IS WITH YOU.&nbsp;&nbsp;SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF<br/>
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.<br/>
<br/>
&nbsp;&nbsp;16. Limitation of Liability.<br/>
<br/>
&nbsp;&nbsp;IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING<br/>
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS<br/>
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY<br/>
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE<br/>
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF<br/>
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD<br/>
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),<br/>
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF<br/>
SUCH DAMAGES.<br/>
<br/>
&nbsp;&nbsp;17. Interpretation of Sections 15 and 16.<br/>
<br/>
&nbsp;&nbsp;If the disclaimer of warranty and limitation of liability provided<br/>
above cannot be given local legal effect according to their terms,<br/>
reviewing courts shall apply local law that most closely approximates<br/>
an absolute waiver of all civil liability in connection with the<br/>
Program, unless a warranty or assumption of liability accompanies a<br/>
copy of the Program in return for a fee.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END OF TERMS AND CONDITIONS<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How to Apply These Terms to Your New Programs<br/>
<br/>
&nbsp;&nbsp;If you develop a new program, and you want it to be of the greatest<br/>
possible use to the public, the best way to achieve this is to make it<br/>
free software which everyone can redistribute and change under these terms.<br/>
<br/>
&nbsp;&nbsp;To do so, attach the following notices to the program.&nbsp;&nbsp;It is safest<br/>
to attach them to the start of each source file to most effectively<br/>
state the exclusion of warranty; and each file should have at least<br/>
the "copyright" line and a pointer to where the full notice is found.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;one line to give the program's name and a brief idea of what it does.&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Copyright (C) &lt;year&gt;&nbsp;&nbsp;&lt;name of author&gt;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;This program is free software: you can redistribute it and/or modify<br/>
&nbsp;&nbsp;&nbsp;&nbsp;it under the terms of the GNU General Public License as published by<br/>
&nbsp;&nbsp;&nbsp;&nbsp;the Free Software Foundation, either version 3 of the License, or<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(at your option) any later version.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;This program is distributed in the hope that it will be useful,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;GNU General Public License for more details.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;You should have received a copy of the GNU General Public License<br/>
&nbsp;&nbsp;&nbsp;&nbsp;along with this program.&nbsp;&nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
<br/>
Also add information on how to contact you by electronic and paper mail.<br/>
<br/>
&nbsp;&nbsp;If the program does terminal interaction, make it output a short<br/>
notice like this when it starts in an interactive mode:<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;program&gt;&nbsp;&nbsp;Copyright (C) &lt;year&gt;&nbsp;&nbsp;&lt;name of author&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;This is free software, and you are welcome to redistribute it<br/>
&nbsp;&nbsp;&nbsp;&nbsp;under certain conditions; type `show c' for details.<br/>
<br/>
The hypothetical commands `show w' and `show c' should show the appropriate<br/>
parts of the General Public License.&nbsp;&nbsp;Of course, your program's commands<br/>
might be different; for a GUI interface, you would use an "about box".<br/>
<br/>
&nbsp;&nbsp;You should also get your employer (if you work as a programmer) or school,<br/>
if any, to sign a "copyright disclaimer" for the program, if necessary.<br/>
For more information on this, and how to apply and follow the GNU GPL, see<br/>
&lt;http://www.gnu.org/licenses/&gt;.<br/>
<br/>
&nbsp;&nbsp;The GNU General Public License does not permit incorporating your program<br/>
into proprietary programs.&nbsp;&nbsp;If your program is a subroutine library, you<br/>
may consider it more useful to permit linking proprietary applications with<br/>
the library.&nbsp;&nbsp;If this is what you want to do, use the GNU Lesser General<br/>
Public License instead of this License.&nbsp;&nbsp;But first, please read<br/>
&lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardkalmanfilter.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardkalmanfilter.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "standardkalmanfilter.h"<br/>
<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
<br/>
#include "matrix.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::kalman::StandardKalmanFilter::StandardKalmanFilter(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterCalculationElements&gt;&amp; calculation,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: KalmanFilter{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_covariance_estimate{boost::dynamic_pointer_cast&lt;const StandardKalmanFilterParameters&gt;(parameters)-&gt;GetInitialCovarianceEstimate()},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_last_standard_calculation{boost::dynamic_pointer_cast&lt;StandardKalmanFilterCalculationElements&gt;(calculation)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_standard_parameters{boost::dynamic_pointer_cast&lt;const StandardKalmanFilterParameters&gt;(parameters)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_state_estimate{boost::dynamic_pointer_cast&lt;const StandardKalmanFilterParameters&gt;(parameters)-&gt;GetInitialStateEstimate()}<br/>
{<br/>
&nbsp;&nbsp;assert(m_last_standard_calculation);<br/>
&nbsp;&nbsp;assert(m_standard_parameters);<br/>
&nbsp;&nbsp;assert(this-&gt;GetType() == m_last_standard_calculation-&gt;GetType());<br/>
&nbsp;&nbsp;assert(this-&gt;GetType() == parameters-&gt;GetType());<br/>
&nbsp;&nbsp;assert(this-&gt;GetType() == m_standard_parameters-&gt;GetType());<br/>
&nbsp;&nbsp;assert(this-&gt;GetType() == GetParameters()-&gt;GetType()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Initialize each Kalman filter type with the right type of parameters");<br/>
<br/>
&nbsp;&nbsp;//m_covariance_estimate = m_standard_parameters-&gt;GetInitialCovarianceEstimate();<br/>
&nbsp;&nbsp;//m_state_estimate = m_standard_parameters-&gt;GetInitialStateEstimate();<br/>
<br/>
&nbsp;&nbsp;//Do not initialize the calculation yet<br/>
&nbsp;&nbsp;//m_last_standard_calculation-&gt;m_predicted_state = m_standard_parameters-&gt;GetInitialStateEstimate();<br/>
&nbsp;&nbsp;//m_last_standard_calculation-&gt;m_predicted_covariance = m_standard_parameters-&gt;GetInitialCovarianceEstimate();<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;//Check for correct dimensionality<br/>
&nbsp;&nbsp;const auto sz = m_state_estimate.size();<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetControl().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetControl().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetEstimatedMeasurementNoise().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetEstimatedMeasurementNoise().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetObservation().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetObservation().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_covariance_estimate.size1() == sz);<br/>
&nbsp;&nbsp;assert(m_covariance_estimate.size2() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetEstimatedProcessNoiseCovariance().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetEstimatedProcessNoiseCovariance().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetStateTransition().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetStateTransition().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_state_estimate.size() == sz);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
int ribi::kalman::StandardKalmanFilter::GetStateSize() const noexcept<br/>
{<br/>
&nbsp;&nbsp;const int sz = boost::numeric_cast&lt;int&gt;(m_state_estimate.size());<br/>
&nbsp;&nbsp;return sz;<br/>
}<br/>
<br/>
const std::string ribi::kalman::StandardKalmanFilter::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.0";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::StandardKalmanFilter::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-04-28: version 1.0: initial version"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt; ribi::kalman::StandardKalmanFilter::PredictState(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input) const<br/>
{<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; state_prediction<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(m_standard_parameters-&gt;GetStateTransition(),m_state_estimate)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ Matrix::Prod(m_standard_parameters-&gt;GetControl(),input);<br/>
&nbsp;&nbsp;return state_prediction;<br/>
}<br/>
<br/>
const boost::numeric::ublas::matrix&lt;double&gt; ribi::kalman::StandardKalmanFilter::PredictCovariance() const<br/>
{<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; covariance_prediction<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::MultiProd(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_standard_parameters-&gt;GetStateTransition(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans(m_standard_parameters-&gt;GetStateTransition())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ m_standard_parameters-&gt;GetEstimatedProcessNoiseCovariance();<br/>
&nbsp;&nbsp;return covariance_prediction;<br/>
}<br/>
<br/>
<br/>
void ribi::kalman::StandardKalmanFilter::SupplyMeasurementAndInput(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurements,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input)<br/>
{<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::identity_matrix;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::matrix;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::trans;<br/>
&nbsp;&nbsp;using boost::numeric::ublas::vector;<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;///Debug statements to keep code below clean<br/>
&nbsp;&nbsp;assert(measurements.size() == input.size());<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;assert(m_standard_parameters-&gt;GetStateTransition().size2() == m_covariance_estimate.size1());<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;assert(Matrix::Prod(m_standard_parameters-&gt;GetStateTransition(),m_covariance_estimate).size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;==&nbsp;&nbsp;trans(m_standard_parameters-&gt;GetStateTransition()).size1() );<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;assert(matrix&lt;double&gt;(Matrix::Prod(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix&lt;double&gt;(Matrix::Prod(m_standard_parameters-&gt;GetStateTransition(),m_covariance_estimate)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans(m_standard_parameters-&gt;GetStateTransition()))).size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;== m_standard_parameters-&gt;GetEstimatedProcessNoiseCovariance().size1());<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;assert(matrix&lt;double&gt;(Matrix::Prod(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix&lt;double&gt;(Matrix::Prod(m_standard_parameters-&gt;GetStateTransition(),m_covariance_estimate)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trans(m_standard_parameters-&gt;GetStateTransition()))).size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;== m_standard_parameters-&gt;GetEstimatedProcessNoiseCovariance().size2());<br/>
&nbsp;&nbsp;<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;//Store calculation for KalmanFilterExperiment<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;Clear();<br/>
&nbsp;&nbsp;//assert(!m_last_standard_calculation-&gt;IsComplete()); //Can be empty and thus complete<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetPreviousStateEstimate(this-&gt;GetStateEstimate()); //1<br/>
&nbsp;&nbsp;assert(!m_last_standard_calculation-&gt;IsComplete() || input.empty()); //Can be empty or incomplete<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetPreviousCovarianceEstimate(this-&gt;GetEstimationErrorCovariance()); //2<br/>
<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;// 1/7) State prediction<br/>
&nbsp;&nbsp;const vector&lt;double&gt; state_prediction = PredictState(input);<br/>
&nbsp;&nbsp;// 2/7) Covariance prediction<br/>
&nbsp;&nbsp;const matrix&lt;double&gt; covariance_prediction = PredictCovariance();<br/>
&nbsp;&nbsp;// 3/7) Innovation (y with a squiggle above it)<br/>
&nbsp;&nbsp;const vector&lt;double&gt; innovation = measurements - Matrix::Prod(m_standard_parameters-&gt;GetObservation(),state_prediction);<br/>
&nbsp;&nbsp;// 4/7) Innovation covariance (S)<br/>
&nbsp;&nbsp;const matrix&lt;double&gt; innovation_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::MultiProd(m_standard_parameters-&gt;GetObservation(),covariance_prediction,trans(m_standard_parameters-&gt;GetObservation()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ m_standard_parameters-&gt;GetEstimatedMeasurementNoise();<br/>
&nbsp;&nbsp;// 5/7) Kalman gain (K)<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;if (Matrix::CalcDeterminant(innovation_covariance) == 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("Innovation covariance became degenerate");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;const matrix&lt;double&gt; kalman_gain<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::MultiProd(covariance_prediction,trans(m_standard_parameters-&gt;GetObservation()),Matrix::Inverse(innovation_covariance));<br/>
&nbsp;&nbsp;// 6/7) Update state prediction<br/>
&nbsp;&nbsp;m_state_estimate = state_prediction + Matrix::Prod(kalman_gain,innovation);<br/>
&nbsp;&nbsp;// 7/7) Update covariance prediction<br/>
&nbsp;&nbsp;const identity_matrix&lt;double&gt; my_identity_matrix(kalman_gain.size1());<br/>
&nbsp;&nbsp;m_covariance_estimate = Matrix::Prod(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_identity_matrix<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Matrix::Prod(kalman_gain,m_standard_parameters-&gt;GetObservation()),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;covariance_prediction<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//Store calculation for KalmanFilterExperiment<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetPredictedState(state_prediction); //1<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetPredictedCovariance(covariance_prediction); //2<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetInnovation(innovation); //3<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetMeasurement(measurements); //3<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetInnovationCovariance(innovation_covariance); //4<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetKalmanGain(kalman_gain); //5<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetUpdatedState(m_state_estimate); //6<br/>
&nbsp;&nbsp;m_last_standard_calculation-&gt;SetUpdatedCovariance(m_covariance_estimate); //7<br/>
&nbsp;&nbsp;assert(m_last_standard_calculation-&gt;IsComplete());<br/>
&nbsp;&nbsp;<br/>
}<br/>
<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardkalmanfilter.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardkalmanfilter.h" border = "1"><tr><td><code>
#ifndef STANDARDKALMANFILTER_H<br/>
#define STANDARDKALMANFILTER_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfilter.h"<br/>
#include "standardkalmanfilterparameters.h"<br/>
#include "standardkalmanfiltercalculationelements.h"<br/>
<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///A discrete time Kalman filter<br/>
struct StandardKalmanFilter : public KalmanFilter<br/>
{<br/>
&nbsp;&nbsp;///Obtain the estimation error covariance ('P'), which is updated during SupplyMeasurementAndInput<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetEstimationErrorCovariance() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_covariance_estimate; }<br/>
<br/>
&nbsp;&nbsp;///Get the Kalman filter last calculation elements<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; GetLastCalculation() const noexcept<br/>
&nbsp;&nbsp;{ return m_last_standard_calculation; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the (downcasted) calculation<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterCalculationElements&gt; GetLastStandardCalculation() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_last_standard_calculation; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt; GetParameters() const noexcept<br/>
&nbsp;&nbsp;{ return m_standard_parameters; }<br/>
<br/>
&nbsp;&nbsp;///The downcasted parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; GetStandardParameters() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_standard_parameters; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the number of values a state consists of<br/>
&nbsp;&nbsp;int GetStateSize() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the current prediction of the state ('x')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetStateEstimate() const noexcept { return m_state_estimate; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const noexcept { return KalmanFilterType::standard; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Give the filter a measurement and input, and it will update its predictions<br/>
&nbsp;&nbsp;///Also logs the calculation<br/>
&nbsp;&nbsp;void SupplyMeasurementAndInput(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurements,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input);<br/>
<br/>
&nbsp;&nbsp;///Let the filter estimate the next state<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; PredictState(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input) const;<br/>
<br/>
&nbsp;&nbsp;///Let the filter estimate the next estimation error covariance<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; PredictCovariance() const;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Initialize the filter with a first measurent<br/>
&nbsp;&nbsp;explicit StandardKalmanFilter(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterCalculationElements&gt;&amp; calculation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;friend class StandardKalmanFilterFactory;<br/>
<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~StandardKalmanFilter() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(StandardKalmanFilter*);<br/>
<br/>
&nbsp;&nbsp;///P: The estimation error covariance<br/>
&nbsp;&nbsp;boost::numeric::ublas::matrix&lt;double&gt; m_covariance_estimate;<br/>
<br/>
&nbsp;&nbsp;///The downcasted parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterCalculationElements&gt; m_last_standard_calculation;<br/>
<br/>
&nbsp;&nbsp;///The Kalman filter parameters<br/>
&nbsp;&nbsp;//const boost::shared_ptr&lt;const KalmanFilterParameters&gt; m_parameters;<br/>
<br/>
&nbsp;&nbsp;///The downcasted parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardKalmanFilterParameters&gt; m_standard_parameters;<br/>
<br/>
&nbsp;&nbsp;///x: The (current prediction of the) state<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_state_estimate;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STANDARDKALMANFILTER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardkalmanfiltercalculationelements.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardkalmanfiltercalculationelements.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "standardkalmanfiltercalculationelements.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
ribi::kalman::StandardKalmanFilterCalculationElements::StandardKalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;//Base<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state,<br/>
&nbsp;&nbsp;//This class<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; innovation,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; innovation_covariance,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; kalman_gain,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; predicted_covariance,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; previous_covariance_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; updated_covariance)<br/>
&nbsp;&nbsp;: KalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;measurement,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predicted_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previous_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updated_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_innovation{innovation},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_innovation_covariance{innovation_covariance},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_kalman_gain{kalman_gain},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_predicted_covariance{predicted_covariance},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_previous_covariance_estimate{previous_covariance_estimate},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_updated_covariance{updated_covariance}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;//size may be zero<br/>
&nbsp;&nbsp;const std::size_t sz = m_innovation.size();<br/>
&nbsp;&nbsp;//Base<br/>
&nbsp;&nbsp;assert(sz == GetMeasurement().size());<br/>
&nbsp;&nbsp;assert(sz == GetPredictedState().size());<br/>
&nbsp;&nbsp;assert(sz == GetPreviousState().size());<br/>
&nbsp;&nbsp;assert(sz == GetUpdatedState().size());<br/>
&nbsp;&nbsp;//This class<br/>
&nbsp;&nbsp;assert(sz == m_innovation.size());<br/>
&nbsp;&nbsp;assert(sz == m_innovation_covariance.size1());<br/>
&nbsp;&nbsp;assert(sz == m_innovation_covariance.size2());<br/>
&nbsp;&nbsp;assert(sz == m_kalman_gain.size1());<br/>
&nbsp;&nbsp;assert(sz == m_kalman_gain.size2());<br/>
&nbsp;&nbsp;assert(sz == m_predicted_covariance.size1());<br/>
&nbsp;&nbsp;assert(sz == m_predicted_covariance.size2());<br/>
&nbsp;&nbsp;assert(sz == m_previous_covariance_estimate.size1());<br/>
&nbsp;&nbsp;assert(sz == m_previous_covariance_estimate.size2());<br/>
&nbsp;&nbsp;assert(sz == m_updated_covariance.size1());<br/>
&nbsp;&nbsp;assert(sz == m_updated_covariance.size2());<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
void ribi::kalman::StandardKalmanFilterCalculationElements::Clear()<br/>
{<br/>
&nbsp;&nbsp;KalmanFilterCalculationElements::Clear();<br/>
&nbsp;&nbsp;m_innovation = boost::numeric::ublas::vector&lt;double&gt;();<br/>
&nbsp;&nbsp;assert(m_innovation.empty());<br/>
&nbsp;&nbsp;m_innovation_covariance = boost::numeric::ublas::matrix&lt;double&gt;();<br/>
&nbsp;&nbsp;m_kalman_gain = boost::numeric::ublas::matrix&lt;double&gt;();<br/>
&nbsp;&nbsp;m_predicted_covariance = boost::numeric::ublas::matrix&lt;double&gt;();<br/>
&nbsp;&nbsp;m_previous_covariance_estimate = boost::numeric::ublas::matrix&lt;double&gt;();<br/>
&nbsp;&nbsp;m_updated_covariance = boost::numeric::ublas::matrix&lt;double&gt;();<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::KalmanFilterCalculationElements&gt; ribi::kalman::StandardKalmanFilterCalculationElements::Clone() const<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; p(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Base<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetMeasurement(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetPredictedState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetPreviousState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetUpdatedState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Derived class<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetInnovation(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetInnovationCovariance(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetKalmanGain(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetPredicatedCovariance(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetPreviousCovarianceEstimate(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetUpdatedCovariance()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;assert(p-&gt;GetType() == this-&gt;GetType());<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
bool ribi::kalman::StandardKalmanFilterCalculationElements::IsComplete() const<br/>
{<br/>
&nbsp;&nbsp;const std::size_t sz = m_innovation.size();<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //sz != 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sz == m_innovation.size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_innovation_covariance.size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_innovation_covariance.size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_innovation_covariance.size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_innovation_covariance.size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_kalman_gain.size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_kalman_gain.size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetMeasurement().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_predicted_covariance.size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_predicted_covariance.size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetPredictedState().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_previous_covariance_estimate.size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_previous_covariance_estimate.size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetPreviousState().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_updated_covariance.size1()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == m_updated_covariance.size2()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetUpdatedState().size();<br/>
}<br/>
<br/>
void ribi::kalman::StandardKalmanFilterCalculationElements::SetInnovation(const boost::numeric::ublas::vector&lt;double&gt;&amp; innovation)<br/>
{<br/>
&nbsp;&nbsp;assert(m_innovation.empty());<br/>
&nbsp;&nbsp;m_innovation = innovation;<br/>
}<br/>
<br/>
void ribi::kalman::StandardKalmanFilterCalculationElements::SetInnovationCovariance(const boost::numeric::ublas::matrix&lt;double&gt;&amp; innovation_covariance)<br/>
{<br/>
&nbsp;&nbsp;assert(m_innovation_covariance.size1() == 0);<br/>
&nbsp;&nbsp;assert(m_innovation_covariance.size2() == 0);<br/>
&nbsp;&nbsp;m_innovation_covariance = innovation_covariance;<br/>
}<br/>
<br/>
void ribi::kalman::StandardKalmanFilterCalculationElements::SetKalmanGain(const boost::numeric::ublas::matrix&lt;double&gt;&amp; kalman_gain)<br/>
{<br/>
&nbsp;&nbsp;assert(m_kalman_gain.size1() == 0);<br/>
&nbsp;&nbsp;assert(m_kalman_gain.size2() == 0);<br/>
&nbsp;&nbsp;m_kalman_gain = kalman_gain;<br/>
}<br/>
<br/>
void ribi::kalman::StandardKalmanFilterCalculationElements::SetPredictedCovariance(const boost::numeric::ublas::matrix&lt;double&gt;&amp; predicted_covariance)<br/>
{<br/>
&nbsp;&nbsp;assert(m_predicted_covariance.size1() == 0);<br/>
&nbsp;&nbsp;assert(m_predicted_covariance.size2() == 0);<br/>
&nbsp;&nbsp;m_predicted_covariance = predicted_covariance;<br/>
}<br/>
<br/>
void ribi::kalman::StandardKalmanFilterCalculationElements::SetPreviousCovarianceEstimate(const boost::numeric::ublas::matrix&lt;double&gt;&amp; previous_covariance_estimate)<br/>
{<br/>
&nbsp;&nbsp;assert(m_previous_covariance_estimate.size1() == 0);<br/>
&nbsp;&nbsp;assert(m_previous_covariance_estimate.size2() == 0);<br/>
&nbsp;&nbsp;m_previous_covariance_estimate = previous_covariance_estimate;<br/>
}<br/>
<br/>
void ribi::kalman::StandardKalmanFilterCalculationElements::SetUpdatedCovariance(const boost::numeric::ublas::matrix&lt;double&gt;&amp; updated_covariance)<br/>
{<br/>
&nbsp;&nbsp;assert(m_updated_covariance.size1() == 0);<br/>
&nbsp;&nbsp;assert(m_updated_covariance.size2() == 0);<br/>
&nbsp;&nbsp;m_updated_covariance = updated_covariance;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardkalmanfiltercalculationelements.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardkalmanfiltercalculationelements.h" border = "1"><tr><td><code>
#ifndef STANDARDKALMANFILTERCALCULATIONELEMENTS_H<br/>
#define STANDARDKALMANFILTERCALCULATIONELEMENTS_H<br/>
<br/>
#include "kalmanfiltertype.h"<br/>
#include "kalmanfiltercalculationelements.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///The elements of a standard Kalman filter calculation<br/>
struct StandardKalmanFilterCalculationElements : public KalmanFilterCalculationElements<br/>
{<br/>
&nbsp;&nbsp;explicit StandardKalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Base<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//This class<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; innovation = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; innovation_covariance = boost::numeric::ublas::matrix&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; kalman_gain = boost::numeric::ublas::matrix&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; predicted_covariance = boost::numeric::ublas::matrix&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; previous_covariance_estimate = boost::numeric::ublas::matrix&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; updated_covariance = boost::numeric::ublas::matrix&lt;double&gt;());<br/>
<br/>
&nbsp;&nbsp;///Clear the calculation, will set IsComplete to false<br/>
&nbsp;&nbsp;void Clear();<br/>
<br/>
&nbsp;&nbsp;///Produce a deep copy of the derived class<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; Clone() const;<br/>
<br/>
&nbsp;&nbsp;///Obtain the innovation ('y_squiggle')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetInnovation() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_innovation; }<br/>
<br/>
&nbsp;&nbsp;///Obtain he innovation covariance ('S')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetInnovationCovariance() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_innovation_covariance; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman gain ('K')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetKalmanGain() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_kalman_gain; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the predicted error estimation covariance ('P_predicted')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetPredicatedCovariance() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_predicted_covariance; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the previous_covariance_estimate ('P_prev'/'P_n-1')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetPreviousCovarianceEstimate() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_previous_covariance_estimate; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const { return KalmanFilterType::standard; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the updated error estimation covariance (in the end of each timestep)<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetUpdatedCovariance() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_updated_covariance; }<br/>
<br/>
&nbsp;&nbsp;///Checks if the state is complete and valid<br/>
&nbsp;&nbsp;bool IsComplete() const;<br/>
<br/>
&nbsp;&nbsp;///Set the innovation ('y_squiggle')<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetInnovation(const boost::numeric::ublas::vector&lt;double&gt;&amp; innovation);<br/>
<br/>
&nbsp;&nbsp;///Set the innovation covariance ('S')<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetInnovationCovariance(const boost::numeric::ublas::matrix&lt;double&gt;&amp; innovation_covariance);<br/>
<br/>
&nbsp;&nbsp;///Set the Kalman gain ('K')<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetKalmanGain(const boost::numeric::ublas::matrix&lt;double&gt;&amp; kalman_gain);<br/>
<br/>
&nbsp;&nbsp;///Set the predicted error estimation covariance ('P_predicted')<br/>
&nbsp;&nbsp;///Calculated at step 2 of the algorithm:<br/>
&nbsp;&nbsp;///2) P_predicted = [...] P_n-1 [...]<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetPredictedCovariance(const boost::numeric::ublas::matrix&lt;double&gt;&amp; predicted_covariance);<br/>
<br/>
&nbsp;&nbsp;///Set the previous_covariance_estimate ('P_prev'/'P_n-1')<br/>
&nbsp;&nbsp;///Is read at step 2 of the algorithm:<br/>
&nbsp;&nbsp;///2) P_predicted = [...] P_n-1 [...]<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetPreviousCovarianceEstimate(const boost::numeric::ublas::matrix&lt;double&gt;&amp; previous_covariance_estimate);<br/>
<br/>
&nbsp;&nbsp;///Set the updated error estimation covariance (in the end of each timestep)<br/>
&nbsp;&nbsp;///Calculated at step 7 of the algorithm:<br/>
&nbsp;&nbsp;///2) P_n = [...] P_predicted<br/>
&nbsp;&nbsp;///Fails if already set<br/>
&nbsp;&nbsp;void SetUpdatedCovariance(const boost::numeric::ublas::matrix&lt;double&gt;&amp; updated_covariance);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~StandardKalmanFilterCalculationElements() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(StandardKalmanFilterCalculationElements*);<br/>
<br/>
&nbsp;&nbsp;///The innovation ('y_squiggle')<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_innovation;<br/>
<br/>
&nbsp;&nbsp;///The innovation covariance ('S')<br/>
&nbsp;&nbsp;boost::numeric::ublas::matrix&lt;double&gt; m_innovation_covariance;<br/>
<br/>
&nbsp;&nbsp;///The Kalman gain ('K')<br/>
&nbsp;&nbsp;boost::numeric::ublas::matrix&lt;double&gt; m_kalman_gain;<br/>
<br/>
&nbsp;&nbsp;///The predicted error estimation covariance ('P_predicted')<br/>
&nbsp;&nbsp;///Calculated at step 2 of the algorithm:<br/>
&nbsp;&nbsp;///2) P_predicted = [...] P_n-1 [...]<br/>
&nbsp;&nbsp;boost::numeric::ublas::matrix&lt;double&gt; m_predicted_covariance;<br/>
<br/>
&nbsp;&nbsp;///The previous_covariance_estimate ('P_prev'/'P_n-1')<br/>
&nbsp;&nbsp;///Is read at step 2 of the algorithm:<br/>
&nbsp;&nbsp;///2) P_predicted = [...] P_n-1 [...]<br/>
&nbsp;&nbsp;boost::numeric::ublas::matrix&lt;double&gt; m_previous_covariance_estimate;<br/>
<br/>
&nbsp;&nbsp;///The updated error estimation covariance (in the end of each timestep)<br/>
&nbsp;&nbsp;///Calculated at step 7 of the algorithm:<br/>
&nbsp;&nbsp;///2) P_n = [...] P_predicted<br/>
&nbsp;&nbsp;boost::numeric::ublas::matrix&lt;double&gt; m_updated_covariance;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STANDARDKALMANFILTERCALCULATIONELEMENTS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardkalmanfilterfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardkalmanfilterfactory.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "standardkalmanfilterfactory.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::StandardKalmanFilter&gt; ribi::kalman::StandardKalmanFilterFactory::Create(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;assert(parameters-&gt;GetType() == KalmanFilterType::standard);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilterCalculationElements&gt; calculation{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilterCalculationElements<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;assert(calculation);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardKalmanFilter&gt; kalman_filter{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardKalmanFilter(calculation,parameters)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(kalman_filter);<br/>
&nbsp;&nbsp;assert(kalman_filter-&gt;GetType() == KalmanFilterType::standard);<br/>
&nbsp;&nbsp;return kalman_filter;<br/>
}<br/>
<br/>
<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardkalmanfilterfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardkalmanfilterfactory.h" border = "1"><tr><td><code>
#ifndef STANDARDKALMANFILTERFACTORY_H<br/>
#define STANDARDKALMANFILTERFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "standardkalmanfilter.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Factory for StandardKalmanFilter<br/>
struct StandardKalmanFilterFactory<br/>
{<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;StandardKalmanFilter&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STANDARDKALMANFILTERFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardkalmanfilterparameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardkalmanfilterparameters.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "standardkalmanfilterparameters.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include "matrix.h"<br/>
<br/>
ribi::kalman::StandardKalmanFilterParameters::StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; estimated_measurement_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; initial_covariance_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; observation,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
&nbsp;&nbsp;: KalmanFilterParameters{control,initial_state_estimate,observation,state_transition},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_estimated_measurement_noise{estimated_measurement_noise},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_estimated_process_noise_covariance{estimated_process_noise_covariance},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_initial_covariance_estimate{initial_covariance_estimate}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;//Check for correct dimensionality<br/>
&nbsp;&nbsp;const std::size_t sz = GetInitialStateEstimate().size();<br/>
&nbsp;&nbsp;//assert(sz &gt;= 0); //Inevitable for std::size_t<br/>
&nbsp;&nbsp;assert(GetEstimatedMeasurementNoise().size1() == sz);<br/>
&nbsp;&nbsp;assert(GetEstimatedMeasurementNoise().size2() == sz);<br/>
&nbsp;&nbsp;assert(GetEstimatedProcessNoiseCovariance().size1() == sz);<br/>
&nbsp;&nbsp;assert(GetEstimatedProcessNoiseCovariance().size2() == sz);<br/>
&nbsp;&nbsp;assert(GetInitialCovarianceEstimate().size1() == sz);<br/>
&nbsp;&nbsp;assert(GetInitialCovarianceEstimate().size2() == sz);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
const std::string ribi::kalman::StandardKalmanFilterParameters::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.1";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::StandardKalmanFilterParameters::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-04-28: version 1.0: initial version",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-03: version 1.1: inhertic from KalmanFilterParameters"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
bool ribi::kalman::StandardKalmanFilterParameters::HasParameterType(const KalmanFilterParameterType type) noexcept<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type == KalmanFilterParameterType::control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::estimated_measurement_noise<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::estimated_process_noise_covariance<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::initial_covariance_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::state_transition;<br/>
}<br/>
<br/>
bool ribi::kalman::StandardKalmanFilterParameters::IsAboutEqual(const StandardKalmanFilterParameters&amp; lhs, const StandardKalmanFilterParameters&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix::MatricesAreAboutEqual(lhs.GetControl(),rhs.GetControl())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetEstimatedMeasurementNoise(),rhs.GetEstimatedMeasurementNoise())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetInitialCovarianceEstimate(),rhs.GetInitialCovarianceEstimate())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::VectorsAreAboutEqual(lhs.GetInitialStateEstimate(),rhs.GetInitialStateEstimate())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetObservation(),rhs.GetObservation())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetEstimatedProcessNoiseCovariance(),rhs.GetEstimatedProcessNoiseCovariance())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetStateTransition(),rhs.GetStateTransition());<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardkalmanfilterparameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardkalmanfilterparameters.h" border = "1"><tr><td><code>
#ifndef STANDARDKALMANFILTERPARAMETERS_H<br/>
#define STANDARDKALMANFILTERPARAMETERS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/checked_delete.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfilterparameters.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Parameters for the standard Kalman filter<br/>
struct StandardKalmanFilterParameters : public KalmanFilterParameters<br/>
{<br/>
&nbsp;&nbsp;explicit StandardKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; estimated_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; estimated_process_noise_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; initial_covariance_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;///Obtain the (estimated) measurement noise ('R')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetEstimatedMeasurementNoise() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_estimated_measurement_noise; }<br/>
<br/>
&nbsp;&nbsp;///P: The initial estimation error covariance estimate<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetInitialCovarianceEstimate() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_initial_covariance_estimate; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the process noise covariance ('Q')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetEstimatedProcessNoiseCovariance() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_estimated_process_noise_covariance; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const noexcept { return KalmanFilterType::standard; }<br/>
<br/>
&nbsp;&nbsp;///Check if two parameter sets are equal with a fuzzy compare<br/>
&nbsp;&nbsp;static bool IsAboutEqual(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const StandardKalmanFilterParameters&amp; lhs,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const StandardKalmanFilterParameters&amp; rhs) noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Check if this parameter set has a certain type of KalmanFilterParameter<br/>
&nbsp;&nbsp;static bool HasParameterType(const KalmanFilterParameterType type) noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~StandardKalmanFilterParameters() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(StandardKalmanFilterParameters*);<br/>
<br/>
&nbsp;&nbsp;///R: Estimated measurement noise<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_estimated_measurement_noise;<br/>
<br/>
&nbsp;&nbsp;///Q: The estimated process noise covariance<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_estimated_process_noise_covariance;<br/>
<br/>
&nbsp;&nbsp;///P: The initial estimation error covariance estimate<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_initial_covariance_estimate;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STANDARDKALMANFILTERPARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardwhitenoisesystem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardwhitenoisesystem.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "standardwhitenoisesystem.h"<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;boost/numeric/ublas/io.hpp&gt;<br/>
#include &lt;boost/random/lagged_fibonacci.hpp&gt;<br/>
#include &lt;boost/random/normal_distribution.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "matrix.h"<br/>
#include "trace.h"<br/>
#include "standardwhitenoisesystemparameters.h"<br/>
<br/>
ribi::kalman::StandardWhiteNoiseSystem::StandardWhiteNoiseSystem(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; parameters)<br/>
&nbsp;&nbsp;: WhiteNoiseSystem{parameters},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_parameters{boost::dynamic_pointer_cast&lt;const StandardWhiteNoiseSystemParameters&gt;(parameters)}<br/>
{<br/>
&nbsp;&nbsp;assert(m_parameters);<br/>
}<br/>
<br/>
const std::string ribi::kalman::StandardWhiteNoiseSystem::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.0";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::StandardWhiteNoiseSystem::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-04-28: version 1.0: initial version"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
void ribi::kalman::StandardWhiteNoiseSystem::GoToNextState()<br/>
{<br/>
&nbsp;&nbsp;//Create a no-input vector<br/>
&nbsp;&nbsp;const auto sz = GetCurrentState().size();<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; input(sz,0.0);<br/>
&nbsp;&nbsp;return GoToNextState(input);<br/>
}<br/>
<br/>
void ribi::kalman::StandardWhiteNoiseSystem::GoToNextState(const boost::numeric::ublas::vector&lt;double&gt;&amp; input)<br/>
{<br/>
&nbsp;&nbsp;//First do a perfect transition<br/>
&nbsp;&nbsp;assert(input.size() == GetCurrentState().size());<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetStateTransition().size1() == GetCurrentState().size());<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetStateTransition().size2() == GetCurrentState().size());<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetControl().size1() == input.size());<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetControl().size2() == input.size());<br/>
<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; new_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(m_parameters-&gt;GetStateTransition(),GetCurrentState())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ Matrix::Prod(m_parameters-&gt;GetControl(),input);<br/>
&nbsp;&nbsp;//Add process noise<br/>
&nbsp;&nbsp;const auto sz = new_state.size();<br/>
&nbsp;&nbsp;assert(new_state.size() == m_parameters-&gt;GetProcessNoise().size());<br/>
&nbsp;&nbsp;for (std::size_t i = 0; i!=sz; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new_state(i) = GetRandomNormal(new_state(i),m_parameters-&gt;GetProcessNoise()(i));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;SetNewCurrentState(new_state);<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt; ribi::kalman::StandardWhiteNoiseSystem::Measure() const noexcept<br/>
{<br/>
&nbsp;&nbsp;const auto sz = GetCurrentState().size();<br/>
&nbsp;&nbsp;assert(GetCurrentState().size() == m_parameters-&gt;GetMeasurementNoise().size());<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; measured(sz);<br/>
&nbsp;&nbsp;for (std::size_t i = 0; i!=sz; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;measured(i) = GetRandomNormal(GetCurrentState()(i),m_parameters-&gt;GetMeasurementNoise()(i));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return measured;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardwhitenoisesystem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardwhitenoisesystem.h" border = "1"><tr><td><code>
#ifndef STANDARDWHITENOISESYSTEM_H<br/>
#define STANDARDWHITENOISESYSTEM_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "standardwhitenoisesystemparameters.h"<br/>
#include "whitenoisesystem.h"<br/>
#include "whitenoisesystemparameters.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct StandardWhiteNoiseSystem : public WhiteNoiseSystem<br/>
{<br/>
&nbsp;&nbsp;///Obtain the type as an enum<br/>
&nbsp;&nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::standard; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state,<br/>
&nbsp;&nbsp;///without any input<br/>
&nbsp;&nbsp;void GoToNextState();<br/>
<br/>
&nbsp;&nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state<br/>
&nbsp;&nbsp;void GoToNextState(const boost::numeric::ublas::vector&lt;double&gt;&amp; input);<br/>
<br/>
&nbsp;&nbsp;///Measure a value from this system with normally distributed noise<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; Measure() const noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///StandardWhiteNoiseSystem can only be created by a StandardWhiteNoiseSystemFactory<br/>
&nbsp;&nbsp;explicit StandardWhiteNoiseSystem(const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; parameters);<br/>
&nbsp;&nbsp;friend class StandardWhiteNoiseSystemFactory;<br/>
<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~StandardWhiteNoiseSystem() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(StandardWhiteNoiseSystem*);<br/>
<br/>
&nbsp;&nbsp;///The parameters for the white noise system<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const StandardWhiteNoiseSystemParameters&gt; m_parameters;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STANDARDWHITENOISESYSTEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardwhitenoisesystemfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardwhitenoisesystemfactory.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "standardwhitenoisesystemfactory.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::StandardWhiteNoiseSystem&gt;<br/>
&nbsp;&nbsp;ribi::kalman::StandardWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;const ribi::kalman::StandardWhiteNoiseSystemParameters&gt; parameters{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_transition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardWhiteNoiseSystem&gt; system{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new StandardWhiteNoiseSystem(parameters)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(system);<br/>
&nbsp;&nbsp;return system;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::StandardWhiteNoiseSystem&gt;<br/>
&nbsp;&nbsp;ribi::kalman::StandardWhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystemParameters&gt;&amp; parameters<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;assert(parameters-&gt;GetType() == WhiteNoiseSystemType::standard);<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardWhiteNoiseSystemParameters&gt; standard_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= boost::dynamic_pointer_cast&lt;StandardWhiteNoiseSystemParameters&gt;(parameters);<br/>
&nbsp;&nbsp;assert(standard_parameters);<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;StandardWhiteNoiseSystem&gt; system<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetControl(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetInitialState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetMeasurementNoise(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetProcessNoise(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standard_parameters-&gt;GetStateTransition());<br/>
&nbsp;&nbsp;assert(system);<br/>
&nbsp;&nbsp;return system;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardwhitenoisesystemfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardwhitenoisesystemfactory.h" border = "1"><tr><td><code>
#ifndef STANDARDWHITENOISESYSTEMFACTORY_H<br/>
#define STANDARDWHITENOISESYSTEMFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "standardwhitenoisesystem.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct StandardWhiteNoiseSystemFactory<br/>
{<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;StandardWhiteNoiseSystem&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition);<br/>
<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;StandardWhiteNoiseSystem&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystemParameters&gt;&amp; parameters);<br/>
<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STANDARDWHITENOISESYSTEMFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardwhitenoisesystemparameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardwhitenoisesystemparameters.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "standardwhitenoisesystemparameters.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include "matrix.h"<br/>
<br/>
ribi::kalman::StandardWhiteNoiseSystemParameters::StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
&nbsp;&nbsp;: WhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state_transition)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
}<br/>
<br/>
const std::string ribi::kalman::StandardWhiteNoiseSystemParameters::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.0";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::StandardWhiteNoiseSystemParameters::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-04-28: version 1.0: initial version"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
bool ribi::kalman::StandardWhiteNoiseSystemParameters::IsAboutEqual(<br/>
&nbsp;&nbsp;const StandardWhiteNoiseSystemParameters&amp; lhs, const StandardWhiteNoiseSystemParameters&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix::MatricesAreAboutEqual(lhs.GetControl(),rhs.GetControl())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::VectorsAreAboutEqual(lhs.GetInitialState(),rhs.GetInitialState())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::VectorsAreAboutEqual(lhs.GetMeasurementNoise(),rhs.GetMeasurementNoise())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::VectorsAreAboutEqual(lhs.GetProcessNoise(),rhs.GetProcessNoise())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetStateTransition(),rhs.GetStateTransition());<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/standardwhitenoisesystemparameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/standardwhitenoisesystemparameters.h" border = "1"><tr><td><code>
#ifndef STANDARDWHITENOISESYSTEMPARAMETERS_H<br/>
#define STANDARDWHITENOISESYSTEMPARAMETERS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/checked_delete.hpp&gt;<br/>
#include "whitenoisesystemparameters.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct StandardWhiteNoiseSystemParameters : public WhiteNoiseSystemParameters<br/>
{<br/>
&nbsp;&nbsp;explicit StandardWhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition);<br/>
<br/>
&nbsp;&nbsp;///Obtain the type as an enum<br/>
&nbsp;&nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::standard; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Check two parameter sets for equality using a fuzzy comparison<br/>
&nbsp;&nbsp;static bool IsAboutEqual(const StandardWhiteNoiseSystemParameters&amp; lhs, const StandardWhiteNoiseSystemParameters&amp; rhs) noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~StandardWhiteNoiseSystemParameters() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(StandardWhiteNoiseSystemParameters*);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STANDARDWHITENOISESYSTEMPARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/steadystatekalmanfilter.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/steadystatekalmanfilter.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "steadystatekalmanfilter.h"<br/>
<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
<br/>
#include "matrix.h"<br/>
#include "kalmanfilter.h"<br/>
#include "kalmanfilterparameters.h"<br/>
#include "steadystatekalmanfilterparameters.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::kalman::SteadyStateKalmanFilter::SteadyStateKalmanFilter(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt;&amp; calculation,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters)<br/>
&nbsp;&nbsp;: KalmanFilter{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_last_calculation{boost::dynamic_pointer_cast&lt;SteadyStateKalmanFilterCalculationElements&gt;(calculation)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_parameters{boost::dynamic_pointer_cast&lt;const SteadyStateKalmanFilterParameters&gt;(parameters)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_state_estimate{dynamic_cast&lt;const SteadyStateKalmanFilterParameters*&gt;(parameters.get())-&gt;GetInitialStateEstimate()}<br/>
{<br/>
&nbsp;&nbsp;assert(m_last_calculation);<br/>
&nbsp;&nbsp;assert(m_parameters<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Initialize each Kalman filter type with the right type of parameters");<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;//Check for correct dimensionality<br/>
&nbsp;&nbsp;const auto sz = m_state_estimate.size();<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetControl().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetControl().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetEstimatedOptimalKalmanGain().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetEstimatedOptimalKalmanGain().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetObservation().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetObservation().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetStateTransition().size1() == sz);<br/>
&nbsp;&nbsp;assert(m_parameters-&gt;GetStateTransition().size2() == sz);<br/>
&nbsp;&nbsp;assert(m_state_estimate.size() == sz);<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;//Initialize the last calculation with null values<br/>
&nbsp;&nbsp;//NEW 2013-05-23<br/>
&nbsp;&nbsp;//m_last_calculation-&gt;SetMeasurement(<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;boost::numeric::ublas::zero_vector&lt;double&gt;(m_state_estimate.size()));<br/>
&nbsp;&nbsp;//m_last_calculation-&gt;SetPredictedState(m_parameters-&gt;GetInitialStateEstimate());<br/>
&nbsp;&nbsp;//m_last_calculation-&gt;SetPreviousStateEstimate(m_parameters-&gt;GetInitialStateEstimate());<br/>
&nbsp;&nbsp;//m_last_calculation-&gt;SetUpdatedState(m_parameters-&gt;GetInitialStateEstimate());<br/>
}<br/>
<br/>
int ribi::kalman::SteadyStateKalmanFilter::GetStateSize() const noexcept<br/>
{<br/>
&nbsp;&nbsp;const int sz = boost::numeric_cast&lt;int&gt;(m_state_estimate.size());<br/>
&nbsp;&nbsp;return sz;<br/>
}<br/>
<br/>
const std::string ribi::kalman::SteadyStateKalmanFilter::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.1";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::SteadyStateKalmanFilter::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-01: version 1.0: initial version",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-06: version 1.1: inherits from KalmanFilter"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
const boost::numeric::ublas::vector&lt;double&gt; ribi::kalman::SteadyStateKalmanFilter::PredictState(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input) const<br/>
{<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; term_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= m_parameters-&gt;GetStateTransition()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- Matrix::Prod(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_parameters-&gt;GetEstimatedOptimalKalmanGain(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_parameters-&gt;GetObservation()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;//m_last_measured must be set before calling PredictState!<br/>
&nbsp;&nbsp;assert(!m_last_calculation-&gt;GetMeasurement().empty());<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; state_prediction<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(term_a,this-&gt;GetStateEstimate())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ Matrix::Prod(m_parameters-&gt;GetControl(),input)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ Matrix::Prod(m_parameters-&gt;GetEstimatedOptimalKalmanGain(),m_last_calculation-&gt;GetMeasurement());<br/>
&nbsp;&nbsp;return state_prediction;<br/>
}<br/>
<br/>
void ribi::kalman::SteadyStateKalmanFilter::SupplyMeasurementAndInput(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurements,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input)<br/>
{<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;assert(measurements.size() == input.size());<br/>
<br/>
&nbsp;&nbsp;//Store the calculation<br/>
&nbsp;&nbsp;m_last_calculation-&gt;Clear();<br/>
&nbsp;&nbsp;assert(!m_last_calculation-&gt;IsComplete());<br/>
&nbsp;&nbsp;m_last_calculation-&gt;SetPreviousStateEstimate(this-&gt;GetStateEstimate());<br/>
<br/>
&nbsp;&nbsp;//m_last_calculation-&gt;SetMeasurement must be set before calling PredictState!<br/>
&nbsp;&nbsp;m_last_calculation-&gt;SetMeasurement(measurements);<br/>
<br/>
&nbsp;&nbsp;// 1/1) State prediction<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; state_prediction = PredictState(input);<br/>
&nbsp;&nbsp;m_state_estimate = state_prediction;<br/>
<br/>
&nbsp;&nbsp;//Store the calculation<br/>
&nbsp;&nbsp;m_last_calculation-&gt;SetPredictedState(state_prediction);<br/>
&nbsp;&nbsp;m_last_calculation-&gt;SetUpdatedState(GetStateEstimate());<br/>
&nbsp;&nbsp;assert(m_last_calculation-&gt;IsComplete());<br/>
}<br/>
<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/steadystatekalmanfilter.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/steadystatekalmanfilter.h" border = "1"><tr><td><code>
#ifndef STEADYSTATEKALMANFILTER_H<br/>
#define STEADYSTATEKALMANFILTER_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
<br/>
#include "kalmanfilter.h"<br/>
#include "steadystatekalmanfilterparameters.h"<br/>
#include "steadystatekalmanfiltercalculationelements.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///A discrete time Kalman filter<br/>
struct SteadyStateKalmanFilter : public KalmanFilter<br/>
{<br/>
&nbsp;&nbsp;SteadyStateKalmanFilter(const SteadyStateKalmanFilter&amp;) = delete;<br/>
&nbsp;&nbsp;SteadyStateKalmanFilter&amp; operator=(const SteadyStateKalmanFilter&amp;) = delete;<br/>
<br/>
&nbsp;&nbsp;///Clear the calculation, will set IsComplete to false<br/>
&nbsp;&nbsp;//void Clear();<br/>
<br/>
&nbsp;&nbsp;///Get the Kalman filter last calculation elements<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; GetLastCalculation() const noexcept<br/>
&nbsp;&nbsp;{ return m_last_calculation; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt; GetParameters() const noexcept<br/>
&nbsp;&nbsp;{ return m_parameters; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the number of values a state consists of<br/>
&nbsp;&nbsp;int GetStateSize() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the current prediction of the state ('x')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetStateEstimate() const noexcept<br/>
&nbsp;&nbsp; { return m_state_estimate; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const noexcept { return KalmanFilterType::steady_state; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Give the filter a measurement and input, and it will update its predictions<br/>
&nbsp;&nbsp;void SupplyMeasurementAndInput(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurements,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input);<br/>
<br/>
&nbsp;&nbsp;///Let the filter estimate the next state<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; PredictState(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; input) const;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Initialize the filter with a first measurent<br/>
&nbsp;&nbsp;explicit SteadyStateKalmanFilter(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt;&amp; calculation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters);<br/>
&nbsp;&nbsp;friend class SteadyStateKalmanFilterFactory;<br/>
<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~SteadyStateKalmanFilter() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(SteadyStateKalmanFilter*);<br/>
<br/>
&nbsp;&nbsp;///The last calculation<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;SteadyStateKalmanFilterCalculationElements&gt; m_last_calculation;<br/>
<br/>
&nbsp;&nbsp;///The downcasted parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const SteadyStateKalmanFilterParameters&gt; m_parameters;<br/>
<br/>
&nbsp;&nbsp;///x: The (current prediction of the) state<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_state_estimate;<br/>
<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STEADYSTATEKALMANFILTER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/steadystatekalmanfiltercalculationelements.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/steadystatekalmanfiltercalculationelements.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "steadystatekalmanfiltercalculationelements.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include "kalmanfiltercalculationelementsfactory.h"<br/>
<br/>
ribi::kalman::SteadyStateKalmanFilterCalculationElements::SteadyStateKalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state)<br/>
<br/>
&nbsp;&nbsp;: KalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;measurement,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predicted_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previous_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updated_state)<br/>
{<br/>
&nbsp;&nbsp;//... nothing to check<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::KalmanFilterCalculationElements&gt; ribi::kalman::SteadyStateKalmanFilterCalculationElements::Clone() const<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new SteadyStateKalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Base<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetMeasurement(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetPredictedState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetPreviousState(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetUpdatedState()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Derived class<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//... no additional data members<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;assert(p-&gt;GetType() == this-&gt;GetType());<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
bool ribi::kalman::SteadyStateKalmanFilterCalculationElements::IsComplete() const<br/>
{<br/>
&nbsp;&nbsp;const std::size_t sz = GetMeasurement().size();<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sz != 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetMeasurement().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetPreviousState().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; sz == GetUpdatedState().size();<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/steadystatekalmanfiltercalculationelements.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/steadystatekalmanfiltercalculationelements.h" border = "1"><tr><td><code>
#ifndef STEADYSTATEKALMANFILTERCALCULATIONELEMENTS_H<br/>
#define STEADYSTATEKALMANFILTERCALCULATIONELEMENTS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "kalmanfiltercalculationelements.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///The elements of a steady-state Kalman filter calculation<br/>
struct SteadyStateKalmanFilterCalculationElements : public KalmanFilterCalculationElements<br/>
{<br/>
&nbsp;&nbsp;explicit SteadyStateKalmanFilterCalculationElements(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; measurement = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; predicted_state = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; previous_state_estimate = boost::numeric::ublas::vector&lt;double&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; updated_state = boost::numeric::ublas::vector&lt;double&gt;());<br/>
<br/>
&nbsp;&nbsp;///Produce a deep copy of the derived class<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; Clone() const;<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const { return KalmanFilterType::steady_state; }<br/>
<br/>
&nbsp;&nbsp;///Checks if the state is complete and valid<br/>
&nbsp;&nbsp;bool IsComplete() const;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~SteadyStateKalmanFilterCalculationElements() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(SteadyStateKalmanFilterCalculationElements*);<br/>
<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STEADYSTATEKALMANFILTERCALCULATIONELEMENTS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/steadystatekalmanfilterfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/steadystatekalmanfilterfactory.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "steadystatekalmanfilterfactory.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include "kalmanfiltercalculationelementsfactory.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::SteadyStateKalmanFilter&gt; ribi::kalman::SteadyStateKalmanFilterFactory::Create(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;assert(parameters);<br/>
&nbsp;&nbsp;assert(parameters-&gt;GetType() == KalmanFilterType::steady_state);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;KalmanFilterCalculationElements&gt; calculation {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;KalmanFilterCalculationElementsFactory::Create(parameters-&gt;GetType())<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;assert(calculation);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;SteadyStateKalmanFilter&gt; kalman_filter {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new SteadyStateKalmanFilter(calculation,parameters)<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;assert(kalman_filter);<br/>
&nbsp;&nbsp;assert(kalman_filter-&gt;GetType() == KalmanFilterType::steady_state);<br/>
&nbsp;&nbsp;return kalman_filter;<br/>
}<br/>
<br/>
<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/steadystatekalmanfilterfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/steadystatekalmanfilterfactory.h" border = "1"><tr><td><code>
#ifndef STEADYSTATEKALMANFILTERFACTORY_H<br/>
#define STEADYSTATEKALMANFILTERFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "steadystatekalmanfilter.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Factory for SteadyStateKalmanFilter<br/>
struct SteadyStateKalmanFilterFactory<br/>
{<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;SteadyStateKalmanFilter&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const KalmanFilterParameters&gt;&amp; parameters);<br/>
<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STEADYSTATEKALMANFILTERFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/steadystatekalmanfilterparameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/steadystatekalmanfilterparameters.cpp" border = "1"><tr><td><code>
<br/>
<br/>
#include "steadystatekalmanfilterparameters.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
<br/>
#include "matrix.h"<br/>
<br/>
ribi::kalman::SteadyStateKalmanFilterParameters::SteadyStateKalmanFilterParameters(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; estimated_optimal_kalman_gain,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state_estimate,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; observation,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
&nbsp;&nbsp;: KalmanFilterParameters(control,initial_state_estimate,observation,state_transition),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_estimated_optimal_kalman_gain{estimated_optimal_kalman_gain}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;//Check for correct dimensionality<br/>
&nbsp;&nbsp;const std::size_t sz = GetInitialStateEstimate().size();<br/>
&nbsp;&nbsp;//assert(sz &gt;= 0); //Inevitable for std::size_t<br/>
&nbsp;&nbsp;assert(GetEstimatedOptimalKalmanGain().size1() == sz);<br/>
&nbsp;&nbsp;assert(GetEstimatedOptimalKalmanGain().size2() == sz);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
const boost::numeric::ublas::matrix&lt;double&gt; ribi::kalman::SteadyStateKalmanFilterParameters::CalculateOptimalKalmanGain(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; initial_covariance,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; measurement_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; observation,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
{<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; a = state_transition;<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; c = observation;<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; p = initial_covariance;<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; r = measurement_noise;<br/>
<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; term_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::MultiProd(a,p,boost::numeric::ublas::trans(c));<br/>
&nbsp;&nbsp;if (Matrix::CalcDeterminant(term_a + r) == 0.0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error("Optimal Kalman gain matrix is degenerate");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; k<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= Matrix::Prod(term_a,Matrix::Inverse(term_a + r));<br/>
<br/>
&nbsp;&nbsp;return k;<br/>
<br/>
}<br/>
<br/>
const std::string ribi::kalman::SteadyStateKalmanFilterParameters::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.1";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::SteadyStateKalmanFilterParameters::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-01: version 1.0: initial version"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-03: version 1.1: inherit from KalmanFilterParameters"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
bool ribi::kalman::SteadyStateKalmanFilterParameters::HasParameterType(const KalmanFilterParameterType type)<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type == KalmanFilterParameterType::control<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::estimated_optimal_kalman_gain<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::initial_state_estimate<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::observation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|| type == KalmanFilterParameterType::state_transition;<br/>
}<br/>
<br/>
bool ribi::kalman::SteadyStateKalmanFilterParameters::IsAboutEqual(<br/>
&nbsp;&nbsp;const SteadyStateKalmanFilterParameters&amp; lhs,<br/>
&nbsp;&nbsp;const SteadyStateKalmanFilterParameters&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix::MatricesAreAboutEqual(lhs.GetControl(),rhs.GetControl())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetEstimatedOptimalKalmanGain(),rhs.GetEstimatedOptimalKalmanGain())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::VectorsAreAboutEqual(lhs.GetInitialStateEstimate(),rhs.GetInitialStateEstimate())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetObservation(),rhs.GetObservation())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetStateTransition(),rhs.GetStateTransition());<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/steadystatekalmanfilterparameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/steadystatekalmanfilterparameters.h" border = "1"><tr><td><code>
#ifndef STEADYSTATEKALMANFILTERPARAMETERS_H<br/>
#define STEADYSTATEKALMANFILTERPARAMETERS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/checked_delete.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "kalmanfilterparameters.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///Parameters for the standard Kalman filter<br/>
struct SteadyStateKalmanFilterParameters : public KalmanFilterParameters<br/>
{<br/>
&nbsp;&nbsp;explicit SteadyStateKalmanFilterParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; estimated_optimal_kalman_gain,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state_estimate,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;///Calculate the optimal Kalman gain<br/>
&nbsp;&nbsp;static const boost::numeric::ublas::matrix&lt;double&gt; CalculateOptimalKalmanGain(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; initial_covariance,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; observation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition);<br/>
<br/>
&nbsp;&nbsp;///Obtain the (estimated) optimal Kalman gain ('K')<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetEstimatedOptimalKalmanGain() const<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_estimated_optimal_kalman_gain; }<br/>
<br/>
<br/>
&nbsp;&nbsp;///Obtain the Kalman filter type as an enum<br/>
&nbsp;&nbsp;KalmanFilterType GetType() const { return KalmanFilterType::steady_state; }<br/>
<br/>
&nbsp;&nbsp;///Check if two parameter sets are equal with a fuzzy compare<br/>
&nbsp;&nbsp;static bool IsAboutEqual(const SteadyStateKalmanFilterParameters&amp; lhs, const SteadyStateKalmanFilterParameters&amp; rhs);<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Check if this parameter set has a certain type of KalmanFilterParameter<br/>
&nbsp;&nbsp;static bool HasParameterType(const KalmanFilterParameterType type);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Can only be deleted by boost::checked_delete<br/>
&nbsp;&nbsp;~SteadyStateKalmanFilterParameters() noexcept {}<br/>
&nbsp;&nbsp;friend void boost::checked_delete&lt;&gt;(SteadyStateKalmanFilterParameters*);<br/>
<br/>
&nbsp;&nbsp;///K: Estimated optimal Kalman gain<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_estimated_optimal_kalman_gain;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // STEADYSTATEKALMANFILTERPARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystem.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include "whitenoisesystem.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;boost/random.hpp&gt;<br/>
<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::kalman::WhiteNoiseSystem::WhiteNoiseSystem(const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; parameters)<br/>
&nbsp;&nbsp;: m_current_state{parameters-&gt;GetInitialState()},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_parameters{parameters}<br/>
{<br/>
&nbsp;&nbsp;assert(m_parameters);<br/>
}<br/>
<br/>
double ribi::kalman::WhiteNoiseSystem::GetRandomNormal(const double mean, const double sigma) noexcept<br/>
{<br/>
&nbsp;&nbsp;boost::normal_distribution&lt;double&gt; norm_dist(mean, sigma);<br/>
&nbsp;&nbsp;static boost::lagged_fibonacci19937 engine;<br/>
&nbsp;&nbsp;const double value = norm_dist.operator () &lt;boost::lagged_fibonacci19937&gt;((engine));<br/>
&nbsp;&nbsp;return value;<br/>
}<br/>
<br/>
const std::string ribi::kalman::WhiteNoiseSystem::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.0";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::WhiteNoiseSystem::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-05-03: version 1.0: initial version"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
void ribi::kalman::WhiteNoiseSystem::SetNewCurrentState(const boost::numeric::ublas::vector&lt;double&gt;&amp; new_current_state)<br/>
{<br/>
&nbsp;&nbsp;assert(m_current_state.size() == new_current_state.size());<br/>
&nbsp;&nbsp;m_current_state = new_current_state;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystem.h" border = "1"><tr><td><code>
#ifndef WHITENOISESYSTEM_H<br/>
#define WHITENOISESYSTEM_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
<br/>
#include "whitenoisesystemtype.h"<br/>
#include "whitenoisesystemparameters.h"<br/>
<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct WhiteNoiseSystem<br/>
{<br/>
&nbsp;&nbsp;WhiteNoiseSystem(const WhiteNoiseSystem&amp;) = delete;<br/>
&nbsp;&nbsp;WhiteNoiseSystem&amp; operator=(const WhiteNoiseSystem&amp;) = delete;<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;virtual ~WhiteNoiseSystem() noexcept {}<br/>
<br/>
&nbsp;&nbsp;///The parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; GetParameters() const noexcept { return m_parameters; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the type as an enum<br/>
&nbsp;&nbsp;virtual WhiteNoiseSystemType GetType() const noexcept = 0;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state<br/>
&nbsp;&nbsp;virtual void GoToNextState(const boost::numeric::ublas::vector&lt;double&gt;&amp; input) = 0;<br/>
<br/>
&nbsp;&nbsp;///Measure a value from this system with normally distributed noise<br/>
&nbsp;&nbsp;virtual const boost::numeric::ublas::vector&lt;double&gt; Measure() const = 0;<br/>
<br/>
&nbsp;&nbsp;///Peek what the real value is<br/>
&nbsp;&nbsp;virtual const boost::numeric::ublas::vector&lt;double&gt;&amp; PeekAtRealState() const noexcept { return m_current_state; }<br/>
<br/>
&nbsp;&nbsp;protected:<br/>
&nbsp;&nbsp;///An ABC can only be constructed by derived classes<br/>
&nbsp;&nbsp;explicit WhiteNoiseSystem(const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt;&amp; parameters);<br/>
<br/>
&nbsp;&nbsp;///Obtain a random number from a normal distribution<br/>
&nbsp;&nbsp;///From http://www.richelbilderbeek.nl/CppGetRandomNormal.htm<br/>
&nbsp;&nbsp;static double GetRandomNormal(const double mean = 0.0, const double sigma = 1.0) noexcept;<br/>
<br/>
&nbsp;&nbsp;///The real state of the system<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetCurrentState() const noexcept { return m_current_state; }<br/>
<br/>
&nbsp;&nbsp;///Set the new current state<br/>
&nbsp;&nbsp;void SetNewCurrentState(const boost::numeric::ublas::vector&lt;double&gt;&amp; new_current_state);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///The real state of the system<br/>
&nbsp;&nbsp;boost::numeric::ublas::vector&lt;double&gt; m_current_state;<br/>
<br/>
&nbsp;&nbsp;///The parameters<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const WhiteNoiseSystemParameters&gt; m_parameters;<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // WHITENOISESYSTEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemfactory.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemfactory.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "whitenoisesystemfactory.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include "gapsfilledwhitenoisesystemfactory.h"<br/>
#include "laggedwhitenoisesystemfactory.h"<br/>
#include "standardwhitenoisesystemfactory.h"<br/>
<br/>
const boost::shared_ptr&lt;ribi::kalman::WhiteNoiseSystem&gt; ribi::kalman::WhiteNoiseSystemFactory::Create(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystemParameters&gt;&amp; parameters)<br/>
{<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;WhiteNoiseSystem&gt; p;<br/>
&nbsp;&nbsp;switch (parameters-&gt;GetType())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemType::gaps_filled:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = GapsFilledWhiteNoiseSystemFactory::Create(parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemType::lagged:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = LaggedWhiteNoiseSystemFactory::Create(parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemType::standard:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = StandardWhiteNoiseSystemFactory::Create(parameters);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemType::n_types:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented white noise system");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemfactory.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemfactory.h" border = "1"><tr><td><code>
#ifndef WHITENOISESYSTEMFACTORY_H<br/>
#define WHITENOISESYSTEMFACTORY_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#include "whitenoisesystem.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "whitenoisesystemparameters.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct WhiteNoiseSystemFactory<br/>
{<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;WhiteNoiseSystem&gt; Create(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;WhiteNoiseSystemParameters&gt;&amp; parameters);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // WHITENOISESYSTEMFACTORY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemparameter.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemparameter.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "whitenoisesystemparameter.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;stdexcept&gt;<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
const std::vector&lt;ribi::kalman::WhiteNoiseSystemParameterType&gt; ribi::kalman::WhiteNoiseSystemParameter::GetAll()<br/>
{<br/>
&nbsp;&nbsp;const std::vector&lt;WhiteNoiseSystemParameterType&gt; v {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::initial_state_real,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::measurement_frequency,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemParameterType::state_transition,<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;assert(boost::numeric_cast&lt;int&gt;(v.size()) == static_cast&lt;int&gt;(WhiteNoiseSystemParameterType::n_parameters)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "All parameters must be in");<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
bool ribi::kalman::WhiteNoiseSystemParameter::IsMatrix(const WhiteNoiseSystemParameterType type)<br/>
{<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::control: return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::initial_state_real: return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::measurement_frequency: return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::real_measurement_noise: return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::real_process_noise: return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::state_transition: return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"n_parameters is not an implemented type of WhiteNoiseSystemParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");<br/>
&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
}<br/>
<br/>
bool ribi::kalman::WhiteNoiseSystemParameter::IsVector(const WhiteNoiseSystemParameterType type)<br/>
{<br/>
&nbsp;&nbsp;return !ribi::kalman::WhiteNoiseSystemParameter::IsMatrix(type);<br/>
}<br/>
<br/>
const std::string ribi::kalman::WhiteNoiseSystemParameter::ToDescription(const WhiteNoiseSystemParameterType type)<br/>
{<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::control:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix for converting input to state change");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::initial_state_real:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Vector with the real initial state");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::measurement_frequency:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Vector containing after which number of timesteps a measurement is taken");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::real_measurement_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Vector with the real standard deviations of the measurement noise per state");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::real_process_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Vector with the real standard deviations of the process noise per state");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::state_transition:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Matrix that contains the internal physics of the system; the effect of current state on the next state");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");<br/>
&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
}<br/>
<br/>
const std::string ribi::kalman::WhiteNoiseSystemParameter::ToName(const WhiteNoiseSystemParameterType type)<br/>
{<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::control:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Control");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::initial_state_real:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Real initial state");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::measurement_frequency:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Measurement frequencies");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::real_measurement_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Real measurement noise");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::real_process_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Real process noise");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::state_transition:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("State transition");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");<br/>
&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
}<br/>
<br/>
const std::string ribi::kalman::WhiteNoiseSystemParameter::ToSymbol(const WhiteNoiseSystemParameterType type)<br/>
{<br/>
&nbsp;&nbsp;switch (type)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::control:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("B");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::initial_state_real:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("x");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::measurement_frequency:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("f");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::real_measurement_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("R"); //Shouldn't be 'r', as it is a vector?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::real_process_noise:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Q"); //Shouldn't be 'q', as it is a vector?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::state_transition:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("A");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case WhiteNoiseSystemParameterType::n_parameters:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");<br/>
&nbsp;&nbsp;throw std::logic_error(__func__);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemparameter.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemparameter.h" border = "1"><tr><td><code>
#ifndef WHITENOISESYSTEMPARAMETER_H<br/>
#define WHITENOISESYSTEMPARAMETER_H<br/>
<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "whitenoisesystemparametertype.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///A single WhiteNoiseSystemParameter<br/>
///for example, the state transition matrix<br/>
/// - is a matrix<br/>
/// - is not a vector<br/>
/// - has a description like 'Matrix that [...]'<br/>
/// - has the name 'State transition matrix'<br/>
/// - has the symbol 'A'<br/>
struct WhiteNoiseSystemParameter<br/>
{<br/>
&nbsp;&nbsp;///Obtain all WhiteNoiseSystemParameterType values, except n_parameters<br/>
&nbsp;&nbsp;static const std::vector&lt;WhiteNoiseSystemParameterType&gt; GetAll();<br/>
<br/>
&nbsp;&nbsp;///Is the type a matrix?<br/>
&nbsp;&nbsp;static bool IsMatrix(const WhiteNoiseSystemParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Is the type a vector?<br/>
&nbsp;&nbsp;static bool IsVector(const WhiteNoiseSystemParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the full name of a type, e.g. 'Matrix to capture the physics of the system'<br/>
&nbsp;&nbsp;static const std::string ToDescription(const WhiteNoiseSystemParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the full name of a type, e.g. 'State transition'<br/>
&nbsp;&nbsp;static const std::string ToName(const WhiteNoiseSystemParameterType type);<br/>
<br/>
&nbsp;&nbsp;///Obtain the symbol of a type, e.g. 'A'<br/>
&nbsp;&nbsp;static const std::string ToSymbol(const WhiteNoiseSystemParameterType type);<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // WHITENOISESYSTEMPARAMETER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemparameters.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemparameters.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "whitenoisesystemparameters.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include "matrix.h"<br/>
<br/>
ribi::kalman::WhiteNoiseSystemParameters::WhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition)<br/>
&nbsp;&nbsp;: m_control{control},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_initial_state{initial_state},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_real_measurement_noise{real_measurement_noise},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_real_process_noise{real_process_noise},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_state_transition{state_transition}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;//Check for correct dimensionality<br/>
&nbsp;&nbsp;const size_t sz = initial_state.size();<br/>
&nbsp;&nbsp;//assert(sz &gt;= 0); //Inevitable for std::size_t<br/>
&nbsp;&nbsp;assert(m_control.size1() == sz);<br/>
&nbsp;&nbsp;assert(m_control.size2() == sz);<br/>
&nbsp;&nbsp;assert(m_initial_state.size() == sz);<br/>
&nbsp;&nbsp;assert(m_real_measurement_noise.size() == sz);<br/>
&nbsp;&nbsp;assert(m_real_process_noise.size() == sz);<br/>
&nbsp;&nbsp;assert(m_state_transition.size1() == sz);<br/>
&nbsp;&nbsp;assert(m_state_transition.size2() == sz);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
const std::string ribi::kalman::WhiteNoiseSystemParameters::GetVersion() noexcept<br/>
{<br/>
&nbsp;&nbsp;return "1.0";<br/>
}<br/>
<br/>
const std::vector&lt;std::string&gt; ribi::kalman::WhiteNoiseSystemParameters::GetVersionHistory() noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;"2013-04-28: version 1.0: initial version"<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
bool ribi::kalman::WhiteNoiseSystemParameters::IsAboutEqual(<br/>
&nbsp;&nbsp;const WhiteNoiseSystemParameters&amp; lhs, const WhiteNoiseSystemParameters&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matrix::MatricesAreAboutEqual(lhs.GetControl(),rhs.GetControl())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::VectorsAreAboutEqual(lhs.GetInitialState(),rhs.GetInitialState())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::VectorsAreAboutEqual(lhs.GetMeasurementNoise(),rhs.GetMeasurementNoise())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::VectorsAreAboutEqual(lhs.GetProcessNoise(),rhs.GetProcessNoise())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; Matrix::MatricesAreAboutEqual(lhs.GetStateTransition(),rhs.GetStateTransition());<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemparameters.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemparameters.h" border = "1"><tr><td><code>
#ifndef WHITENOISESYSTEMPARAMETERS_H<br/>
#define WHITENOISESYSTEMPARAMETERS_H<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br/>
#include &lt;boost/numeric/ublas/vector.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "whitenoisesystemtype.h"<br/>
<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
///ABC of the parameters of a white noise system<br/>
struct WhiteNoiseSystemParameters<br/>
{<br/>
&nbsp;&nbsp;WhiteNoiseSystemParameters(const WhiteNoiseSystemParameters&amp;) = delete;<br/>
&nbsp;&nbsp;WhiteNoiseSystemParameters&amp; operator=(const WhiteNoiseSystemParameters&amp;) = delete;<br/>
<br/>
&nbsp;&nbsp;virtual ~WhiteNoiseSystemParameters() noexcept {}<br/>
<br/>
&nbsp;&nbsp;///The control matrix to determine the influence of the input (in GoToNextState)<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetControl() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_control; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the real initial state<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetInitialState() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_initial_state; }<br/>
<br/>
&nbsp;&nbsp;///The real standard deviation of the noise in the state transition<br/>
&nbsp;&nbsp;///(used in WhiteNoiseSystem::GoToNextState)<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetProcessNoise() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_real_process_noise; }<br/>
<br/>
&nbsp;&nbsp;///The real amount of noise in the system<br/>
&nbsp;&nbsp;///A noise of zero indicates a system that can be measured accurately to infinite precision<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; GetMeasurementNoise() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_real_measurement_noise; }<br/>
<br/>
&nbsp;&nbsp;///The state transitions in the system<br/>
&nbsp;&nbsp;///(used in WhiteNoiseSystem::GoToNextState)<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; GetStateTransition() const noexcept<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ return m_state_transition; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the type as an enum<br/>
&nbsp;&nbsp;virtual WhiteNoiseSystemType GetType() const noexcept = 0;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version of this class<br/>
&nbsp;&nbsp;static const std::string GetVersion() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the version history of this class<br/>
&nbsp;&nbsp;static const std::vector&lt;std::string&gt; GetVersionHistory() noexcept;<br/>
<br/>
&nbsp;&nbsp;///Check two parameter sets for equality using a fuzzy comparison<br/>
&nbsp;&nbsp;static bool IsAboutEqual(const WhiteNoiseSystemParameters&amp; lhs, const WhiteNoiseSystemParameters&amp; rhs) noexcept;<br/>
<br/>
&nbsp;&nbsp;protected:<br/>
&nbsp;&nbsp;///An ABC can only be constructed by derived classes<br/>
&nbsp;&nbsp;explicit WhiteNoiseSystemParameters(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; control,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; initial_state,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_measurement_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt;&amp; real_process_noise,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt;&amp; state_transition);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///The control matrix to determine the influence of the input (in GoToNextState)<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_control;<br/>
<br/>
&nbsp;&nbsp;///The real initial state<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; m_initial_state;<br/>
<br/>
&nbsp;&nbsp;///The real amount of noise in the system<br/>
&nbsp;&nbsp;///A noise of zero indicates a system that can be measured accurately to infinite precision<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; m_real_measurement_noise;<br/>
<br/>
&nbsp;&nbsp;///The standard deviation of the noise in the state transition (in GoToNextState)<br/>
&nbsp;&nbsp;const boost::numeric::ublas::vector&lt;double&gt; m_real_process_noise;<br/>
<br/>
&nbsp;&nbsp;///The state transitions in the system, used in GoToNextState<br/>
&nbsp;&nbsp;const boost::numeric::ublas::matrix&lt;double&gt; m_state_transition;<br/>
<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // WHITENOISESYSTEMPARAMETERS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemparametertype.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemparametertype.cpp" border = "1"><tr><td><code>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#include "whitenoisesystemparametertype.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;boost/numeric/conversion/cast.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
bool ribi::kalman::operator&lt;(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) &lt; static_cast&lt;int&gt;(rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator==(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) == static_cast&lt;int&gt;(rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator!=(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemparametertype.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemparametertype.h" border = "1"><tr><td><code>
#ifndef WHITENOISESYSTEMPARAMETERTYPE_H<br/>
#define WHITENOISESYSTEMPARAMETERTYPE_H<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
enum class WhiteNoiseSystemParameterType<br/>
{<br/>
&nbsp;&nbsp;control,<br/>
&nbsp;&nbsp;initial_state_real,<br/>
&nbsp;&nbsp;measurement_frequency,<br/>
&nbsp;&nbsp;real_measurement_noise,<br/>
&nbsp;&nbsp;real_process_noise,<br/>
&nbsp;&nbsp;state_transition,<br/>
&nbsp;&nbsp;n_parameters<br/>
};<br/>
<br/>
bool operator&lt;(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs);<br/>
bool operator==(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs);<br/>
bool operator!=(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs);<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // WHITENOISESYSTEMPARAMETERTYPE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemtype.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemtype.cpp" border = "1"><tr><td><code>
<br/>
<br/>
#include "whitenoisesystemtype.h"<br/>
<br/>
bool ribi::kalman::operator==(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) == static_cast&lt;int&gt;(rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator!=(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) != static_cast&lt;int&gt;(rhs);<br/>
}<br/>
<br/>
bool ribi::kalman::operator&lt;(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs)<br/>
{<br/>
&nbsp;&nbsp;//Must cast enum class to integer, because of a bug<br/>
&nbsp;&nbsp;//in GCC version 4.4.0:<br/>
&nbsp;&nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(lhs) &lt; static_cast&lt;int&gt;(rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemtype.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemtype.h" border = "1"><tr><td><code>
#ifndef WHITENOISESYSTEMTYPE_H<br/>
#define WHITENOISESYSTEMTYPE_H<br/>
<br/>
#include &lt;string&gt;<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
enum class WhiteNoiseSystemType<br/>
{<br/>
&nbsp;&nbsp;gaps_filled,<br/>
&nbsp;&nbsp;lagged,<br/>
&nbsp;&nbsp;standard,<br/>
&nbsp;&nbsp;n_types<br/>
};<br/>
<br/>
bool operator==(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs);<br/>
bool operator!=(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs);<br/>
bool operator&lt;(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs);<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // WHITENOISESYSTEMTYPE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemtypes.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemtypes.cpp" border = "1"><tr><td><code>
<br/>
<br/>
#include "whitenoisesystemtypes.h"<br/>
<br/>
boost::bimap&lt;ribi::kalman::WhiteNoiseSystemType,std::string&gt; ribi::kalman::WhiteNoiseSystemTypes::m_map;<br/>
<br/>
const boost::bimap&lt;ribi::kalman::WhiteNoiseSystemType,std::string&gt; ribi::kalman::WhiteNoiseSystemTypes::CreateMap()<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;boost::bimap&lt;WhiteNoiseSystemType,std::string&gt; m;<br/>
&nbsp;&nbsp;m.insert(boost::bimap&lt;WhiteNoiseSystemType,std::string&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemType::gaps_filled,std::string("gaps_filled")));<br/>
&nbsp;&nbsp;m.insert(boost::bimap&lt;WhiteNoiseSystemType,std::string&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemType::lagged,std::string("lagged")));<br/>
&nbsp;&nbsp;m.insert(boost::bimap&lt;WhiteNoiseSystemType,std::string&gt;::value_type(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemType::standard,std::string("standard")));<br/>
&nbsp;&nbsp;return m;<br/>
}<br/>
<br/>
const std::vector&lt;ribi::kalman::WhiteNoiseSystemType&gt; ribi::kalman::WhiteNoiseSystemTypes::GetAllTypes()<br/>
{<br/>
&nbsp;&nbsp;const std::vector&lt;WhiteNoiseSystemType&gt; v {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemType::gaps_filled,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemType::lagged,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;WhiteNoiseSystemType::standard<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(static_cast&lt;int&gt;(v.size()) == static_cast&lt;int&gt;(WhiteNoiseSystemType::n_types));<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::kalman::WhiteNoiseSystemTypes::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const std::vector&lt;WhiteNoiseSystemType&gt; v = GetAllTypes();<br/>
&nbsp;&nbsp;const std::size_t sz = v.size();<br/>
&nbsp;&nbsp;for (std::size_t i=0; i!=sz; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const WhiteNoiseSystemType t = v[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string s = ToStr(t);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!s.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const WhiteNoiseSystemType u = ToType(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(u == t);<br/>
&nbsp;&nbsp;}<br/>
}<br/>
#endif<br/>
<br/>
const std::string ribi::kalman::WhiteNoiseSystemTypes::ToStr(const WhiteNoiseSystemType type)<br/>
{<br/>
&nbsp;&nbsp;if (m_map.left.empty()) m_map = CreateMap();<br/>
&nbsp;&nbsp;assert(!m_map.left.empty());<br/>
&nbsp;&nbsp;assert(m_map.left.count(type) == 1);<br/>
&nbsp;&nbsp;const std::string s = m_map.left.find(type)-&gt;second;<br/>
&nbsp;&nbsp;return s;<br/>
}<br/>
<br/>
ribi::kalman::WhiteNoiseSystemType ribi::kalman::WhiteNoiseSystemTypes::ToType(const std::string&amp; s)<br/>
{<br/>
&nbsp;&nbsp;if (m_map.right.empty()) m_map = CreateMap();<br/>
&nbsp;&nbsp;assert(!m_map.right.empty());<br/>
&nbsp;&nbsp;assert(m_map.right.count(s) == 1);<br/>
&nbsp;&nbsp;const WhiteNoiseSystemType t = m_map.right.find(s)-&gt;second;<br/>
&nbsp;&nbsp;return t;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppKalmanFilter/whitenoisesystemtypes.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppKalmanFilter/whitenoisesystemtypes.h" border = "1"><tr><td><code>
#ifndef WHITENOISESYSTEMTYPES_H<br/>
#define WHITENOISESYSTEMTYPES_H<br/>
<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/bimap.hpp&gt;<br/>
#pragma GCC diagnostic pop<br/>
<br/>
#include "whitenoisesystemtype.h"<br/>
<br/>
namespace ribi {<br/>
namespace kalman {<br/>
<br/>
struct WhiteNoiseSystemTypes<br/>
{<br/>
&nbsp;&nbsp;static const std::vector&lt;WhiteNoiseSystemType&gt; GetAllTypes();<br/>
&nbsp;&nbsp;static const std::string ToStr(const WhiteNoiseSystemType type);<br/>
&nbsp;&nbsp;static WhiteNoiseSystemType ToType(const std::string&amp; s);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;static boost::bimap&lt;WhiteNoiseSystemType,std::string&gt; m_map;<br/>
&nbsp;&nbsp;static const boost::bimap&lt;WhiteNoiseSystemType,std::string&gt; CreateMap();<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
};<br/>
<br/>
} //~namespace kalman<br/>
} //~namespace ribi<br/>
<br/>
#endif // WHITENOISESYSTEMTYPES_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
