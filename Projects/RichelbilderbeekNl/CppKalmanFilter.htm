&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"&gt;
&lt;head&gt;
&nbsp;&nbsp;&lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"/&gt;
&nbsp;&nbsp;&lt;title&gt;KalmanFilter&lt;/title&gt;
&nbsp;&nbsp;&lt;meta name="description" content="C++ KalmanFilter"/&gt;
&nbsp;&nbsp;&lt;meta name="keywords" content="C++ KalmanFilter "/&gt;
&nbsp;&nbsp;&lt;link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/&gt;
&lt;/head&gt;
&lt;!-- End of head, start of body --&gt;
&lt;body&gt;
&lt;p&gt;&lt;a href="index.htm"&gt;Go back to Richel Bilderbeek's homepage&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="Cpp.htm"&gt;Go back to Richel Bilderbeek's C++ page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- Page header --&gt;
&lt;h1&gt;(&lt;a href="Cpp.htm"&gt;C++&lt;/a&gt;) &lt;a href="CppKalmanFilter.htm"&gt;KalmanFilter&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/CppKalmanFilter.pri&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/CppKalmanFilter.pri" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
INCLUDEPATH += \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter&lt;br/&gt;
&lt;br/&gt;
SOURCES += \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilter.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystem.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystemfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystemparameters.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilter.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfiltercalculationelements.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfiltercalculationelementsfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterexample.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperiment.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperimentparameter.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperimentparametertype.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterparameter.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterparameters.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterparametertype.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfiltertype.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfiltertypes.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystem.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystemfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystemparameters.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardkalmanfilter.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardkalmanfiltercalculationelements.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardkalmanfilterfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardkalmanfilterparameters.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystem.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystemfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystemparameters.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilter.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfiltercalculationelements.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilterfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilterparameters.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystem.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemfactory.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparameter.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparameters.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparametertype.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemtype.cpp \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemtypes.cpp&lt;br/&gt;
&lt;br/&gt;
HEADERS&amp;nbsp;&amp;nbsp;+= \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilter.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystem.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystemfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/gapsfilledwhitenoisesystemparameters.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilter.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfiltercalculationelements.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfiltercalculationelementsfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterexample.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperiment.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperimentparameter.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterexperimentparametertype.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterparameter.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterparameters.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfilterparametertype.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfiltertype.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/kalmanfiltertypes.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystem.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystemfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/laggedwhitenoisesystemparameters.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardkalmanfilter.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardkalmanfiltercalculationelements.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardkalmanfilterfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardkalmanfilterparameters.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystem.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystemfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/standardwhitenoisesystemparameters.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilter.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfiltercalculationelements.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilterfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/steadystatekalmanfilterparameters.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystem.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemfactory.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparameter.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparameters.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemparametertype.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemtype.h \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/whitenoisesystemtypes.h&lt;br/&gt;
&lt;br/&gt;
OTHER_FILES += \&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;../../Classes/CppKalmanFilter/Licence.txt&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/fixedlagsmootherkalmanfilter.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilter.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "fixedlagsmootherkalmanfilter.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/io.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector_proxy.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
#include "standardkalmanfilterfactory.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::FixedLagSmootherKalmanFilter::FixedLagSmootherKalmanFilter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;FixedLagSmootherKalmanFilterCalculationElements&amp;gt;&amp;amp; calculation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilter{},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_last_calculation{calculation},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_last_fixed_lag_smoother_calculation{boost::dynamic_pointer_cast&amp;lt;FixedLagSmootherKalmanFilterCalculationElements&amp;gt;(calculation)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_filter{StandardKalmanFilterFactory::Create(DownCast(parameters)-&amp;gt;GetStandardParameters())},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_parameters{DownCast(parameters)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_state_estimates{CreateInitialStates(DownCast(parameters))}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_last_fixed_lag_smoother_calculation);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(m_state_estimates.size()) == m_parameters-&amp;gt;GetLag() * m_standard_filter-&amp;gt;GetStateSize());&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt; ribi::kalman::FixedLagSmootherKalmanFilter::CreateInitialGains(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const StandardKalmanFilter&amp;amp; filter)&lt;br/&gt;
{&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(filter.GetStateSize() == boost::numeric_cast&amp;lt;int&amp;gt;(filter.GetLastStandardCalculation()-&amp;gt;GetKalmanGain().size1()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(filter.GetLastStandardCalculation()-&amp;gt;GetKalmanGain().size1() == filter.GetLastStandardCalculation()-&amp;gt;GetKalmanGain().size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt; v(lag,filter.GetLastStandardCalculation()-&amp;gt;GetKalmanGain());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; ribi::kalman::FixedLagSmootherKalmanFilter::CreateComplexInitialStates(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const FixedLagSmootherKalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; v(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetLag(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetStandardParameters()-&amp;gt;GetInitialStateEstimate());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::FixedLagSmootherKalmanFilter::CreateComplexTermA(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int state_size)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag &amp;gt; 0 &amp;amp;&amp;amp; "Term A is not needed for a lag of zero");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt; v(lag);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v[0] = boost::numeric::ublas::identity_matrix&amp;lt;double&amp;gt;(state_size);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (int i=1; i!=lag; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(i &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;v[i] = boost::numeric::ublas::zero_matrix&amp;lt;double&amp;gt;(state_size);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::FixedLagSmootherKalmanFilter::CreateTermA(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int state_size)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag &amp;gt; 0 &amp;amp;&amp;amp; "Term A is not needed for a lag of zero");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; v&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::SimplifyVectorOfMatrix(CreateComplexTermA(lag,state_size));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag * state_size == boost::numeric_cast&amp;lt;int&amp;gt;(v.size1()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(&amp;nbsp;&amp;nbsp;1 * state_size == boost::numeric_cast&amp;lt;int&amp;gt;(v.size2()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::matrix&amp;lt;double &amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::FixedLagSmootherKalmanFilter::CreateTermB(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int state_size)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; v&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::SimplifyMatrixOfMatrix(CreateComplexTermB(lag,state_size));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag &amp;gt; 0 &amp;amp;&amp;amp; "Term B is not needed for a lag of zero");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag &amp;gt; 1 &amp;amp;&amp;amp; "Term B cannot be calculated for a lag of one");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert((lag - 0) * state_size == boost::numeric_cast&amp;lt;int&amp;gt;(v.size1()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert((lag - 1) * state_size == boost::numeric_cast&amp;lt;int&amp;gt;(v.size2()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::matrix&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::FixedLagSmootherKalmanFilter::CreateComplexTermB(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int state_size)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag &amp;gt; 0 &amp;amp;&amp;amp; "Term B is not needed for a lag of zero");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n_cols = lag - 1;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n_rows = lag;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::matrix&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt; v(n_rows,n_cols);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (int y=0; y!=n_rows; ++y)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int x=0; x!=n_cols; ++x)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (y - 1 == x)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(y &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size1()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(x &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size2()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;v(y,x) = boost::numeric::ublas::identity_matrix&amp;lt;double&amp;gt;(state_size);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(y &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size1()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(x &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size2()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;v(y,x) = boost::numeric::ublas::zero_matrix&amp;lt;double&amp;gt;(state_size);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt; ribi::kalman::FixedLagSmootherKalmanFilter::CreateInitialStates(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const FixedLagSmootherKalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//if (lag == 0) return boost::numeric::ublas::vector&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; v = Matrix::SimplifyVectorOfVector(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CreateComplexInitialStates(parameters));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;const ribi::kalman::FixedLagSmootherKalmanFilterParameters&amp;gt; ribi::kalman::FixedLagSmootherKalmanFilter::DownCast(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto i = parameters.use_count();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const FixedLagSmootherKalmanFilterParameters&amp;gt; p&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::dynamic_pointer_cast&amp;lt;const FixedLagSmootherKalmanFilterParameters&amp;gt;(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = parameters.use_count();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(i + 1 == j);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return p;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::FixedLagSmootherKalmanFilter::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.0";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::FixedLagSmootherKalmanFilter::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-03: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt; ribi::kalman::FixedLagSmootherKalmanFilter::PredictState(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input) const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::range;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::vector;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::vector_range;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (m_parameters-&amp;gt;GetLag() == 0) return m_standard_filter-&amp;gt;PredictState(input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_state_estimates.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t state_size = m_standard_filter-&amp;gt;GetStateSize();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_size &amp;lt;= m_state_estimates.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const vector_range&amp;lt;const vector&amp;lt;double&amp;gt; &amp;gt; state(m_state_estimates,range(0,state_size));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return vector&amp;lt;double&amp;gt;(state);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::FixedLagSmootherKalmanFilter::SupplyMeasurementAndInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; x,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::vector;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::vector_range;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::range;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::matrix;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::trans;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Store calculation for KalmanFilterExperiment&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_fixed_lag_smoother_calculation-&amp;gt;Clear();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_fixed_lag_smoother_calculation-&amp;gt;SetPreviousStateEstimate(this-&amp;gt;GetStandardKalmanFilter()-&amp;gt;GetStateEstimate()); //1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_fixed_lag_smoother_calculation-&amp;gt;SetPreviousCovarianceEstimate(this-&amp;gt;GetEstimationErrorCovariance()); //2&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int state_size = m_standard_filter-&amp;gt;GetStateSize();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_size == boost::numeric_cast&amp;lt;int&amp;gt;(x.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_size == boost::numeric_cast&amp;lt;int&amp;gt;(input.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_standard_filter-&amp;gt;SupplyMeasurementAndInput(x,input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (m_parameters-&amp;gt;GetLag() == 0) return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const matrix&amp;lt;double&amp;gt; term_a = CreateTermA(m_parameters-&amp;gt;GetLag(),state_size);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int lag = m_parameters-&amp;gt;GetLag();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag * state_size == boost::numeric_cast&amp;lt;int&amp;gt;(term_a.size1()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(&amp;nbsp;&amp;nbsp;1 * state_size == boost::numeric_cast&amp;lt;int&amp;gt;(term_a.size2()));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Get the naive (that is, based on no time lag) prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const vector&amp;lt;double&amp;gt; x_naive = m_standard_filter-&amp;gt;PredictState(input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const matrix&amp;lt;double&amp;gt; term_b = CreateTermB(lag,state_size);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Find P(i) (yes, i can be zero and goes to lag)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//ps has length lag&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//P(i) has size state_size x state_size&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//P(i) = P . [ [F-KH]^T ]^i (where ^T denotes a transposition, where ^i denotes an exponent to the power of i&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE(m_standard_filter-&amp;gt;GetLastStandardCalculation()-&amp;gt;GetPreviousCovarianceEstimate());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE(m_standard_filter-&amp;gt;GetLastStandardCalculation()-&amp;gt;GetKalmanGain());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;vector&amp;lt;matrix&amp;lt;double&amp;gt; &amp;gt; ps_complex(lag);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (int i=0; i!=lag; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(i &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(ps_complex.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ps_complex[i]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_filter-&amp;gt;GetEstimationErrorCovariance(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::Power(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;trans(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_filter-&amp;gt;GetParameters()-&amp;gt;GetStateTransition()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- Matrix::Prod(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_filter-&amp;gt;GetLastStandardCalculation()-&amp;gt;GetKalmanGain(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_filter-&amp;gt;GetParameters()-&amp;gt;GetObservation()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Find K(i) (yes, i can be zero and goes to lag)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//ks has length lag&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//K(i) has size state_size x state_size&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//K(i) = P(i) . H^T . [H.P.H^T + R]^-1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;vector&amp;lt;matrix&amp;lt;double&amp;gt; &amp;gt; ks_complex(lag);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (int i=0; i!=lag; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; term&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::MultiProd(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_filter-&amp;gt;GetParameters()-&amp;gt;GetObservation(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_filter-&amp;gt;GetEstimationErrorCovariance(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;trans(m_standard_filter-&amp;gt;GetParameters()-&amp;gt;GetObservation())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ m_standard_filter-&amp;gt;GetStandardParameters()-&amp;gt;GetEstimatedMeasurementNoise();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (Matrix::CalcDeterminant(term) == 0.0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::runtime_error("Determinant of term in K(i) equals zero");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(i &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(ks_complex.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(i &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(ps_complex.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ks_complex[i]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::MultiProd(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ps_complex[i],&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;trans(m_standard_filter-&amp;gt;GetParameters()-&amp;gt;GetObservation()),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::Inverse(term)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;matrix&amp;lt;double&amp;gt; ks = Matrix::SimplifyVectorOfMatrix(ks_complex);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const vector&amp;lt;double&amp;gt; innovation = m_standard_filter-&amp;gt;GetLastStandardCalculation()-&amp;gt;GetInnovation();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const vector&amp;lt;double&amp;gt; new_states_term_a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(term_a,x_naive);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const vector&amp;lt;double&amp;gt; new_states_term_b&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(term_b,vector_range&amp;lt;const vector&amp;lt;double&amp;gt; &amp;gt;(m_state_estimates,range(0,m_state_estimates.size()- m_standard_filter-&amp;gt;GetStateSize())));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//const vector&amp;lt;double&amp;gt; new_states_term_b&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;&amp;nbsp;= Matrix::Prod(term_b,vector_range&amp;lt;const vector&amp;lt;double&amp;gt; &amp;gt;(m_states,range(m_standard_filter-&amp;gt;GetStateSize(),m_states.size())))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const vector&amp;lt;double&amp;gt; new_states_term_c&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(ks,innovation);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_state_estimates&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= new_states_term_a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ new_states_term_b&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ new_states_term_c;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Store the calculation hiero");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_fixed_lag_smoother_calculation-&amp;gt;SetStandardCalculationElement(this-&amp;gt;m_standard_filter-&amp;gt;GetLastStandardCalculation());&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
#ifndef NDEBUG&lt;br/&gt;
void ribi::kalman::FixedLagSmootherKalmanFilter::Test() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static bool is_tested = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (is_tested) return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;is_tested = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Starting ribi::kalman::FixedLagSmootherKalmanFilter::Test()")&lt;br/&gt;
&amp;nbsp;&amp;nbsp;try&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::numeric_cast&amp;lt;std::size_t&amp;gt;(-1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Line above must fail, so shouldn't get here");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;catch (boost::numeric::bad_numeric_cast&amp;amp; e)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//OK!&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//CreateTermA&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag = 13;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int state_size = 17;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; v = CreateTermA(lag,state_size);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int n_rows = lag * state_size;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int n_cols =&amp;nbsp;&amp;nbsp; 1 * state_size;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size1()) == n_rows);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size2()) == n_cols);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int row = 0; row!=n_rows; ++row)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(row &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size1()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int col = 0; col!=n_cols; ++col)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(col &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size2()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const double expected = row == col ? 1.0 : 0.0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(Matrix::IsAboutEqual(v(row,col),expected));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//CreateTermB&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag = 3;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int state_size = 5;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; v = CreateTermB(lag,state_size);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int n_rows = lag * state_size;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int n_cols = (lag - 1) * state_size;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size1()) == n_rows);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size2()) == n_cols);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int row = 0; row!=n_rows; ++row)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(row &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size1()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int col = 0; col!=n_cols; ++col)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(col &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(v.size2()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const double expected = row - state_size == col ? 1.0 : 0.0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(Matrix::IsAboutEqual(v(row,col),expected));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Finished ribi::kalman::FixedLagSmootherKalmanFilter::Test()")&lt;br/&gt;
}&lt;br/&gt;
#endif&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/fixedlagsmootherkalmanfilter.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilter.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef FIXEDLAGSMOOTHERKALMANFILTER_H&lt;br/&gt;
#define FIXEDLAGSMOOTHERKALMANFILTER_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfilter.h"&lt;br/&gt;
#include "standardkalmanfilter.h"&lt;br/&gt;
#include "standardkalmanfilterparameters.h"&lt;br/&gt;
#include "fixedlagsmootherkalmanfilterparameters.h"&lt;br/&gt;
#include "fixedlagsmootherkalmanfiltercalculationelements.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct FixedLagSmootherKalmanFilter : public KalmanFilter&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The augmented estimation error covariances, that is the estimation error covariance for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::matrix&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp; Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A B ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C D ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ A B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ C D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ E F ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ E F ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ G H ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp;[ G H ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetEstimationErrorCovariances() const { return m_estimation_error_covariances; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Get the Kalman filter last calculation elements&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; GetLastCalculation() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return m_last_calculation;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The last augmented Kalman gains, that is the gain for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::matrix&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp; Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A B ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C D ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ A B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ C D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ E F ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ E F ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ G H ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp;[ G H ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetLastGains() const { return m_kalman_gains; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The last predicted augmented estimation error covariances,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///that is the estimation error covariance for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::matrix&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp; Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A B ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C D ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ A B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ C D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ E F ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ E F ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ G H ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp;[ G H ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetLastPredictedCovariances() const { return m_last_predicted_covariances; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The last predicted augmented states&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::vector&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ B ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ A ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ C ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ D ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp; [ D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetLastPredictedStates() const { return m_last_predicted_states; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt; GetParameters() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return m_parameters;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The augmented states, that is the state for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::vector&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ B ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ A ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ C ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ D ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp; [ D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetStateEstimates() const { return m_state_estimates; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const { return KalmanFilterType::fixed_lag_smoother; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Let the filter predict&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; PredictState(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input) const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Give the filter a measurement and input, and it will update its predictions&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SupplyMeasurementAndInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; x,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Only a FixedLagSmootherKalmanFilterFactory can create a FixedLagSmootherKalmanFilter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit FixedLagSmootherKalmanFilter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;FixedLagSmootherKalmanFilterCalculationElements&amp;gt;&amp;amp; calculation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend class FixedLagSmootherKalmanFilterFactory;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~FixedLagSmootherKalmanFilter() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(FixedLagSmootherKalmanFilter*);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(const FixedLagSmootherKalmanFilter*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The Kalman filter last calculation elements&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; m_last_calculation;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The (downcasted) calculation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;FixedLagSmootherKalmanFilterCalculationElements&amp;gt; m_last_fixed_lag_smoother_calculation;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The standard (unlagged) Kalman filter used&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilter&amp;gt; m_standard_filter;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The augmented estimation error covariances, that is the estimation error covariance for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::matrix&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp; Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A B ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C D ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ A B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ C D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ E F ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ E F ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ G H ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp;[ G H ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_estimation_error_covariances;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The augmented Kalman gains, that is the gain for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::matrix&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp; Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A B ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C D ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ A B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ C D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ E F ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ E F ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ G H ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp;[ G H ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_kalman_gains;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The augmented Kalman gains, that is the gain for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::matrix&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp; Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A B ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C D ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ A B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ C D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ E F ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ E F ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ G H ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp;[ G H ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_last_kalman_gains;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The last predicted augmented estimation error covariances,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///that is the estimation error covariance for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::matrix&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp; Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A B ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C D ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ A B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ C D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ E F ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ E F ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ G H ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp;[ G H ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_last_predicted_covariances;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The last predicted augmented states&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::vector&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ B ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ A ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ C ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ D ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp; [ D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_last_predicted_states;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The downcasted parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const FixedLagSmootherKalmanFilterParameters&amp;gt; m_parameters;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The augmented states, that is the state for each lag timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Use boost::numeric::ublas::vector&amp;lt;double&amp;gt; instead of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; to allow for matrix operation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;Complex&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Simplified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ A ] ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ B ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ A ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ B ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ C ] ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ C ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// [ [ D ] ]&amp;nbsp;&amp;nbsp; -&amp;gt;&amp;nbsp;&amp;nbsp; [ D ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_state_estimates;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; CreateComplexInitialStates(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const FixedLagSmootherKalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt; CreateInitialGains(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const StandardKalmanFilter&amp;amp; filter);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::numeric::ublas::vector&amp;lt;double&amp;gt; CreateInitialStates(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const FixedLagSmootherKalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ I ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///term_a = [ 0 ], where I denotes an identity matrix with size input.size() x input.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;and where 0 denotes a null matrix with size input.size() x input.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The length of term_a is equal to the lag (3 in this example)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::numeric::ublas::vector&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt; CreateComplexTermA(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int state_size);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ 0&amp;nbsp;&amp;nbsp;0&amp;nbsp;&amp;nbsp;0]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ I&amp;nbsp;&amp;nbsp;0&amp;nbsp;&amp;nbsp;0]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///term_b = [ 0&amp;nbsp;&amp;nbsp;I&amp;nbsp;&amp;nbsp;0], where I denotes an identity matrix with size input.size() x input.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; and where 0 denotes a null matrix with size input.size() x input.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The size of term_b is lag x lag (3 in this example)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::numeric::ublas::matrix&amp;lt;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; &amp;gt; CreateComplexTermB(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int state_size);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ 1 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ 0 1 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ I ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ 0 ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///term_a = [ 0 ] =&amp;gt; [ 0 0 ],&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;where I denotes an identity matrix with size input.size() x input.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;and where 0 denotes a null matrix with size input.size() x input.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The size of term_a will be:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// - number of rows&amp;nbsp;&amp;nbsp; : lag (3) x input.size() (2) = 6&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// - number of columns:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; input.size() (2) = 2&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; CreateTermA(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int state_size);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ 0 0 0 0 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ 0 0 0 0 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ 1 0 0 0 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ 0&amp;nbsp;&amp;nbsp;0&amp;nbsp;&amp;nbsp;0]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ 0 1 0 0 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; [ I&amp;nbsp;&amp;nbsp;0&amp;nbsp;&amp;nbsp;0]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[ 0 0 1 0 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///term_b = [ 0&amp;nbsp;&amp;nbsp;I&amp;nbsp;&amp;nbsp;0] =&amp;gt; [ 0 0 0 1 0 0 ]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///where I denotes an identity matrix with size input.size() x input.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; and where 0 denotes a null matrix with size input.size() x input.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The size of term_b is lag x lag (3 in this example)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The size of term_b will be:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// - number of rows&amp;nbsp;&amp;nbsp; : lag (3) x input.size() (2) = 6&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/// - number of columns: lag (3) x input.size() (2) = 6&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; CreateTermB(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int state_size);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;const FixedLagSmootherKalmanFilterParameters&amp;gt; DownCast(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the (unlagged) Kalman filter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilter&amp;gt; GetStandardKalmanFilter() const { return m_standard_filter; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Test this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static void Test() noexcept;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // FIXEDLAGSMOOTHERKALMANFILTER_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "fixedlagsmootherkalmanfiltercalculationelements.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "standardkalmanfiltercalculationelements.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::FixedLagSmootherKalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;measurement,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;predicted_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;previous_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;updated_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_calculation{}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//... nothing to check left&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::Clear()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterCalculationElements::Clear();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Others, e.g.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_updated_covariance = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::KalmanFilterCalculationElements&amp;gt; ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::Clone() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; p;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return p;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::IsComplete() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = GetMeasurement().size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sz != 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Others, e.g.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;amp;&amp;amp; sz == m_innovation.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;amp;&amp;amp; sz == m_innovation_covariance.size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;amp;&amp;amp; sz == m_innovation_covariance.size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;amp;&amp;amp; sz == m_innovation_covariance.size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetMeasurement().size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetPredictedState().size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetPreviousState().size();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::FixedLagSmootherKalmanFilterCalculationElements::SetStandardCalculationElement(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterCalculationElements&amp;gt;&amp;amp; standard_calculation)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_standard_calculation);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(standard_calculation);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_standard_calculation = standard_calculation;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_calculation);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/fixedlagsmootherkalmanfiltercalculationelements.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef FIXEDLAGSMOOTHERKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
#define FIXEDLAGSMOOTHERKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfiltercalculationelements.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct StandardKalmanFilterCalculationElements;&lt;br/&gt;
&lt;br/&gt;
struct FixedLagSmootherKalmanFilterCalculationElements : public KalmanFilterCalculationElements&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit FixedLagSmootherKalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state = boost::numeric::ublas::vector&amp;lt;double&amp;gt;());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Clear the calculation, will set IsComplete to false&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void Clear();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Produce a deep copy of the derived class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; Clone() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const { return KalmanFilterType::fixed_lag_smoother; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Checks if the state is complete and valid&lt;br/&gt;
&amp;nbsp;&amp;nbsp;bool IsComplete() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetStandardCalculationElement(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterCalculationElements&amp;gt;&amp;amp; standard_calculation);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::shared_ptr&amp;lt;const StandardKalmanFilterCalculationElements&amp;gt; m_standard_calculation;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~FixedLagSmootherKalmanFilterCalculationElements() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(FixedLagSmootherKalmanFilterCalculationElements*);&lt;br/&gt;
&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // FIXEDLAGSMOOTHERKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "fixedlagsmootherkalmanfilterfactory.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::FixedLagSmootherKalmanFilter&amp;gt; ribi::kalman::FixedLagSmootherKalmanFilterFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters-&amp;gt;GetType() == KalmanFilterType::fixed_lag_smoother);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;FixedLagSmootherKalmanFilterCalculationElements&amp;gt; calculation {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new FixedLagSmootherKalmanFilterCalculationElements&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(calculation);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;FixedLagSmootherKalmanFilter&amp;gt; kalman_filter {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new FixedLagSmootherKalmanFilter(calculation,parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(kalman_filter);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(kalman_filter-&amp;gt;GetType() == KalmanFilterType::fixed_lag_smoother);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return kalman_filter;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilterfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef FIXEDLAGSMOOTHERKALMANFILTERFACTORY_H&lt;br/&gt;
#define FIXEDLAGSMOOTHERKALMANFILTERFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "fixedlagsmootherkalmanfilter.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Factory for FixedLagSmootherKalmanFilter&lt;br/&gt;
struct FixedLagSmootherKalmanFilterFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;FixedLagSmootherKalmanFilter&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // FIXEDLAGSMOOTHERKALMANFILTERFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "fixedlagsmootherkalmanfilterparameters.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "standardkalmanfilterparameters.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::FixedLagSmootherKalmanFilterParameters::FixedLagSmootherKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterParameters&amp;gt;&amp;amp; standard_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int lag)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetControl(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetInitialStateEstimate(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetObservation(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetStateTransition()),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_lag{lag},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_parameters{standard_parameters}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag &amp;gt;= 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::FixedLagSmootherKalmanFilterParameters::HasParameterType(const KalmanFilterParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return StandardKalmanFilterParameters::HasParameterType(type);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/fixedlagsmootherkalmanfilterparameters.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef FIXEDLAGSMOOTHERKALMANFILTERPARAMETERS_H&lt;br/&gt;
#define FIXEDLAGSMOOTHERKALMANFILTERPARAMETERS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilterparameters.h"&lt;br/&gt;
#include "kalmanfiltertype.h"&lt;br/&gt;
#include "standardkalmanfilterparameters.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct FixedLagSmootherKalmanFilterParameters : public KalmanFilterParameters&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit FixedLagSmootherKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterParameters&amp;gt;&amp;amp; standard_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the lag in timesteps&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int GetLag() const { return m_lag; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The parameters from a standard Kalman filter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; GetStandardParameters() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_standard_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const { return KalmanFilterType::fixed_lag_smoother; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if this parameter set has a certain type of KalmanFilterParameter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool HasParameterType(const KalmanFilterParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~FixedLagSmootherKalmanFilterParameters() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(FixedLagSmootherKalmanFilterParameters*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The lag in timesteps&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int m_lag;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The parameters from a standard Kalman filter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; m_standard_parameters;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // FIXEDLAGSMOOTHERKALMANFILTERPARAMETERS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/gapsfilledwhitenoisesystem.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/gapsfilledwhitenoisesystem.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "gapsfilledwhitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
#include "gapsfilledwhitenoisesystem.h"&lt;br/&gt;
#include "gapsfilledwhitenoisesystemfactory.h"&lt;br/&gt;
#include "gapsfilledwhitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::GapsFilledWhiteNoiseSystem::GapsFilledWhiteNoiseSystem(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: WhiteNoiseSystem{parameters},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_last_measument{parameters-&amp;gt;GetInitialState().size(),0.0},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_parameters{boost::dynamic_pointer_cast&amp;lt;const GapsFilledWhiteNoiseSystemParameters&amp;gt;(parameters)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_timestep{0}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check measuring frequecies&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const auto v = m_parameters-&amp;gt;GetMeasurementFrequency();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::size_t sz = v.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (std::size_t i=0; i!=sz; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int x = v[i];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(x &amp;gt;= 1 &amp;amp;&amp;amp; "At least one out of one measurements is a real measurement");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::GapsFilledWhiteNoiseSystem::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.0";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::GapsFilledWhiteNoiseSystem::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-06-25: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::GapsFilledWhiteNoiseSystem::GoToNextState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Standard transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(input.size() == GetCurrentState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetStateTransition().size1() == GetCurrentState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetStateTransition().size2() == GetCurrentState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetControl().size1() == input.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetControl().size2() == input.size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; new_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(m_parameters-&amp;gt;GetStateTransition(),GetCurrentState())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ Matrix::Prod(m_parameters-&amp;gt;GetControl(),input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Add process noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto sz = new_state.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(new_state.size() == m_parameters-&amp;gt;GetProcessNoise().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (std::size_t i = 0; i!=sz; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new_state(i) = GetRandomNormal(new_state(i),m_parameters-&amp;gt;GetProcessNoise()(i));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;SetNewCurrentState(new_state);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt; ribi::kalman::GapsFilledWhiteNoiseSystem::Measure() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;int&amp;gt;&amp;amp; fs&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= this-&amp;gt;GetGapsFilledWhiteNoiseSystemParameters()-&amp;gt;GetMeasurementFrequency();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(fs.size() == m_last_measument.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(fs.size() == GetCurrentState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(fs.size() == m_parameters-&amp;gt;GetMeasurementNoise().size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t n_states = fs.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (std::size_t state=0; state!=n_states; ++state)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(state &amp;lt; fs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int f = fs[state];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(f &amp;gt;= 1);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (m_timestep % f == 0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(state &amp;lt; m_last_measument.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(state &amp;lt; GetCurrentState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(state &amp;lt; m_parameters-&amp;gt;GetMeasurementNoise().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_last_measument(state) = GetRandomNormal(GetCurrentState()(state),m_parameters-&amp;gt;GetMeasurementNoise()(state));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Should get here&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;++m_timestep;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m_last_measument;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::GapsFilledWhiteNoiseSystem::PeekAtRealState() const noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return this-&amp;gt;GetCurrentState();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
#ifndef NDEBUG&lt;br/&gt;
void ribi::kalman::GapsFilledWhiteNoiseSystem::Test() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static bool is_tested = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (is_tested) return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;is_tested = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Starting ribi::kalman::GapsFilledWhiteNoiseSystem::Test()")&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check if measurements are indeed lagged:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//The system's real value should update immediatly, but this fresh measurement&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//must only be accessible after lag timesteps&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Context: measuring the position of an object with constant velocity&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int f = 5;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;GapsFilledWhiteNoiseSystem&amp;gt; my_system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= GapsFilledWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateMatrix(1,1, { 1.0 } ), //control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateVector(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { 0.0 } ), //initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateVector(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; {&amp;nbsp;&amp;nbsp; f } ), //measurement frequencies&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateVector(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { 0.0000001 } ), //real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateVector(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { 0.0000001 } ), //real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateMatrix(1,1, { 1.0 } )&amp;nbsp;&amp;nbsp;//state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(my_system);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Context: airhockey puck&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; input = Matrix::CreateVector( { 1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i=0; i!= 3*f; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; measurements = my_system-&amp;gt;Measure();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!measurements.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(measurements.size() == 1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(measurements.size() == my_system-&amp;gt;PeekAtRealState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const double expected = static_cast&amp;lt;double&amp;gt;(i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const double measured = measurements(0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const double real = my_system-&amp;gt;PeekAtRealState()(0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(Matrix::IsAboutEqual(real,expected));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (i % f == 0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(Matrix::IsAboutEqual(measured,expected));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!Matrix::IsAboutEqual(measured,expected));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;my_system-&amp;gt;GoToNextState(input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Finished ribi::kalman::GapsFilledWhiteNoiseSystem::Test()")&lt;br/&gt;
}&lt;br/&gt;
#endif&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/gapsfilledwhitenoisesystem.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/gapsfilledwhitenoisesystem.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef GAPSFILLEDWHITENOISESYSTEM_H&lt;br/&gt;
#define GAPSFILLEDWHITENOISESYSTEM_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;queue&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystem.h"&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
#include "gapsfilledwhitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///A gaps-filled white noise system is a system that does not have a measurement every timestep.&lt;br/&gt;
///Instead, it has for example 1 measurement and then 4 non-measurements (which is a gap of 5)&lt;br/&gt;
///During the 4 non-measurements the 1 measurement is repeated&lt;br/&gt;
struct GapsFilledWhiteNoiseSystem : public WhiteNoiseSystem&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the gaps-filled white noise system parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const GapsFilledWhiteNoiseSystemParameters&amp;gt;&amp;amp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GetGapsFilledWhiteNoiseSystemParameters() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::gaps_filled; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void GoToNextState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Measure a value from this system with normally distributed noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; Measure() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Peek what the real value is&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; PeekAtRealState() const noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///GapsFilledWhiteNoiseSystem must be created with a GapsFilledWhiteNoiseSystemFactory&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit GapsFilledWhiteNoiseSystem(const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; white_noise_system_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend class GapsFilledWhiteNoiseSystemFactory;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~GapsFilledWhiteNoiseSystem() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(GapsFilledWhiteNoiseSystem*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The last successfull measurement&lt;br/&gt;
&amp;nbsp;&amp;nbsp;mutable boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_last_measument;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The gaps-filled white noise system parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const GapsFilledWhiteNoiseSystemParameters&amp;gt; m_parameters;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The current timestep: zero denotes a measurement will be done&lt;br/&gt;
&amp;nbsp;&amp;nbsp;mutable int m_timestep;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Test this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static void Test() noexcept;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // GAPSFILLEDWHITENOISESYSTEM_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/gapsfilledwhitenoisesystemfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/gapsfilledwhitenoisesystemfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "gapsfilledwhitenoisesystemfactory.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::GapsFilledWhiteNoiseSystem&amp;gt; ribi::kalman::GapsFilledWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;int&amp;gt;&amp;amp; measurement_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt; parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new GapsFilledWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;measurement_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters-&amp;gt;GetType() == WhiteNoiseSystemType::gaps_filled);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;GapsFilledWhiteNoiseSystem&amp;gt; system(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new GapsFilledWhiteNoiseSystem(parameters));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(system);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(system-&amp;gt;GetType() == WhiteNoiseSystemType::gaps_filled);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return system;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::GapsFilledWhiteNoiseSystem&amp;gt; ribi::kalman::GapsFilledWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystemParameters&amp;gt;&amp;amp; general_parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(general_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(general_parameters-&amp;gt;GetType() == WhiteNoiseSystemType::gaps_filled);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;GapsFilledWhiteNoiseSystemParameters&amp;gt; parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::dynamic_pointer_cast&amp;lt;GapsFilledWhiteNoiseSystemParameters&amp;gt;(general_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters-&amp;gt;GetType() == WhiteNoiseSystemType::gaps_filled);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;GapsFilledWhiteNoiseSystem&amp;gt; my_system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetControl(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetInitialState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetMeasurementFrequency(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetMeasurementNoise(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetProcessNoise(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetStateTransition());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(my_system);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(my_system-&amp;gt;GetType() == WhiteNoiseSystemType::gaps_filled);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return my_system;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/gapsfilledwhitenoisesystemfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/gapsfilledwhitenoisesystemfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef GAPSFILLEDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
#define GAPSFILLEDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "gapsfilledwhitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Factory for GapsFilledWhiteNoiseSystem&lt;br/&gt;
struct GapsFilledWhiteNoiseSystemFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Create a GapsFilledWhiteNoiseSystem from the loose parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;GapsFilledWhiteNoiseSystem&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;int&amp;gt;&amp;amp; measurement_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Create a GapsFilledWhiteNoiseSystem from the parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;GapsFilledWhiteNoiseSystem&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // GAPSFILLEDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/gapsfilledwhitenoisesystemparameters.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/gapsfilledwhitenoisesystemparameters.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "gapsfilledwhitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::GapsFilledWhiteNoiseSystemParameters::GapsFilledWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;int&amp;gt;&amp;amp; measurement_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: WhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_measurement_frequency{measurement_frequency}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_measurement_frequency.size() == initial_state.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check measuring frequecies&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const auto v = m_measurement_frequency;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::size_t sz = v.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (std::size_t i=0; i!=sz; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int x = v[i];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (x &amp;lt; 1)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TRACE(x);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TRACE("BREAK");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(x &amp;gt;= 1 &amp;amp;&amp;amp; "At least one out of one measurements is a real measurement");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
#ifndef NDEBUG&lt;br/&gt;
void ribi::kalman::GapsFilledWhiteNoiseSystemParameters::Test() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static bool is_tested = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (is_tested) return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;is_tested = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
#endif&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/gapsfilledwhitenoisesystemparameters.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/gapsfilledwhitenoisesystemparameters.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef GAPSFILLEDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
#define GAPSFILLEDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct GapsFilledWhiteNoiseSystemParameters : public WhiteNoiseSystemParameters&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit GapsFilledWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;int&amp;gt;&amp;amp; measurement_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The number of timesteps after which a real measurement is acquired&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;int&amp;gt;&amp;amp; GetMeasurementFrequency() const noexcept { return m_measurement_frequency; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::gaps_filled; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~GapsFilledWhiteNoiseSystemParameters() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(GapsFilledWhiteNoiseSystemParameters*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The gaps (in timesteps) is the number of measurements of which only one real measurement is acquired&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;int&amp;gt; m_measurement_frequency;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static void Test() noexcept;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // GAPSFILLEDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilter.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilter.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#include "kalmanfilter.h"&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilter::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.1";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::KalmanFilter::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-06: version 1.0: initial version",&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-09-09: version 1.1: removed data members"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilter.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilter.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTER_H&lt;br/&gt;
#define KALMANFILTER_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;vector&amp;gt;&lt;br/&gt;
#include &amp;lt;string&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#include "kalmanfiltertype.h"&lt;br/&gt;
#include "kalmanfilterparameters.h"&lt;br/&gt;
#include "kalmanfiltercalculationelements.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Kalman filter base class&lt;br/&gt;
struct KalmanFilter&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilter(const KalmanFilter&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilter&amp;amp; operator=(const KalmanFilter&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual ~KalmanFilter() noexcept {}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual KalmanFilterType GetType() const = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Get the Kalman filter last calculation elements&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; GetLastCalculation() const = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt; GetParameters() const = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual void SupplyMeasurementAndInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurements,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input) = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;protected:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit KalmanFilter() {}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;/*&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///An ABC can only be constructed by derived classes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit KalmanFilter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt;&amp;amp; calculation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The Kalman filter last calculation elements&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; m_last_calculation;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The Kalman filter parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt; m_parameters;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTER_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfiltercalculationelements.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfiltercalculationelements.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfiltercalculationelements.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::KalmanFilterCalculationElements::KalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: m_measurement{measurement},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_predicted_state{predicted_state},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_previous_state_estimate{previous_state_estimate},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_updated_state{updated_state}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Size may be zero&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = m_measurement.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_measurement.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_predicted_state.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_previous_state_estimate.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_updated_state.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::KalmanFilterCalculationElements::Clear()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_measurement = boost::numeric::ublas::vector&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_predicted_state = boost::numeric::ublas::vector&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_previous_state_estimate = boost::numeric::ublas::vector&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_updated_state = boost::numeric::ublas::vector&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_measurement.size() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!ribi::kalman::KalmanFilterCalculationElements::IsComplete());&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; ribi::kalman::KalmanFilterCalculationElements::GetMeasurement() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m_measurement;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; ribi::kalman::KalmanFilterCalculationElements::GetPredictedState() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m_predicted_state;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; ribi::kalman::KalmanFilterCalculationElements::GetPreviousState() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m_previous_state_estimate;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; ribi::kalman::KalmanFilterCalculationElements::GetUpdatedState() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m_updated_state;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterCalculationElements::IsComplete() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = m_measurement.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return sz != 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_measurement.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_predicted_state.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_previous_state_estimate.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_updated_state.size();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::KalmanFilterCalculationElements::SetMeasurement(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_measurement.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_measurement = measurement;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::KalmanFilterCalculationElements::SetPredictedState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_predicted_state.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_predicted_state = predicted_state;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::KalmanFilterCalculationElements::SetPreviousStateEstimate(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_previous_state_estimate.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_previous_state_estimate = previous_state_estimate;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::KalmanFilterCalculationElements::SetUpdatedState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_updated_state.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_updated_state = updated_state;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfiltercalculationelements.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfiltercalculationelements.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
#define KALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfiltertype.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///The elements of a steady-state Kalman filter calculation&lt;br/&gt;
struct KalmanFilterCalculationElements&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterCalculationElements(const KalmanFilterCalculationElements&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterCalculationElements&amp;amp; operator=(const KalmanFilterCalculationElements&amp;amp;) = delete;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual ~KalmanFilterCalculationElements() noexcept {}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Clear the calculation, will set IsComplete to false&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual void Clear();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the measurement ('z_n')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetMeasurement() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Get the predicted state ('x_predicted')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is calculated at step 1 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///x_predicted = [...] x_n-1 [...]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetPredictedState() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the previous_state_estimate ('x_prev')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetPreviousState() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the updated state ('x_n')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetUpdatedState() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual KalmanFilterType GetType() const = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Checks if the state is complete and valid&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual bool IsComplete() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the measurement ('z_n')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetMeasurement(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the predicted state ('x_predicted')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is calculated at step 1 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///x_predicted = [...] x_n-1 [...]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetPredictedState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the previous_state_estimate ('x_prev'/'x_n-1')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is read at step 1 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///x_predicted = [...] x_n-1 [...]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetPreviousStateEstimate(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the updated state ('x_n')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is calculated at step 6 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///x_n = x_predicted + [...]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetUpdatedState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;protected:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///An ABC can only be constructed by derived classes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit KalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Produce a deep copy of the derived class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; Clone() const = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend class KalmanFilterCalculationElementsFactory;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The measurement ('z_n')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_measurement;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The predicted state ('x_predicted')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_predicted_state;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The previous_state_estimate ('x_prev')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_previous_state_estimate;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The updated state ('x_n')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_updated_state;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfiltercalculationelementsfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfiltercalculationelementsfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfiltercalculationelementsfactory.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "standardkalmanfiltercalculationelements.h"&lt;br/&gt;
#include "steadystatekalmanfiltercalculationelements.h"&lt;br/&gt;
#include "fixedlagsmootherkalmanfiltercalculationelements.h"&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::KalmanFilterCalculationElements&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::KalmanFilterCalculationElementsFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const KalmanFilterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; p;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterType::fixed_lag_smoother:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p.reset(new FixedLagSmootherKalmanFilterCalculationElements);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterType::standard:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p.reset(new StandardKalmanFilterCalculationElements);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterType::steady_state:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p.reset(new SteadyStateKalmanFilterCalculationElements);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterType::n_types:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented KalmanFilterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p-&amp;gt;GetType() == type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return p;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::KalmanFilterCalculationElements&amp;gt; ribi::kalman::KalmanFilterCalculationElementsFactory::DeepCopy(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt;&amp;amp; original)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(original);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; my_copy = original-&amp;gt;Clone();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(my_copy);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(original-&amp;gt;GetType() == my_copy-&amp;gt;GetType());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return my_copy;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfiltercalculationelementsfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfiltercalculationelementsfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTERCALCULATIONELEMENTSFACTORY_H&lt;br/&gt;
#define KALMANFILTERCALCULATIONELEMENTSFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfiltercalculationelements.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct KalmanFilterCalculationElementsFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Create a KalmanFilterCalculationElements of a certain type&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const KalmanFilterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Deep copy&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; DeepCopy(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt;&amp;amp; elements);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTERCALCULATIONELEMENTSFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterexample.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterexample.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include "kalmanfilterexample.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;boost/math/constants/constants.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;memory&amp;gt;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;boost/lexical_cast.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/io.hpp&amp;gt;&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::KalmanFilterExample::KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string&amp;amp; title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string&amp;amp; context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt;&amp;amp; kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt;&amp;amp; white_noise_system_parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: m_context{context},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_inputs{inputs},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_kalman_filter_parameters{kalman_filter_parameters},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_number_of_timesteps{number_of_timesteps},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_state_names{state_names},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_title{title},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_white_noise_system_parameters{white_noise_system_parameters}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_state_names.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_state_names.size() == m_inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_state_names.size() == m_kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_state_names.size() == m_white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(number_of_timesteps &amp;gt;= 0);&lt;br/&gt;
&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;boost::shared_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; &amp;gt; ribi::kalman::KalmanFilterExample::CreateExamples()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::vector&amp;lt;boost::shared_ptr&amp;lt;KalmanFilterExample&amp;gt; &amp;gt; v;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (int i=0; ; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; p(CreateExample(i));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!p) return v;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterExample&amp;gt; q(p.release());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(q);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(q.use_count() == 1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!p);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;v.push_back(q);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Cannot get here: must return in for loop above");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample(const int i)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; p;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 0: p = CreateExample0(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 1: p = CreateExample1(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 2: p = CreateExample2(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 3: p = CreateExample3(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 4: p = CreateExample4(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 5: p = CreateExample5(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 6: p = CreateExample6(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 7: p = CreateExample7(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 8: p = CreateExample8(); break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;default: break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//When p is nullptr, this indicates that there are no more examples&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return p;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample0()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Constant voltage";&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 0.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 0.1 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 0.0001 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 1.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 3.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 1.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, {1.0} );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 1.25 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.1 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.00001 } );&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs = { "0.0" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "V" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::stringstream context_stream;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;context_stream&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;h1&amp;gt;" &amp;lt;&amp;lt; title &amp;lt;&amp;lt; "&amp;lt;/h1&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;This is an example from &amp;lt;a href=\"http://greg.czerniak.info/guides/kalman1\"&amp;gt;Greg Czerniak's tutorial&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;The context is the noisy measurement of a constant voltage.&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;ul&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State names: " &amp;lt;&amp;lt; DisplayAsUblasVector(state_names) &amp;lt;&amp;lt; ": the voltage&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, real: " &amp;lt;&amp;lt; initial_state &amp;lt;&amp;lt; ": just some voltage&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, estimate: " &amp;lt;&amp;lt; initial_state_estimate &amp;lt;&amp;lt; ": set this value off on purpose, to see the Kalman filter converge&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Input: " &amp;lt;&amp;lt; DisplayAsUblasVector(inputs) &amp;lt;&amp;lt; ": the state (that is, the voltage) will not be changed&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Control: " &amp;lt;&amp;lt; control &amp;lt;&amp;lt; ": any input (albeit none) will have no effect&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Observation: " &amp;lt;&amp;lt; observation &amp;lt;&amp;lt; ": the voltage is measured directly (that is: as a voltage)&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State transition: " &amp;lt;&amp;lt; state_transition &amp;lt;&amp;lt; ": the voltage remains constant&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, real: " &amp;lt;&amp;lt; real_measurement_noise &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, estimate: " &amp;lt;&amp;lt; estimated_measurement_noise &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, real: " &amp;lt;&amp;lt; real_process_noise &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, estimated covariance: " &amp;lt;&amp;lt; estimated_process_noise_covariance &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial covariance estimate: " &amp;lt;&amp;lt; initial_covariance_estimate &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/ul&amp;gt;";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context = context_stream.str();&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample1()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Accelerating car (two states)";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n = 2;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double acceleration = 1.0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double measurement_noise = 10.0; //Called 'measnoise'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double accelnoise = 0.2; //Called 'accelnoise'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double dt = 0.1; //Timestep&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 0.0,0.0,0.0,dt } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 1.0,0.0,0.0,1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 10.0,1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0,0.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 10.0 * measurement_noise,0.0,0.0,1000000.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 1.0,0.0,0.0,0.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10.0 * accelnoise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10.0 * accelnoise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10.0 * accelnoise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;10.0 * accelnoise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { measurement_noise, 1000000.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.5&amp;nbsp;&amp;nbsp;* accelnoise * dt * dt, accelnoise * dt} );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 1.0, 0.0, dt, 1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs = { "0.0", boost::lexical_cast&amp;lt;std::string&amp;gt;(acceleration) };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "x", "v" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size1() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size2() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetControl(),white_noise_system_parameters-&amp;gt;GetControl()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetStateTransition(),white_noise_system_parameters-&amp;gt;GetStateTransition()));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::stringstream context_stream;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;context_stream&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;h1&amp;gt;" &amp;lt;&amp;lt; title &amp;lt;&amp;lt; "&amp;lt;/h1&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;This is an example from D. Simon's article 'Kalman Filtering', published in 'Embedded Systems Programming' (June 2001).&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;The context is an accelerating car with a GPS and a defect speedometer&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;ul&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State names: " &amp;lt;&amp;lt; DisplayAsUblasVector(state_names) &amp;lt;&amp;lt; ": position (e.g. meter) and velocity (e.g. meter per second)&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, real: " &amp;lt;&amp;lt; initial_state &amp;lt;&amp;lt; ": car starts from standstill&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, estimate: " &amp;lt;&amp;lt; initial_state_estimate &amp;lt;&amp;lt; ": set this value off on purpose, to see the Kalman filter converge&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Input: " &amp;lt;&amp;lt; DisplayAsUblasVector(inputs) &amp;lt;&amp;lt; ": a gas pedal is pushed to a certain acceleration value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Control: " &amp;lt;&amp;lt; control &amp;lt;&amp;lt; ": a gas pedal has an influence on the velocity&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Observation: " &amp;lt;&amp;lt; observation &amp;lt;&amp;lt; ": only observe position, which can be observed directly with a GPS&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State transition: " &amp;lt;&amp;lt; state_transition &amp;lt;&amp;lt; ": the position is increased by a velocity, the velocity stays constant without input&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, real: " &amp;lt;&amp;lt; real_measurement_noise &amp;lt;&amp;lt; ": GPS works, speedometer does not&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, estimate: " &amp;lt;&amp;lt; estimated_measurement_noise &amp;lt;&amp;lt; ": just some pessimistic value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, real: " &amp;lt;&amp;lt; real_process_noise &amp;lt;&amp;lt; ": noise caused by acceleration&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, estimated covariance: " &amp;lt;&amp;lt; estimated_process_noise_covariance &amp;lt;&amp;lt; ": a more pessimistic value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial covariance estimate: " &amp;lt;&amp;lt; initial_covariance_estimate &amp;lt;&amp;lt; ": just a guess&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/ul&amp;gt;";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context = context_stream.str();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample2()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Cannonball";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n = 4; //Size of all vectors and matrices&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double dt = 0.1; //Timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double g = 9.81; //Gravity&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double pi = boost::math::constants::pi&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double angle = pi / 4.0; //Radians. 45 degrees = pi / 4.0 radians&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Gravity influences y and Vy&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 1.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Just a guess&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 1.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 1.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Initial state estimates are a bit off on purpose&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0, 100.0 * std::cos(angle), 500.0, 100.0 * sin(angle) } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Shot from the cannon with velocity 100.0 at an angle&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0, 100.0 * std::cos(angle), 0.0, 100.0 * sin(angle) } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Gravity influences position and velocity in the vertical direction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::lexical_cast&amp;lt;std::string&amp;gt;( 0.0 ),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::lexical_cast&amp;lt;std::string&amp;gt;( 0.0 ),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::lexical_cast&amp;lt;std::string&amp;gt;( -0.5*g*dt*dt ),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::lexical_cast&amp;lt;std::string&amp;gt;( -&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g*dt&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//ust an estimation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.2, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.2, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.2, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 0.2&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Can observe all positions and speeds&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 1.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 1.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Due to this being a simulation, one can safely assume no process noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 0.0, 0.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Noise in GPS and speedometer in cannonball&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 30.0, 30.0, 30.0, 30.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Due to this being a simulation, put in no process noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0, 0.0, 0.0, 0.0 } );&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Velocities influence positions&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ //Beware: appears as transposition of real matrix&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0, 0.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; dt, 1.0, 0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, 1.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0, dt , 1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "x", "Vx", "y", "Vy" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::stringstream context_stream;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;context_stream&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;h1&amp;gt;" &amp;lt;&amp;lt; title &amp;lt;&amp;lt; "&amp;lt;/h1&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;This is an example from &amp;lt;a href=\"http://greg.czerniak.info/guides/kalman1\"&amp;gt;Greg Czerniak's tutorial&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;The context is a cannonball lauched from a cannon.&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;ul&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State names: " &amp;lt;&amp;lt; DisplayAsUblasVector(state_names) &amp;lt;&amp;lt; ": horizontal position (m), horizontal velocity (m/s), vertical position (m), vertical velocity (m)&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, real: " &amp;lt;&amp;lt; initial_state &amp;lt;&amp;lt; ": the cannon shoots the ball from an angle of 45 degrees at an initial speed of 100 m/s&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, estimate: " &amp;lt;&amp;lt; initial_state_estimate &amp;lt;&amp;lt; ": set this value off on purpose, to see the Kalman filter converge&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Input: " &amp;lt;&amp;lt; DisplayAsUblasVector(inputs) &amp;lt;&amp;lt; ": gravity will change the vertical velocity by 9.81 m/(s^2)&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Control: " &amp;lt;&amp;lt; control &amp;lt;&amp;lt; ": gravity influences the vertical velocity only&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Observation: " &amp;lt;&amp;lt; observation &amp;lt;&amp;lt; ": all states are observed directly with a GPS and an internal speedometer&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State transition: " &amp;lt;&amp;lt; state_transition &amp;lt;&amp;lt; ": positions are increased by their velocities. Velocities remain constant without input&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, real: " &amp;lt;&amp;lt; real_measurement_noise &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, estimate: " &amp;lt;&amp;lt; estimated_measurement_noise &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, real: " &amp;lt;&amp;lt; real_process_noise &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, estimated covariance: " &amp;lt;&amp;lt; estimated_process_noise_covariance &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial covariance estimate: " &amp;lt;&amp;lt; initial_covariance_estimate &amp;lt;&amp;lt; ": just some low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/ul&amp;gt;";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context = context_stream.str();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample3()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Spring";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= "&amp;lt;h1&amp;gt;" + title + "&amp;lt;/h1&amp;gt;";&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Use spring system: a mass is lying on a frictionless surface and is connected to two horizontal springs&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n = 2; //Size of vectors and matrices&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double dt = 0.1; //Timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double k = 1.0; //Spring constant&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double mass = 1.0; //Mass&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//No input used, so control matrix can be zeroes only&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Just a guess&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Initial state estimates are a bit off on purpose&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { -10.0, -1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//From a perfect standstill at a certain position&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 10.0, 0.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//There is no input supplied&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::lexical_cast&amp;lt;std::string&amp;gt;( 0.0 ),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::lexical_cast&amp;lt;std::string&amp;gt;( 0.0 )&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Observe the position of the spring only&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0, 0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Some noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 1.0, 1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Simulation, so process noise is zero&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0, 0.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "x", "v" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ //As on paper&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0,&amp;nbsp;&amp;nbsp; -dt*k/mass,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dt , 0.99&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample4()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Airhockey puck";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= "&amp;lt;h1&amp;gt;" + title + "&amp;lt;/h1&amp;gt;";&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Context: airhockey puck with a constant speed&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 1.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 0.0000001 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 0.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 0.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, { 1.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(1,1, {1.0} );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0 } );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0 } );&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::lexical_cast&amp;lt;std::string&amp;gt;( 1.0 )&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "x" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample5()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Accelerating car (3 states)";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= "&amp;lt;h1&amp;gt;" + title + "&amp;lt;/h1&amp;gt;";&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Another accelerating car&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n = 3;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double force =&amp;nbsp;&amp;nbsp;1000.0; //Newton&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double mass&amp;nbsp;&amp;nbsp;= 10000.0; //kilogram&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double dt = 0.1; //Timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double acc = dt * force / mass;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//A gas pedal only influences acceleration&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,0.0,0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,0.0,0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,0.0,acc&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Just a guess&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0,0.0,0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,1.0,0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,0.0,1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Initial state estimates are a bit off on purpose&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 10.0,1.0,-1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//From exact standstill&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0,0.0,0.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Only (pessimistic) normal noise in GPS, speedometer and accelerometer&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;100.0,&amp;nbsp;&amp;nbsp;0.0,&amp;nbsp;&amp;nbsp;0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,100.0,&amp;nbsp;&amp;nbsp;0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,&amp;nbsp;&amp;nbsp;0.0,100.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Observe all: GPS, speedometer, accelerometer&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0,0.0,0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,1.0,0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,0.0,1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.1,0.0,0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,0.1,0.0,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0,0.0,0.1,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} ); //Pessimistic estimate&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Only normal noise in GPS, speedometer has enormous noise as if defect (yet cannot be 0.0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 10.0, 10.0, 10.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.01, 0.01, 0.01 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//x(t+1) = x(t) + dt*v(t) + 0.5*(dt^2)*a(t)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//v(t+1) =&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; v(t) +&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; (dt&amp;nbsp;&amp;nbsp;)*a(t)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//a(t+1) =&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; a(t)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ //Shown as on paper&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.0,&amp;nbsp;&amp;nbsp;dt, 0.5*dt*dt,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 1.0,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dt,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0, 0.0,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} ));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//A gas pedal only influences acceleration&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs = { "0.0", "0.0", "1.0" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "x", "v", "a" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size1() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size2() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetControl(),white_noise_system_parameters-&amp;gt;GetControl()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetStateTransition(),white_noise_system_parameters-&amp;gt;GetStateTransition()));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample6()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Exponential decay";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//One state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n = 1;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double epsilon = 0.00000000001;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Reach a 10% value after 1000 timesteps with the closed-form solution&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double gamma = -std::log(0.1)/1000.0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Reach a 10% value after 1000 timesteps with the recurrence equation&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double e = boost::math::constants::e&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double tau = std::pow(e,std::log(0.1) / 1000.0);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Just a variable name&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "x" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Input does not change state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 0.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { epsilon } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//From 100%&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Initial state estimate is correct on purpose&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate = initial_state;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { epsilon } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Observe directly&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { epsilon } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { epsilon } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { epsilon } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Reach a 10% value after 1000 timesteps with the recurrence equation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n, { tau } ));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Reach a 10% value after 1000 timesteps with the closed-form solution&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string input = std::string("exp(-") + boost::lexical_cast&amp;lt;std::string&amp;gt;(gamma) + "*(t+1))";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs = { input };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size1() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size2() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetControl(),white_noise_system_parameters-&amp;gt;GetControl()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetStateTransition(),white_noise_system_parameters-&amp;gt;GetStateTransition()));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::stringstream context_stream;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;context_stream&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;h1&amp;gt;" &amp;lt;&amp;lt; title &amp;lt;&amp;lt; "&amp;lt;/h1&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;&amp;amp;nbsp;&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;This is more of a mathematical example. It shows that" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;a recurrence equation and its closed-form solution for exponential" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;decay are equivalent" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The closed-form solution of exponential decay is:" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;f(t) = e^(-gamma*t)" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;Where t is the time step and gamma a constant, which is equal to -ln(0.1)/1000 = 0.0023025850929940454." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;This value of gamma lets the exponential decay reach 10% after 1000 timesteps." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The recurrence equation of exponential decay is:" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;f(t+1) = tau * f(t)" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;Where t is the time step and tau a constant, which is equal to e^(ln(0.1)/1000) = 0.99770006382255327." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;This value of tau lets the exponential decay reach 10% after 1000 timesteps." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The closed-form solution is plotted as the input, the recurrence equation as the state." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;Because the control matrix contains a zero only, the input has no influence on the state." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;For the cleanest look, all noise was set to a low value." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;&amp;amp;nbsp;&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;ul&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State names: " &amp;lt;&amp;lt; DisplayAsUblasVector(state_names) &amp;lt;&amp;lt; ": just a variable without meaning&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, real: " &amp;lt;&amp;lt; initial_state &amp;lt;&amp;lt; ": decay starting from 1.0&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, estimate: " &amp;lt;&amp;lt; initial_state_estimate &amp;lt;&amp;lt; ": set this value to the real value, there is no need to do estimation&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Input: " &amp;lt;&amp;lt; DisplayAsUblasVector(inputs) &amp;lt;&amp;lt; ": the closed-form solution of exponential decay. t must be increased by one timestep, because a Kalman Filter estimates after an update&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Control: " &amp;lt;&amp;lt; control &amp;lt;&amp;lt; ": input must have no effect in changing the state to do a valid comparison&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Observation: " &amp;lt;&amp;lt; observation &amp;lt;&amp;lt; ": the value is observed directly&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State transition: " &amp;lt;&amp;lt; state_transition &amp;lt;&amp;lt; ": the recurrence equation of exponential decay&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, real: " &amp;lt;&amp;lt; real_measurement_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, estimate: " &amp;lt;&amp;lt; estimated_measurement_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, real: " &amp;lt;&amp;lt; real_process_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, estimated covariance: " &amp;lt;&amp;lt; estimated_process_noise_covariance &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial covariance estimate: " &amp;lt;&amp;lt; initial_covariance_estimate &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/ul&amp;gt;"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context = context_stream.str();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample7()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Harmonic oscillation (two states)";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Two states&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n = 2;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double e = 0.00000000001;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Period of 100 timesteps&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double pi = boost::math::constants::pi&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double angular_frequency = 2.0 * pi / 100.0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Correct for floating point rounding errors that will increase the amplitude.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//This value is found by experimenting&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double correction = 0.998026148;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Name of the functions&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "sin", "cos" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Input does not change state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 0.0, 0.0, 0.0, 0.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Correct&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0, 1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Initial state estimate is correct on purpose&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate = initial_state;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Observe directly&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 1.0,0.0,0.0,1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { e,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { e,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Reach a 10% value after 1000 timesteps with the recurrence equation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;correction, angular_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-angular_frequency,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;correction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} ));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Reach a 10% value after 1000 timesteps with the closed-form solution&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string input1 = std::string("sin(") + boost::lexical_cast&amp;lt;std::string&amp;gt;(angular_frequency) + "*(t+1))";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string input2 = std::string("cos(") + boost::lexical_cast&amp;lt;std::string&amp;gt;(angular_frequency) + "*(t+1))";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs = { input1, input2 };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size1() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size2() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetControl(),white_noise_system_parameters-&amp;gt;GetControl()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetStateTransition(),white_noise_system_parameters-&amp;gt;GetStateTransition()));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::stringstream context_stream;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;context_stream&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;h1&amp;gt;" &amp;lt;&amp;lt; title &amp;lt;&amp;lt; "&amp;lt;/h1&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;&amp;amp;nbsp;&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;This is more of a mathematical example. It shows that" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;a recurrence equation and its closed-form solution for a harmonic" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;oscillation are equivalent" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The closed-form solution of a harmonic oscillation is:" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;code&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "x(t) = sin(angular_frequency*t)&amp;lt;br/&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "v(t) = cos(angular_frequency*t)&amp;lt;br/&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/code&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The period is set to 100 timesteps," &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;so the angular frequency equals 2*pi radian per period = 2 * pi / 100 = 0.0628." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The recurrence equation of a harmonic oscillation is" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;code&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "x(t+1) = c * x(t) + angular_frequency * v(t)&amp;lt;br/&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "v(t+1) = c * v(t) - angular_frequency * x(t)&amp;lt;br/&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/code&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;Where c is a correction close to 1.0, to prevent the amplitude from increasing beyond 1" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;(probably due to rounding errors)" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The closed-form solution is plotted as the input, the recurrence equation as the state." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;Because the control matrix contains a zero only, the input has no influence on the state." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;For the cleanest look, all noise was set to a low value." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;&amp;amp;nbsp;&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;ul&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State names: " &amp;lt;&amp;lt; DisplayAsUblasVector(state_names) &amp;lt;&amp;lt; ": position (e.g. meters) and velocity (e.g. meters per second)&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, real: " &amp;lt;&amp;lt; initial_state &amp;lt;&amp;lt; ": a sine starts at 0.0, a cosine starts at 1.0&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, estimate: " &amp;lt;&amp;lt; initial_state_estimate &amp;lt;&amp;lt; ": set this value to the real value, there is no need to do estimation&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Input: " &amp;lt;&amp;lt; DisplayAsUblasVector(inputs) &amp;lt;&amp;lt; ": the closed-form solution of a harmonic oscillation. t must be increased by one timestep, because a Kalman Filter estimates after an update&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Control: " &amp;lt;&amp;lt; control &amp;lt;&amp;lt; ": input must have no effect in changing the state to do a valid comparison&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Observation: " &amp;lt;&amp;lt; observation &amp;lt;&amp;lt; ": the value is observed directly&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State transition: " &amp;lt;&amp;lt; state_transition &amp;lt;&amp;lt; ": the recurrence equation of a harmonic oscillation&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, real: " &amp;lt;&amp;lt; real_measurement_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, estimate: " &amp;lt;&amp;lt; estimated_measurement_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, real: " &amp;lt;&amp;lt; real_process_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, estimated covariance: " &amp;lt;&amp;lt; estimated_process_noise_covariance &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial covariance estimate: " &amp;lt;&amp;lt; initial_covariance_estimate &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/ul&amp;gt;"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context = context_stream.str();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
std::unique_ptr&amp;lt;ribi::kalman::KalmanFilterExample&amp;gt; ribi::kalman::KalmanFilterExample::CreateExample8()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string title = "Harmonic oscillation (three states)";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Two states&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n = 3;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double e = 0.00000000001;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Period of 100 timesteps&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double pi = boost::math::constants::pi&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double angular_frequency = 2.0 * pi / 100.0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Correct for floating point rounding errors that will increase the amplitude.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//This value is found by experimenting&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double correction = 0.998026148;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int number_of_timesteps = 1000;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Name of the functions&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; state_names = { "x", "v", "a" };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Input does not change state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n,std::vector&amp;lt;double&amp;gt;(n*n,0.0));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,0.0,e,0.0,0.0,0.0,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Correct&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { 0.0, angular_frequency, -angular_frequency*angular_frequency } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Initial state estimate is correct on purpose&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; initial_state_estimate = initial_state;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,0.0,e,0.0,0.0,0.0,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Observe directly&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { 1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateMatrix(n,n, { e,0.0,0.0,0.0,e,0.0,0.0,0.0,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { e,e,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//As small as possible&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::CreateVector( { e,e,e } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Reach a 10% value after 1000 timesteps with the recurrence equation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::numeric::ublas::trans(Matrix::CreateMatrix(n,n,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;correction, angular_frequency,angular_frequency*angular_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-angular_frequency,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;correction,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angular_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-angular_frequency*angular_frequency,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0.0,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0.0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} ));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Reach a 10% value after 1000 timesteps with the closed-form solution&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string input1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= std::string("sin(") + boost::lexical_cast&amp;lt;std::string&amp;gt;(angular_frequency) + "*(t+1))";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string input2&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::lexical_cast&amp;lt;std::string&amp;gt;(angular_frequency)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ std::string("*cos(") + boost::lexical_cast&amp;lt;std::string&amp;gt;(angular_frequency)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ "*(t+1))";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string input3&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= std::string("-")&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ boost::lexical_cast&amp;lt;std::string&amp;gt;(angular_frequency)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ std::string("*")&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ boost::lexical_cast&amp;lt;std::string&amp;gt;(angular_frequency)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ std::string("*sin(") + boost::lexical_cast&amp;lt;std::string&amp;gt;(angular_frequency) + "*(t+1))";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; inputs = { input1, input2, input3 };&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; kalman_filter_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; white_noise_system_parameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size1() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(control.size2() &amp;gt; 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == inputs.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == kalman_filter_parameters-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(state_names.size() == white_noise_system_parameters-&amp;gt;GetInitialState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetControl(),white_noise_system_parameters-&amp;gt;GetControl()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreEqual(kalman_filter_parameters-&amp;gt;GetStateTransition(),white_noise_system_parameters-&amp;gt;GetStateTransition()));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::stringstream context_stream;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;context_stream&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;h1&amp;gt;" &amp;lt;&amp;lt; title &amp;lt;&amp;lt; "&amp;lt;/h1&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;&amp;amp;nbsp;&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;This is more of a mathematical example. It shows that" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;a recurrence equation and its closed-form solution for a harmonic" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;oscillation (three states) are equivalent" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The closed-form solution of a harmonic oscillation is:" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;code&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "x(t) = sin(angular_frequency*t)&amp;lt;br/&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "v(t) = cos(angular_frequency*t)&amp;lt;br/&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/code&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The period is set to 100 timesteps," &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;so the angular frequency equals 2*pi radian per period = 2 * pi / 100 = 0.0628." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The recurrence equation of a harmonic oscillation is" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;code&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "x(t+1) = c * x(t) + angular_frequency * v(t)&amp;lt;br/&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "v(t+1) = c * v(t) - angular_frequency * x(t)&amp;lt;br/&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/code&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;Where c is a correction close to 1.0, to prevent the amplitude from increasing beyond 1" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;(probably due to rounding errors)" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;The closed-form solution is plotted as the input, the recurrence equation as the state." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;Because the control matrix contains a zero only, the input has no influence on the state." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;For the cleanest look, all noise was set to a low value." &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;p&amp;gt;&amp;amp;nbsp;&amp;lt;/p&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;ul&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State names: " &amp;lt;&amp;lt; DisplayAsUblasVector(state_names) &amp;lt;&amp;lt; ": position (e.g. meters) and velocity (e.g. meters per second)&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, real: " &amp;lt;&amp;lt; initial_state &amp;lt;&amp;lt; ": a sine starts at 0.0, a cosine starts at 1.0&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial state, estimate: " &amp;lt;&amp;lt; initial_state_estimate &amp;lt;&amp;lt; ": set this value to the real value, there is no need to do estimation&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Input: " &amp;lt;&amp;lt; DisplayAsUblasVector(inputs) &amp;lt;&amp;lt; ": the closed-form solution of a harmonic oscillation. t must be increased by one timestep, because a Kalman Filter estimates after an update&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Control: " &amp;lt;&amp;lt; control &amp;lt;&amp;lt; ": input must have no effect in changing the state to do a valid comparison&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Observation: " &amp;lt;&amp;lt; observation &amp;lt;&amp;lt; ": the value is observed directly&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;State transition: " &amp;lt;&amp;lt; state_transition &amp;lt;&amp;lt; ": the recurrence equation of a harmonic oscillation&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, real: " &amp;lt;&amp;lt; real_measurement_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Measurement noise, estimate: " &amp;lt;&amp;lt; estimated_measurement_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, real: " &amp;lt;&amp;lt; real_process_noise &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Process noise, estimated covariance: " &amp;lt;&amp;lt; estimated_process_noise_covariance &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;nbsp;&amp;nbsp;&amp;lt;li&amp;gt;Initial covariance estimate: " &amp;lt;&amp;lt; initial_covariance_estimate &amp;lt;&amp;lt; ": some very low value&amp;lt;/li&amp;gt;" &amp;lt;&amp;lt; '\n'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;&amp;lt; "&amp;lt;/ul&amp;gt;"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string context = context_stream.str();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; example(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;white_noise_system_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(example);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return example;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilterExample::DisplayAsUblasVector(const std::vector&amp;lt;std::string&amp;gt;&amp;amp; v)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::stringstream s;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;s &amp;lt;&amp;lt; "[" &amp;lt;&amp;lt; v.size() &amp;lt;&amp;lt; "](";&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for(const std::string&amp;amp; str: v) { s &amp;lt;&amp;lt; str &amp;lt;&amp;lt; ","; }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Replace trailing comma with a closing bracket&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::string str = s.str();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;str[str.size() - 1] = ')';&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return str;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterexample.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterexample.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTEREXAMPLE_H&lt;br/&gt;
#define KALMANFILTEREXAMPLE_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;memory&amp;gt;&lt;br/&gt;
#include &amp;lt;vector&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/checked_delete.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "standardkalmanfilterparameters.h"&lt;br/&gt;
#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///KalmanFilterExample contains an example set of variables&lt;br/&gt;
struct KalmanFilterExample&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit KalmanFilterExample(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::string&amp;amp; title,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::string&amp;amp; context,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; inputs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt;&amp;amp; kalman_filter_parameters,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int number_of_timesteps,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt;&amp;amp; white_noise_system_parameters);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;boost::shared_ptr&amp;lt;KalmanFilterExample&amp;gt; &amp;gt; CreateExamples();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample(const int i);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string&amp;amp; GetContext() const { return m_context; }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; GetInputs() const { return m_inputs; }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt;&amp;amp; GetKalmanFilterParameters() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_kalman_filter_parameters; }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int GetNumberOfTimesteps() const { return m_number_of_timesteps; }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; GetStateNames() const { return m_state_names; }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string&amp;amp; GetTitle() const { return m_title; }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt;&amp;amp; GetWhiteNoiseSystemParameters() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return&amp;nbsp;&amp;nbsp;m_white_noise_system_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~KalmanFilterExample() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by smart pointers: boost::checked_delete and std::unique_ptr&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(KalmanFilterExample*);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(const KalmanFilterExample*);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend struct std::default_delete&amp;lt;KalmanFilterExample&amp;gt;;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string m_context;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; m_inputs;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; m_kalman_filter_parameters;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int m_number_of_timesteps;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; m_state_names;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string m_title;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; m_white_noise_system_parameters;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample0();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample1();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample2();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample3();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample4();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample5();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample6();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample7();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static std::unique_ptr&amp;lt;KalmanFilterExample&amp;gt; CreateExample8();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string DisplayAsUblasVector(const std::vector&amp;lt;std::string&amp;gt;&amp;amp; v);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTEREXAMPLE_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterexperiment.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterexperiment.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfilterexperiment.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfiltercalculationelementsfactory.h"&lt;br/&gt;
#include "modelfunctionparser.h"&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::KalmanFilterExperiment::KalmanFilterExperiment(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int time,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; input_functions,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilter&amp;gt; m_kalman_filter,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystem&amp;gt;&amp;amp; m_white_noise_system,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string&amp;amp; context&lt;br/&gt;
&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: m_calculation_elements{},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_context{context},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_inputs{ribi::kalman::KalmanFilterExperiment::ParseInput(input_functions,time)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_kalman_filter{m_kalman_filter},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_real_states{},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_state_names{state_names},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_white_noise_system{m_white_noise_system}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_kalman_filter);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;GetKalmanFilter());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;GetKalmanFilter()-&amp;gt;GetParameters());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_white_noise_system);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;GetWhiteNoiseSystem());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;GetWhiteNoiseSystem()-&amp;gt;GetParameters());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::size_t sz = state_names.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == state_names.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == this-&amp;gt;GetKalmanFilter()-&amp;gt;GetParameters()-&amp;gt;GetControl().size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == this-&amp;gt;GetKalmanFilter()-&amp;gt;GetParameters()-&amp;gt;GetControl().size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == this-&amp;gt;GetKalmanFilter()-&amp;gt;GetParameters()-&amp;gt;GetInitialStateEstimate().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == this-&amp;gt;GetKalmanFilter()-&amp;gt;GetParameters()-&amp;gt;GetObservation().size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == this-&amp;gt;GetKalmanFilter()-&amp;gt;GetParameters()-&amp;gt;GetObservation().size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == this-&amp;gt;GetKalmanFilter()-&amp;gt;GetParameters()-&amp;gt;GetStateTransition().size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == this-&amp;gt;GetKalmanFilter()-&amp;gt;GetParameters()-&amp;gt;GetStateTransition().size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == GetWhiteNoiseSystem()-&amp;gt;GetParameters()-&amp;gt;GetControl().size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == GetWhiteNoiseSystem()-&amp;gt;GetParameters()-&amp;gt;GetControl().size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == GetWhiteNoiseSystem()-&amp;gt;GetParameters()-&amp;gt;GetInitialState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == GetWhiteNoiseSystem()-&amp;gt;GetParameters()-&amp;gt;GetMeasurementNoise().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == GetWhiteNoiseSystem()-&amp;gt;GetParameters()-&amp;gt;GetProcessNoise().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == GetWhiteNoiseSystem()-&amp;gt;GetParameters()-&amp;gt;GetStateTransition().size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == GetWhiteNoiseSystem()-&amp;gt;PeekAtRealState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(sz == input_functions.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreAboutEqual(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_kalman_filter-&amp;gt;GetParameters()-&amp;gt;GetControl(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_white_noise_system-&amp;gt;GetParameters()-&amp;gt;GetControl()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::MatricesAreAboutEqual(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_kalman_filter-&amp;gt;GetParameters()-&amp;gt;GetStateTransition(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_white_noise_system-&amp;gt;GetParameters()-&amp;gt;GetStateTransition()));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (int i=0;i!=time;++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Update reality, that is, let the real system (i.e. reality) go to its next state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(i &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(GetInputs().size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input = GetInputs()[i];&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//assert(m_white_noise_system-&amp;gt;GetCurrentState().size() == input.size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_white_noise_system-&amp;gt;GoToNextState(input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Perform a noisy measurement&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; z_measured = m_white_noise_system-&amp;gt;Measure();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Pass this measurement to the filter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_kalman_filter-&amp;gt;SupplyMeasurementAndInput(z_measured,input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;catch (std::runtime_error&amp;amp; e)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Happens when innovation covariance becomes degenerate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//(that is, its determinant is zero)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;IsValid() &amp;amp;&amp;amp; "The experiment must end in a valid state");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;catch (...)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Should never get here");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;AppendRealState(m_white_noise_system-&amp;gt;PeekAtRealState());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Store&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; last_calculation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= KalmanFilterCalculationElementsFactory::DeepCopy(m_kalman_filter-&amp;gt;GetLastCalculation());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_calculation_elements.push_back(last_calculation);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(time == boost::numeric_cast&amp;lt;int&amp;gt;(m_calculation_elements.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;IsValid() &amp;amp;&amp;amp; "The experiment must end in a valid state");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::KalmanFilterExperiment::AppendRealState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_state)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;this-&amp;gt;m_real_states.push_back(real_state);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; ribi::kalman::KalmanFilterExperiment::GetMeasuredStates() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; v;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.reserve(m_calculation_elements.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = m_calculation_elements.end();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (auto i = m_calculation_elements.begin(); i!=j; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;v.push_back( (*i)-&amp;gt;GetMeasurement() );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; ribi::kalman::KalmanFilterExperiment::GetPredictedStates() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; v;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.reserve(m_calculation_elements.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = m_calculation_elements.end();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (auto i = m_calculation_elements.begin(); i!=j; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; element = *i;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;v.push_back( element-&amp;gt;GetPredictedState() );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperiment::IsValid() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Do not count the inputs: these are created at startup of the experiment&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//and always have the maximum size (of n_timesteps)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//const int n_inputs = boost::numeric_cast&amp;lt;int&amp;gt;(GetInputs().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n_real_states = boost::numeric_cast&amp;lt;int&amp;gt;(GetRealStates().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n_predicted_states = boost::numeric_cast&amp;lt;int&amp;gt;(GetPredictedStates().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n_measured_states = boost::numeric_cast&amp;lt;int&amp;gt;(GetMeasuredStates().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Does the experiment produce an equal amount of real, estimated and measured states?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return n_real_states == n_predicted_states&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; n_real_states == n_measured_states;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; ribi::kalman::KalmanFilterExperiment::ParseInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; input,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n_timesteps)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n_rows = n_timesteps;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int n_cols = input.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; m(n_rows,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt;(n_cols));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (int row=0; row!=n_rows; ++row)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int col=0; col!=n_cols; ++col)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(col &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(input.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::string&amp;amp; s = input[col];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const ModelFunctionParser f(s.empty() ? "0.0" : s, "t");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const double y = f.Evaluate( boost::numeric_cast&amp;lt;double&amp;gt;(row) );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(row &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(m.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(col &amp;lt; boost::numeric_cast&amp;lt;int&amp;gt;(m[row].size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m[row](col) = y;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;catch (std::runtime_error&amp;amp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TRACE("Unparsable function (will be parsed against 't'):");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TRACE(s);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Parsing the function should have succeeded, as the GUI takes this out");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(n_timesteps == boost::numeric_cast&amp;lt;int&amp;gt;(m.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m.empty() || input.size() == m[0].size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m;&lt;br/&gt;
&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterexperiment.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterexperiment.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTEREXPERIMENT_H&lt;br/&gt;
#define KALMANFILTEREXPERIMENT_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;vector&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/checked_delete.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "steadystatekalmanfilterparameters.h"&lt;br/&gt;
#include "steadystatekalmanfiltercalculationelements.h"&lt;br/&gt;
//#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
#include "kalmanfilter.h"&lt;br/&gt;
#include "whitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///A KalmanFilterExperiment&lt;br/&gt;
struct KalmanFilterExperiment&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterExperiment(const KalmanFilterExperiment&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterExperiment&amp;amp; operator=(const KalmanFilterExperiment&amp;amp;) = delete;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit KalmanFilterExperiment(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int time,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; input,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilter&amp;gt; kalman_filter,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; state_names,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystem&amp;gt;&amp;amp; white_noise_system,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::string&amp;amp; context = ""&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the calculation elements of each timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; &amp;gt;&amp;amp; GetCalculationElements() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_calculation_elements; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the HTML description of the context of this experiment&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string&amp;amp; GetContext() const { return m_context; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the predicted states&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The states are stored as a chronological collection (the std::vector) of states (the ublas::vector)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; GetPredictedStates() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the inputs of each timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The states are stored as a chronological collection (the std::vector) of inputs (the ublas::vector)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt;&amp;amp; GetInputs() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_inputs; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilter&amp;gt;&amp;amp; GetKalmanFilter() const { return m_kalman_filter; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the measured states, that is, measured with noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The states are stored as a chronological collection (the std::vector) of states (the ublas::vector)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; GetMeasuredStates() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the real states, that is, the values that would be measured without noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The states are stored as a chronological collection (the std::vector) of states (the ublas::vector)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt;&amp;amp; GetRealStates() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_real_states; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the state names&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; GetStateNames() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_state_names; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The white noise system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystem&amp;gt;&amp;amp; GetWhiteNoiseSystem() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_white_noise_system; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if the state of the class is valid&lt;br/&gt;
&amp;nbsp;&amp;nbsp;bool IsValid() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;protected:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Append a real state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void AppendRealState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_state);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~KalmanFilterExperiment() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(KalmanFilterExperiment*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; ParseInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt;&amp;amp; input,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int n_timesteps);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The calculation elements of each timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::vector&amp;lt;boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; &amp;gt; m_calculation_elements;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The HTML description of the context of this experiment&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string m_context;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The inputs of each timestep&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; m_inputs;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The Kalman filter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilter&amp;gt; m_kalman_filter;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The real state, that is, the values that would be measured without noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::vector&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; m_real_states;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///State names&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;std::string&amp;gt; m_state_names;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The white noise system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystem&amp;gt; m_white_noise_system;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTEREXPERIMENT_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterexperimentparameter.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterexperimentparameter.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#include "kalmanfilterexperimentparameter.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include &amp;lt;stdexcept&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilterparameter.h"&lt;br/&gt;
#include "whitenoisesystemparameter.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::pair&amp;lt;ribi::kalman::KalmanFilterParameterType,ribi::kalman::KalmanFilterExperimentParameterType&amp;gt; &amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::KalmanFilterExperimentParameter::m_map_kalman_filter = CreateMapKalmanFilter();&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::pair&amp;lt;ribi::kalman::WhiteNoiseSystemParameterType,ribi::kalman::KalmanFilterExperimentParameterType&amp;gt; &amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::KalmanFilterExperimentParameter::m_map_white_noise_system = CreateMapWhiteNoiseSystem();&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperimentParameter::CanConvertToKalmanFilterParameter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const KalmanFilterExperimentParameterType parameter)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = m_map_kalman_filter.end();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (auto i = m_map_kalman_filter.begin(); i!=j ;++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((*i).second == parameter) return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperimentParameter::CanConvertToWhiteNoiseSystemParameter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const KalmanFilterExperimentParameterType parameter)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = m_map_white_noise_system.end();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (auto i = m_map_white_noise_system.begin(); i!=j ;++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((*i).second == parameter) return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::KalmanFilterExperimentParameterType ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterExperimentParameter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const KalmanFilterParameterType parameter)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = m_map_kalman_filter.end();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (auto i = m_map_kalman_filter.begin(); i!=j ;++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((*i).first == parameter) return (*i).second;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Should never get here");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//throw std::logic_error(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;&amp;nbsp;"ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterExperimentParameter(const KalmanFilterParameterType parameter)");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::KalmanFilterExperimentParameterType ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterExperimentParameter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const WhiteNoiseSystemParameterType parameter)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = m_map_white_noise_system.end();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (auto i = m_map_white_noise_system.begin(); i!=j ;++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((*i).first == parameter) return (*i).second;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Should never get here");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterExperimentParameter(const WhiteNoiseSystemParameterType parameter)");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::KalmanFilterParameterType ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterParameter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const KalmanFilterExperimentParameterType parameter)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(CanConvertToKalmanFilterParameter(parameter));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = m_map_kalman_filter.end();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (auto i = m_map_kalman_filter.begin(); i!=j ;++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((*i).second == parameter) return (*i).first;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Should never get here");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"ribi::kalman::KalmanFilterExperimentParameter::ConvertToKalmanFilterParameter");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::WhiteNoiseSystemParameterType ribi::kalman::KalmanFilterExperimentParameter::ConvertToWhiteNoiseSystemParameter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const KalmanFilterExperimentParameterType parameter)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(CanConvertToWhiteNoiseSystemParameter(parameter));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto j = m_map_white_noise_system.end();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (auto i = m_map_white_noise_system.begin(); i!=j ;++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((*i).second == parameter) return (*i).first;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Should never get here");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"ribi::kalman::KalmanFilterExperimentParameter::ConvertToWhiteNoiseSystemParameter");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::pair&amp;lt;ribi::kalman::KalmanFilterParameterType,ribi::kalman::KalmanFilterExperimentParameterType&amp;gt; &amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::KalmanFilterExperimentParameter::CreateMapKalmanFilter()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::vector&amp;lt;std::pair&amp;lt;KalmanFilterParameterType,KalmanFilterExperimentParameterType&amp;gt; &amp;gt; v;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::estimated_optimal_kalman_gain,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::state_transition,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size()) == static_cast&amp;lt;int&amp;gt;(KalmanFilterParameterType::n_parameters));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::pair&amp;lt;ribi::kalman::WhiteNoiseSystemParameterType,ribi::kalman::KalmanFilterExperimentParameterType&amp;gt; &amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::KalmanFilterExperimentParameter::CreateMapWhiteNoiseSystem()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;std::vector&amp;lt;std::pair&amp;lt;WhiteNoiseSystemParameterType,KalmanFilterExperimentParameterType&amp;gt; &amp;gt; v;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::initial_state_real,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::initial_state_real&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::measurement_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::measurement_frequency&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;v.push_back(std::make_pair(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::state_transition,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size()) == static_cast&amp;lt;int&amp;gt;(WhiteNoiseSystemParameterType::n_parameters));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;ribi::kalman::KalmanFilterExperimentParameterType&amp;gt; ribi::kalman::KalmanFilterExperimentParameter::GetAll()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;KalmanFilterExperimentParameterType&amp;gt; v&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;=&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::control,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::estimated_measurement_noise,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::estimated_process_noise_covariance, //E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::initial_covariance_estimate,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::initial_state_estimate,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::measurement_frequency,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E&amp;nbsp;&amp;nbsp; W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::initial_state_real,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E&amp;nbsp;&amp;nbsp; W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::real_measurement_noise,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E&amp;nbsp;&amp;nbsp; W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::real_process_noise,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E&amp;nbsp;&amp;nbsp; W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::input,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::observation,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::state_names,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterExperimentParameterType::state_transition&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size()) == static_cast&amp;lt;int&amp;gt;(KalmanFilterExperimentParameterType::n_parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; "All parameters must be in");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperimentParameter::IsDouble(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::control:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::input:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::observation:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_names:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_transition:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"n_parameters is not implemented to be used");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsDouble: use of n_parameters");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsDouble: use of unimplemented type");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperimentParameter::IsFunction(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::control:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::input:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::observation:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_names:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_transition:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"n_parameters is not implemented to be used");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsFunction: use of n_parameters");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsFunction: use of unimplemented type");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperimentParameter::IsInt(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::control:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::input:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::observation:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_names:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_transition:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"n_parameters is not implemented to be used");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsInt: use of n_parameters");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsInt: use of unimplemented type");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperimentParameter::IsString(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::control:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::input:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::observation:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_names:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_transition:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"n_parameters is not implemented to be used");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsString: use of n_parameters");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsString: use of unimplemented type");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperimentParameter::IsMatrix(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return !ribi::kalman::KalmanFilterExperimentParameter::IsVector(type);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterExperimentParameter::IsVector(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::control:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::estimated_process_noise_covariance: return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_covariance_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_estimate:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::initial_state_real:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::measurement_frequency:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_measurement_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::real_process_noise:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::input:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::observation:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_names:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_transition:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"n_parameters is not implemented to be used");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsVector: use of n_parameters");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error("ribi::kalman::KalmanFilterExperimentParameter::IsVector: use of unimplemented type");&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
#ifndef NDEBUG&lt;br/&gt;
void ribi::kalman::KalmanFilterExperimentParameter::Test() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static bool is_tested = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (is_tested) return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;is_tested = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Started ribi::kalman::KalmanFilterExperimentParameter::Test");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::control));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::estimated_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::initial_covariance_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::initial_state_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::initial_state_real));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::measurement_frequency));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::real_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::real_process_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::input));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::observation));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsMatrix(KalmanFilterExperimentParameterType::state_names));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsMatrix(KalmanFilterExperimentParameterType::state_transition));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::control));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::estimated_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::initial_covariance_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsVector(KalmanFilterExperimentParameterType::initial_state_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsVector(KalmanFilterExperimentParameterType::initial_state_real));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsVector(KalmanFilterExperimentParameterType::measurement_frequency));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsVector(KalmanFilterExperimentParameterType::real_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsVector(KalmanFilterExperimentParameterType::real_process_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsVector(KalmanFilterExperimentParameterType::input));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::observation));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsVector(KalmanFilterExperimentParameterType::state_names));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsVector(KalmanFilterExperimentParameterType::state_transition));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::control));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::estimated_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::initial_covariance_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::initial_state_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::initial_state_real));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::measurement_frequency));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::real_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::real_process_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsString(KalmanFilterExperimentParameterType::input));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::observation));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsString(KalmanFilterExperimentParameterType::state_names));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsString(KalmanFilterExperimentParameterType::state_transition));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::control));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::estimated_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::initial_covariance_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::initial_state_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::initial_state_real));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::measurement_frequency));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::real_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::real_process_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsFunction(KalmanFilterExperimentParameterType::input));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::observation));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::state_names));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsFunction(KalmanFilterExperimentParameterType::state_transition));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::control));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::estimated_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::initial_covariance_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::initial_state_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::initial_state_real));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsDouble(KalmanFilterExperimentParameterType::measurement_frequency));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::real_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::real_process_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsDouble(KalmanFilterExperimentParameterType::input));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::observation));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsDouble(KalmanFilterExperimentParameterType::state_names));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsDouble(KalmanFilterExperimentParameterType::state_transition));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::control));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::estimated_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::estimated_optimal_kalman_gain));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::estimated_process_noise_covariance));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::initial_covariance_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::initial_state_estimate));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::initial_state_real));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert( IsInt(KalmanFilterExperimentParameterType::measurement_frequency));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::real_measurement_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::real_process_noise));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::input));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::observation));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::state_names));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!IsInt(KalmanFilterExperimentParameterType::state_transition));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Finished ribi::kalman::KalmanFilterExperimentParameter::Test");&lt;br/&gt;
}&lt;br/&gt;
#endif&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilterExperimentParameter::ToDescription(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for the subset&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (CanConvertToKalmanFilterParameter(type))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const KalmanFilterParameterType sub_type = ConvertToKalmanFilterParameter(type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return KalmanFilterParameter::ToDescription(sub_type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (CanConvertToWhiteNoiseSystemParameter(type))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const WhiteNoiseSystemParameterType sub_type = ConvertToWhiteNoiseSystemParameter(type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return WhiteNoiseSystemParameter::ToDescription(sub_type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check the unique types&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::input:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Vector of inputs");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_names:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Vector of the state element names");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;default: assert(!"Unimplemented type of KalmanFilterExperimentParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilterExperimentParameter::ToName(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for the subset&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (CanConvertToKalmanFilterParameter(type))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const KalmanFilterParameterType sub_type = ConvertToKalmanFilterParameter(type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return KalmanFilterParameter::ToName(sub_type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (CanConvertToWhiteNoiseSystemParameter(type))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const WhiteNoiseSystemParameterType sub_type = ConvertToWhiteNoiseSystemParameter(type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return WhiteNoiseSystemParameter::ToName(sub_type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check the unique types&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::input:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Input");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_names:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("State names");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;default: assert(!"Unimplemented type of KalmanFilterExperimentParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilterExperimentParameter::ToSymbol(const KalmanFilterExperimentParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for the subset&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (CanConvertToKalmanFilterParameter(type))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const KalmanFilterParameterType sub_type = ConvertToKalmanFilterParameter(type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return KalmanFilterParameter::ToSymbol(sub_type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (CanConvertToWhiteNoiseSystemParameter(type))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const WhiteNoiseSystemParameterType sub_type = ConvertToWhiteNoiseSystemParameter(type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return WhiteNoiseSystemParameter::ToSymbol(sub_type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check the unique types&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::input:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("y");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterExperimentParameterType::state_names:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string(""); //State names has no symbol&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;default: assert(!"Unimplemented type of KalmanFilterExperimentParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterexperimentparameter.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterexperimentparameter.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTEREXPERIMENTPARAMETER_H&lt;br/&gt;
#define KALMANFILTEREXPERIMENTPARAMETER_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;map&amp;gt;&lt;br/&gt;
#include &amp;lt;string&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilterparametertype.h"&lt;br/&gt;
#include "kalmanfilterexperimentparametertype.h"&lt;br/&gt;
#include "whitenoisesystemparametertype.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///A parameter used in a KalmanFilterExperiment&lt;br/&gt;
///Note that a KalmanFilterExperiment uses a KalmanFilter,&lt;br/&gt;
///which has its own parameter type called KalmanFilterParameter, which is&lt;br/&gt;
///a subset of these&lt;br/&gt;
struct KalmanFilterExperimentParameter&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if a convert from KalmanFilterExperimentParameter to a KalmanFilterParameter will succeed&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool CanConvertToKalmanFilterParameter(const KalmanFilterExperimentParameterType parameter);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if a convert from KalmanFilterExperimentParameter to a WhiteNoiseSystemParameter will succeed&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool CanConvertToWhiteNoiseSystemParameter(const KalmanFilterExperimentParameterType parameter);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Convert a KalmanFilterParameter to a KalmanFilterExperimentParameter,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///which will always succeed&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static KalmanFilterExperimentParameterType ConvertToKalmanFilterExperimentParameter(const KalmanFilterParameterType parameter);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Convert a KalmanFilterParameter to a KalmanFilterExperimentParameter,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///which will always succeed&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static KalmanFilterExperimentParameterType ConvertToKalmanFilterExperimentParameter(const WhiteNoiseSystemParameterType parameter);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Convert a KalmanFilterExperimentParameter to a KalmanFilterParameter,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///assumes CanConvertToKalmanFilterParameter succeeds&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static KalmanFilterParameterType ConvertToKalmanFilterParameter(const KalmanFilterExperimentParameterType parameter);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Convert a KalmanFilterExperimentParameter to a WhiteNoiseSystemParameterType,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///assumes CanConvertToWhiteNoiseSystemParameter succeeds&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static WhiteNoiseSystemParameterType ConvertToWhiteNoiseSystemParameter(const KalmanFilterExperimentParameterType parameter);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Get all KalmanFilterExperimentParameterType values&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;KalmanFilterExperimentParameterType&amp;gt; GetAll();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is this parameter a matrix/vector of type double?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsDouble(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is this parameter a matrix/vector of type std::string for a function?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsFunction(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is this parameter a matrix/vector of type integer?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsInt(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is this parameter a matrix/vector of type std::string?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsString(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is this parameter a matrix?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsMatrix(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is this parameter a vector?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsVector(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the full name of a type, e.g. 'Matrix to capture the physics of the system'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToDescription(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the full name of a type, e.g. 'State transition'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToName(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the symbol of a type, e.g. 'A'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToSymbol(const KalmanFilterExperimentParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Test this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static void Test() noexcept;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::pair&amp;lt;KalmanFilterParameterType,KalmanFilterExperimentParameterType&amp;gt; &amp;gt; m_map_kalman_filter;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::pair&amp;lt;WhiteNoiseSystemParameterType,KalmanFilterExperimentParameterType&amp;gt; &amp;gt; m_map_white_noise_system;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::pair&amp;lt;KalmanFilterParameterType,KalmanFilterExperimentParameterType&amp;gt; &amp;gt; CreateMapKalmanFilter();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::pair&amp;lt;WhiteNoiseSystemParameterType,KalmanFilterExperimentParameterType&amp;gt; &amp;gt; CreateMapWhiteNoiseSystem();&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTEREXPERIMENTPARAMETER_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterexperimentparametertype.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterexperimentparametertype.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilterexperimentparametertype.h"&lt;br/&gt;
&lt;br/&gt;
//#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
//#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator&amp;lt;(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) &amp;lt; static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator==(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) == static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator!=(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return !(lhs == rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterexperimentparametertype.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterexperimentparametertype.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTEREXPERIMENTPARAMETERTYPE_H&lt;br/&gt;
#define KALMANFILTEREXPERIMENTPARAMETERTYPE_H&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
//#include &amp;lt;vector&amp;gt;&lt;br/&gt;
&lt;br/&gt;
///These parameters overlap&lt;br/&gt;
///E: Experiment&lt;br/&gt;
///K: Kalman filter&lt;br/&gt;
///W: White noise system parameter&lt;br/&gt;
enum class KalmanFilterExperimentParameterType&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;control,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;estimated_optimal_kalman_gain,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance, //E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;initial_state_estimate,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;initial_state_real,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E&amp;nbsp;&amp;nbsp; W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;measurement_frequency,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E&amp;nbsp;&amp;nbsp; W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;real_measurement_noise,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E&amp;nbsp;&amp;nbsp; W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;real_process_noise,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E&amp;nbsp;&amp;nbsp; W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;input,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E&lt;br/&gt;
&amp;nbsp;&amp;nbsp;observation,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E K&lt;br/&gt;
&amp;nbsp;&amp;nbsp;state_names,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E&lt;br/&gt;
&amp;nbsp;&amp;nbsp;state_transition,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //E K W&lt;br/&gt;
&amp;nbsp;&amp;nbsp;n_parameters&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//E&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
bool operator&amp;lt;(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs);&lt;br/&gt;
bool operator==(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs);&lt;br/&gt;
bool operator!=(const KalmanFilterExperimentParameterType lhs, const KalmanFilterExperimentParameterType rhs);&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTEREXPERIMENTPARAMETERTYPE_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfilterfactory.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "standardkalmanfilterfactory.h"&lt;br/&gt;
#include "steadystatekalmanfilterfactory.h"&lt;br/&gt;
#include "fixedlagsmootherkalmanfilterfactory.h"&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::KalmanFilter&amp;gt; ribi::kalman::KalmanFilterFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::shared_ptr&amp;lt;KalmanFilter&amp;gt; kalman_filter;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch(parameters-&amp;gt;GetType())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterType::standard:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter = StandardKalmanFilterFactory::Create(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterType::steady_state:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter = SteadyStateKalmanFilterFactory::Create(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterType::fixed_lag_smoother:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kalman_filter = FixedLagSmootherKalmanFilterFactory::Create(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterType::n_types:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented Kalman filter type");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(kalman_filter-&amp;gt;GetType() == parameters-&amp;gt;GetType());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return kalman_filter;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTERFACTORY_H&lt;br/&gt;
#define KALMANFILTERFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilter.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Factory for KalmanFilter&lt;br/&gt;
struct KalmanFilterFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;KalmanFilter&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTERFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterparameter.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterparameter.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfilterparameter.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include &amp;lt;stdexcept&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;ribi::kalman::KalmanFilterParameterType&amp;gt; ribi::kalman::KalmanFilterParameter::GetAll()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;KalmanFilterParameterType&amp;gt; v {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::estimated_optimal_kalman_gain,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterParameterType::state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size()) == static_cast&amp;lt;int&amp;gt;(KalmanFilterParameterType::n_parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; "All parameters must be in");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterParameter::IsMatrix(const KalmanFilterParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return !ribi::kalman::KalmanFilterParameter::IsVector(type);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterParameter::IsVector(const KalmanFilterParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return type == KalmanFilterParameterType::initial_state_estimate;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilterParameter::ToDescription(const KalmanFilterParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::control:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix for converting input to state change");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_measurement_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix that has an estimated measurement noise covariance");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_optimal_kalman_gain:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix with the estimated optimal Kalman gain");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_process_noise_covariance:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix with the estimated process noise covariance");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::initial_covariance_estimate:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix with the initial covariance estimate");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::initial_state_estimate:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Vector with the initial state estimate");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::observation:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix that with effect of a measurement on a state change");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::state_transition:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix that contains the internal physics of the system; the effect of current state on the next state");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilterParameter::ToName(const KalmanFilterParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::control:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Control");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_measurement_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Estimated measurement error covariance");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_optimal_kalman_gain:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Estimated optimal Kalman gain");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_process_noise_covariance:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Estimated process noise covariance");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::initial_covariance_estimate:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Initial covariance estimate");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::initial_state_estimate:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Initial state estimate");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::observation:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Observation");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::state_transition:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("State transition");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilterParameter::ToSymbol(const KalmanFilterParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::control:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("B");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_measurement_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("R");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_optimal_kalman_gain:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("K");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::estimated_process_noise_covariance:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Q");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::initial_covariance_estimate:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("P");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::initial_state_estimate:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("x");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::observation:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("H");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::state_transition:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("A");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case KalmanFilterParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of KalmanFilterParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterparameter.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterparameter.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTERPARAMETER_H&lt;br/&gt;
#define KALMANFILTERPARAMETER_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;string&amp;gt;&lt;br/&gt;
#include "kalmanfilterparametertype.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///A single KalmanFilterParameter&lt;br/&gt;
///for example, the state transition matrix&lt;br/&gt;
/// - is a matrix&lt;br/&gt;
/// - is not a vector&lt;br/&gt;
/// - has a description like 'Matrix that [...]'&lt;br/&gt;
/// - has the name 'State transition matrix'&lt;br/&gt;
/// - has the symbol 'A'&lt;br/&gt;
struct KalmanFilterParameter&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain all KalmanFilterParameterType values, except n_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;KalmanFilterParameterType&amp;gt; GetAll();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is the type a matrix?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsMatrix(const KalmanFilterParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is the type a vector?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsVector(const KalmanFilterParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the full name of a type, e.g. 'Matrix to capture the physics of the system'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToDescription(const KalmanFilterParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the full name of a type, e.g. 'State transition'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToName(const KalmanFilterParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the symbol of a type, e.g. 'A'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToSymbol(const KalmanFilterParameterType type);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTERPARAMETER_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterparameters.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterparameters.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfilterparameters.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::KalmanFilterParameters::KalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: m_control{control},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_initial_state_estimate{initial_state_estimate},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_observation{observation},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_state_transition{state_transition}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for correct dimensionality&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = GetInitialStateEstimate().size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//assert(sz &amp;gt;= 0); //Inevitable for std::size_t&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetControl().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetControl().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetObservation().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetObservation().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetStateTransition().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetStateTransition().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetInitialStateEstimate().size() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::KalmanFilterParameters::HasParameterType(const KalmanFilterParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; type == KalmanFilterParameterType::control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::state_transition;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterparameters.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterparameters.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTERPARAMETERS_H&lt;br/&gt;
#define KALMANFILTERPARAMETERS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfiltertype.h"&lt;br/&gt;
#include "kalmanfilterparametertype.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///ABC for the parameters every Kalman filter needs at least&lt;br/&gt;
struct KalmanFilterParameters&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterParameters(const KalmanFilterParameters&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterParameters&amp;amp; operator=(const KalmanFilterParameters&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual ~KalmanFilterParameters() noexcept {}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual KalmanFilterType GetType() const = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the control matrix ('B'): the effect of inputs on the current states&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetControl() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_control; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///x: The initial state estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetInitialStateEstimate() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_initial_state_estimate; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain how the states are observed ('H')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetObservation() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_observation; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the state transition matrix ('F'), containing the physics of the system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetStateTransition() const { return m_state_transition; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if this parameter set has a certain type of KalmanFilterParameter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool HasParameterType(const KalmanFilterParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;protected:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///An ABC can only be constructed by derived classes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit KalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///B: control matrix: the effect of inputs on the current states&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_control;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///x: The initial state estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_initial_state_estimate;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///H: How the states are observed&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_observation;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///F: state transition matrix, containing the physics of the system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_state_transition;&lt;br/&gt;
&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTERPARAMETERS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterparametertype.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterparametertype.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfilterparametertype.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator&amp;lt;(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) &amp;lt; static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator==(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) == static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfilterparametertype.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfilterparametertype.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTERPARAMETERTYPE_H&lt;br/&gt;
#define KALMANFILTERPARAMETERTYPE_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;vector&amp;gt;&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///The matrix/vector types/names of Kalman filter parameters&lt;br/&gt;
enum class KalmanFilterParameterType&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;estimated_optimal_kalman_gain,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;state_transition,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;n_parameters //Must be last element, used in debugging&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
bool operator&amp;lt;(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs);&lt;br/&gt;
bool operator==(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs);&lt;br/&gt;
bool operator!=(const KalmanFilterParameterType lhs, const KalmanFilterParameterType rhs);&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTERPARAMETERTYPE_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfiltertype.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfiltertype.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#include "kalmanfiltertype.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include &amp;lt;stdexcept&amp;gt;&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator==(const KalmanFilterType lhs, const KalmanFilterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) == static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator!=(const KalmanFilterType lhs, const KalmanFilterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return !(lhs == rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator&amp;lt;(const KalmanFilterType lhs, const KalmanFilterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) &amp;lt; static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfiltertype.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfiltertype.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTERTYPE_H&lt;br/&gt;
#define KALMANFILTERTYPE_H&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
enum class KalmanFilterType&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//ensemble,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//extended,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;fixed_lag_smoother,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//hybrid&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//kalman_bucy&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//minimum_variance_smoother&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//modified_Bryson_Frazier_smoother&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//rauch_tung_striebel_smoother&lt;br/&gt;
&amp;nbsp;&amp;nbsp;standard, //Also called: 'discrete'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;steady_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//unscented,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;n_types //Must be last value, used in debugging&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
bool operator==(const KalmanFilterType lhs, const KalmanFilterType rhs);&lt;br/&gt;
bool operator!=(const KalmanFilterType lhs, const KalmanFilterType rhs);&lt;br/&gt;
bool operator&amp;lt;(const KalmanFilterType lhs, const KalmanFilterType rhs);&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTERTYPE_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfiltertypes.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfiltertypes.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#include "kalmanfiltertypes.h"&lt;br/&gt;
&lt;br/&gt;
boost::bimap&amp;lt;ribi::kalman::KalmanFilterType,std::string&amp;gt; ribi::kalman::KalmanFilterTypes::m_map;&lt;br/&gt;
&lt;br/&gt;
const boost::bimap&amp;lt;ribi::kalman::KalmanFilterType,std::string&amp;gt; ribi::kalman::KalmanFilterTypes::CreateMap()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::bimap&amp;lt;KalmanFilterType,std::string&amp;gt; m;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m.insert(boost::bimap&amp;lt;KalmanFilterType,std::string&amp;gt;::value_type(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterType::fixed_lag_smoother,std::string("fixed lag smoother")));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m.insert(boost::bimap&amp;lt;KalmanFilterType,std::string&amp;gt;::value_type(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterType::standard,std::string("discrete")));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m.insert(boost::bimap&amp;lt;KalmanFilterType,std::string&amp;gt;::value_type(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterType::steady_state,std::string("steady state")));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;ribi::kalman::KalmanFilterType&amp;gt; ribi::kalman::KalmanFilterTypes::GetAllTypes()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;KalmanFilterType&amp;gt; v&lt;br/&gt;
&amp;nbsp;&amp;nbsp;=&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterType::fixed_lag_smoother,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterType::standard,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterType::steady_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(static_cast&amp;lt;int&amp;gt;(v.size()) == static_cast&amp;lt;int&amp;gt;(KalmanFilterType::n_types));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
#ifndef NDEBUG&lt;br/&gt;
void ribi::kalman::KalmanFilterTypes::Test() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static bool is_tested = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (is_tested) return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;is_tested = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;KalmanFilterType&amp;gt; v = GetAllTypes();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = v.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (std::size_t i=0; i!=sz; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(i &amp;lt; v.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const KalmanFilterType t = v[i];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::string s = ToStr(t);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!s.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const KalmanFilterType u = ToType(s);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(u == t);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
#endif&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::KalmanFilterTypes::ToStr(const KalmanFilterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (m_map.left.empty()) m_map = CreateMap();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_map.left.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_map.left.count(type));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string s = m_map.left.find(type)-&amp;gt;second;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return s;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::KalmanFilterType ribi::kalman::KalmanFilterTypes::ToType(const std::string&amp;amp; s)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (m_map.right.empty()) m_map = CreateMap();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_map.right.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_map.right.count(s) == 1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const KalmanFilterType t = m_map.right.find(s)-&amp;gt;second;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return t;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/kalmanfiltertypes.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/kalmanfiltertypes.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef KALMANFILTERTYPES_H&lt;br/&gt;
#define KALMANFILTERTYPES_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;string&amp;gt;&lt;br/&gt;
#include &amp;lt;vector&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/bimap.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfiltertype.h"&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Class to work on one or more KalmanFilterType instances&lt;br/&gt;
struct KalmanFilterTypes&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;KalmanFilterType&amp;gt; GetAllTypes();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToStr(const KalmanFilterType type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static KalmanFilterType ToType(const std::string&amp;amp; s);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static boost::bimap&amp;lt;KalmanFilterType,std::string&amp;gt; m_map;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::bimap&amp;lt;KalmanFilterType,std::string&amp;gt; CreateMap();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static void Test() noexcept;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // KALMANFILTERTYPES_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/laggedwhitenoisesystem.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/laggedwhitenoisesystem.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "laggedwhitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
#include "laggedwhitenoisesystem.h"&lt;br/&gt;
#include "laggedwhitenoisesystemfactory.h"&lt;br/&gt;
#include "laggedwhitenoisesystemparameters.h"&lt;br/&gt;
#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
#include "standardwhitenoisesystemfactory.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::LaggedWhiteNoiseSystem::LaggedWhiteNoiseSystem(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: WhiteNoiseSystem{parameters},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_measuments{},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_parameters{boost::dynamic_pointer_cast&amp;lt;const LaggedWhiteNoiseSystemParameters&amp;gt;(parameters)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_system{StandardWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetControl(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetInitialState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetMeasurementNoise(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetProcessNoise(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parameters-&amp;gt;GetStateTransition())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetLag() &amp;gt;= 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(m_measuments.size()) &amp;lt;= m_parameters-&amp;gt;GetLag());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_system);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int lag = m_parameters-&amp;gt;GetLag();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;while (lag != boost::numeric_cast&amp;lt;int&amp;gt;(m_measuments.size()))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_measuments.push(m_system-&amp;gt;Measure());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag == boost::numeric_cast&amp;lt;int&amp;gt;(m_measuments.size()));&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::LaggedWhiteNoiseSystem::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.0";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::LaggedWhiteNoiseSystem::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-03: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::LaggedWhiteNoiseSystem::GoToNextState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_system-&amp;gt;GoToNextState(input);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt; ribi::kalman::LaggedWhiteNoiseSystem::Measure() const noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetLag() == boost::numeric_cast&amp;lt;int&amp;gt;(m_measuments.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_measuments.push(m_system-&amp;gt;Measure());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Result is copied now, to also work for m_lag == 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; result = m_measuments.front();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_measuments.pop();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetLag() == boost::numeric_cast&amp;lt;int&amp;gt;(m_measuments.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return result;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; ribi::kalman::LaggedWhiteNoiseSystem::PeekAtRealState() const noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m_system-&amp;gt;PeekAtRealState();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
#ifndef NDEBUG&lt;br/&gt;
void ribi::kalman::LaggedWhiteNoiseSystem::Test() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static bool is_tested = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (is_tested) return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;is_tested = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Starting ribi::kalman::LaggedWhiteNoiseSystem::Test()")&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check if measurements are indeed lagged:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//The system's real value should update immediatly, but this fresh measurement&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//must only be accessible after lag timesteps&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Context: measuring the position of an object with constant velocity&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag = 5;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;LaggedWhiteNoiseSystem&amp;gt; my_system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= LaggedWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateMatrix(1,1, { 1.0 } ), //control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateVector(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { 0.0 } ), //initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateVector(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { 0.0 } ), //real_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateVector(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; { 0.0 } ), //real_process_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Matrix::CreateMatrix(1,1, { 1.0 } )&amp;nbsp;&amp;nbsp;//state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; input = Matrix::CreateVector( { 1.0 } );&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i=0; i!=lag; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(Matrix::IsAboutEqual( my_system-&amp;gt;Measure()(0), 0.0));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(Matrix::IsAboutEqual( my_system-&amp;gt;PeekAtRealState()(0), boost::numeric_cast&amp;lt;double&amp;gt;(i) ) );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;my_system-&amp;gt;GoToNextState(input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i=0; i!=10; ++i) //10 = just some value&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const double expected = boost::numeric_cast&amp;lt;double&amp;gt;(i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(Matrix::IsAboutEqual( my_system-&amp;gt;Measure()(0), expected));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(Matrix::IsAboutEqual( my_system-&amp;gt;PeekAtRealState()(0), boost::numeric_cast&amp;lt;double&amp;gt;(lag + i) ) );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;my_system-&amp;gt;GoToNextState(input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;TRACE("Finished ribi::kalman::LaggedWhiteNoiseSystem::Test()")&lt;br/&gt;
}&lt;br/&gt;
#endif&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/laggedwhitenoisesystem.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/laggedwhitenoisesystem.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef LAGGEDWHITENOISESYSTEM_H&lt;br/&gt;
#define LAGGEDWHITENOISESYSTEM_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;queue&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystem.h"&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
#include "laggedwhitenoisesystemparameters.h"&lt;br/&gt;
#include "standardwhitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///A lagged white noise system is a system that can be measured only after a certain number&lt;br/&gt;
///of periods.&lt;br/&gt;
struct LaggedWhiteNoiseSystem : public WhiteNoiseSystem&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the lagged white noise system parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const LaggedWhiteNoiseSystemParameters&amp;gt;&amp;amp; GetLaggedWhiteNoiseSystemParameters() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::lagged; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void GoToNextState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Measure a value from this system with normally distributed noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; Measure() const noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Peek what the real value is&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; PeekAtRealState() const noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///LaggedWhiteNoiseSystem must be created with a LaggedWhiteNoiseSystemFactory&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit LaggedWhiteNoiseSystem(const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; white_noise_system_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend class LaggedWhiteNoiseSystemFactory;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~LaggedWhiteNoiseSystem() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(LaggedWhiteNoiseSystem*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The front one is the one that can be read,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///the back one is the freshest measurement&lt;br/&gt;
&amp;nbsp;&amp;nbsp;mutable std::queue&amp;lt;boost::numeric::ublas::vector&amp;lt;double&amp;gt; &amp;gt; m_measuments;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The lagged white noise system parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const LaggedWhiteNoiseSystemParameters&amp;gt; m_parameters;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The standard white noise system used as an engine&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::shared_ptr&amp;lt;StandardWhiteNoiseSystem&amp;gt; m_system;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Test this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static void Test() noexcept;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // LAGGEDWHITENOISESYSTEM_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/laggedwhitenoisesystemfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/laggedwhitenoisesystemfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "laggedwhitenoisesystemfactory.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::LaggedWhiteNoiseSystem&amp;gt; ribi::kalman::LaggedWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt; parameters{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new LaggedWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;LaggedWhiteNoiseSystem&amp;gt; system{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new LaggedWhiteNoiseSystem(parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(system);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return system;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::LaggedWhiteNoiseSystem&amp;gt; ribi::kalman::LaggedWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters-&amp;gt;GetType() == WhiteNoiseSystemType::lagged);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;LaggedWhiteNoiseSystemParameters&amp;gt; lagged_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::dynamic_pointer_cast&amp;lt;LaggedWhiteNoiseSystemParameters&amp;gt;(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lagged_parameters);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;LaggedWhiteNoiseSystem&amp;gt; my_system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lagged_parameters-&amp;gt;GetControl(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lagged_parameters-&amp;gt;GetInitialState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lagged_parameters-&amp;gt;GetLag(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lagged_parameters-&amp;gt;GetMeasurementNoise(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lagged_parameters-&amp;gt;GetProcessNoise(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lagged_parameters-&amp;gt;GetStateTransition());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(my_system);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return my_system;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/laggedwhitenoisesystemfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/laggedwhitenoisesystemfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef LAGGEDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
#define LAGGEDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "laggedwhitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Factory for LaggedWhiteNoiseSystem&lt;br/&gt;
struct LaggedWhiteNoiseSystemFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Create a LaggedWhiteNoiseSystem from the loose parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;LaggedWhiteNoiseSystem&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Create a LaggedWhiteNoiseSystem from the parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;LaggedWhiteNoiseSystem&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // LAGGEDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/laggedwhitenoisesystemparameters.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/laggedwhitenoisesystemparameters.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "laggedwhitenoisesystemparameters.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::LaggedWhiteNoiseSystemParameters::LaggedWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: WhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_lag{lag}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(lag &amp;gt;= 0);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/laggedwhitenoisesystemparameters.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/laggedwhitenoisesystemparameters.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef LAGGEDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
#define LAGGEDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct LaggedWhiteNoiseSystemParameters : public WhiteNoiseSystemParameters&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit LaggedWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const int lag,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The lag (in timesteps) the lagged white noise system has&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int GetLag() const noexcept { return m_lag; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The white noise system parameters of unlagged behavior&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt;&amp;amp; GetStandardWhiteNoiseSystemParameters() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;&amp;nbsp;{ return m_standard_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::lagged; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~LaggedWhiteNoiseSystemParameters() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(LaggedWhiteNoiseSystemParameters*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The lag (in timesteps) the lagged white noise system has&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int m_lag;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // LAGGEDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/Licence.txt&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/Licence.txt" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GNU GENERAL PUBLIC LICENSE&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Version 3, 29 June 2007&lt;br/&gt;
&lt;br/&gt;
 Copyright (C) 2007 Free Software Foundation, Inc. &amp;lt;http://fsf.org/&amp;gt;&lt;br/&gt;
 Everyone is permitted to copy and distribute verbatim copies&lt;br/&gt;
 of this license document, but changing it is not allowed.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Preamble&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The GNU General Public License is a free, copyleft license for&lt;br/&gt;
software and other kinds of works.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The licenses for most software and other practical works are designed&lt;br/&gt;
to take away your freedom to share and change the works.&amp;nbsp;&amp;nbsp;By contrast,&lt;br/&gt;
the GNU General Public License is intended to guarantee your freedom to&lt;br/&gt;
share and change all versions of a program--to make sure it remains free&lt;br/&gt;
software for all its users.&amp;nbsp;&amp;nbsp;We, the Free Software Foundation, use the&lt;br/&gt;
GNU General Public License for most of our software; it applies also to&lt;br/&gt;
any other work released this way by its authors.&amp;nbsp;&amp;nbsp;You can apply it to&lt;br/&gt;
your programs, too.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;When we speak of free software, we are referring to freedom, not&lt;br/&gt;
price.&amp;nbsp;&amp;nbsp;Our General Public Licenses are designed to make sure that you&lt;br/&gt;
have the freedom to distribute copies of free software (and charge for&lt;br/&gt;
them if you wish), that you receive source code or can get it if you&lt;br/&gt;
want it, that you can change the software or use pieces of it in new&lt;br/&gt;
free programs, and that you know you can do these things.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;To protect your rights, we need to prevent others from denying you&lt;br/&gt;
these rights or asking you to surrender the rights.&amp;nbsp;&amp;nbsp;Therefore, you have&lt;br/&gt;
certain responsibilities if you distribute copies of the software, or if&lt;br/&gt;
you modify it: responsibilities to respect the freedom of others.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;For example, if you distribute copies of such a program, whether&lt;br/&gt;
gratis or for a fee, you must pass on to the recipients the same&lt;br/&gt;
freedoms that you received.&amp;nbsp;&amp;nbsp;You must make sure that they, too, receive&lt;br/&gt;
or can get the source code.&amp;nbsp;&amp;nbsp;And you must show them these terms so they&lt;br/&gt;
know their rights.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Developers that use the GNU GPL protect your rights with two steps:&lt;br/&gt;
(1) assert copyright on the software, and (2) offer you this License&lt;br/&gt;
giving you legal permission to copy, distribute and/or modify it.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;For the developers' and authors' protection, the GPL clearly explains&lt;br/&gt;
that there is no warranty for this free software.&amp;nbsp;&amp;nbsp;For both users' and&lt;br/&gt;
authors' sake, the GPL requires that modified versions be marked as&lt;br/&gt;
changed, so that their problems will not be attributed erroneously to&lt;br/&gt;
authors of previous versions.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Some devices are designed to deny users access to install or run&lt;br/&gt;
modified versions of the software inside them, although the manufacturer&lt;br/&gt;
can do so.&amp;nbsp;&amp;nbsp;This is fundamentally incompatible with the aim of&lt;br/&gt;
protecting users' freedom to change the software.&amp;nbsp;&amp;nbsp;The systematic&lt;br/&gt;
pattern of such abuse occurs in the area of products for individuals to&lt;br/&gt;
use, which is precisely where it is most unacceptable.&amp;nbsp;&amp;nbsp;Therefore, we&lt;br/&gt;
have designed this version of the GPL to prohibit the practice for those&lt;br/&gt;
products.&amp;nbsp;&amp;nbsp;If such problems arise substantially in other domains, we&lt;br/&gt;
stand ready to extend this provision to those domains in future versions&lt;br/&gt;
of the GPL, as needed to protect the freedom of users.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Finally, every program is threatened constantly by software patents.&lt;br/&gt;
States should not allow patents to restrict development and use of&lt;br/&gt;
software on general-purpose computers, but in those that do, we wish to&lt;br/&gt;
avoid the special danger that patents applied to a free program could&lt;br/&gt;
make it effectively proprietary.&amp;nbsp;&amp;nbsp;To prevent this, the GPL assures that&lt;br/&gt;
patents cannot be used to render the program non-free.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The precise terms and conditions for copying, distribution and&lt;br/&gt;
modification follow.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; TERMS AND CONDITIONS&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;0. Definitions.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;"This License" refers to version 3 of the GNU General Public License.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;"Copyright" also means copyright-like laws that apply to other kinds of&lt;br/&gt;
works, such as semiconductor masks.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;"The Program" refers to any copyrightable work licensed under this&lt;br/&gt;
License.&amp;nbsp;&amp;nbsp;Each licensee is addressed as "you".&amp;nbsp;&amp;nbsp;"Licensees" and&lt;br/&gt;
"recipients" may be individuals or organizations.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;To "modify" a work means to copy from or adapt all or part of the work&lt;br/&gt;
in a fashion requiring copyright permission, other than the making of an&lt;br/&gt;
exact copy.&amp;nbsp;&amp;nbsp;The resulting work is called a "modified version" of the&lt;br/&gt;
earlier work or a work "based on" the earlier work.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;A "covered work" means either the unmodified Program or a work based&lt;br/&gt;
on the Program.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;To "propagate" a work means to do anything with it that, without&lt;br/&gt;
permission, would make you directly or secondarily liable for&lt;br/&gt;
infringement under applicable copyright law, except executing it on a&lt;br/&gt;
computer or modifying a private copy.&amp;nbsp;&amp;nbsp;Propagation includes copying,&lt;br/&gt;
distribution (with or without modification), making available to the&lt;br/&gt;
public, and in some countries other activities as well.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;To "convey" a work means any kind of propagation that enables other&lt;br/&gt;
parties to make or receive copies.&amp;nbsp;&amp;nbsp;Mere interaction with a user through&lt;br/&gt;
a computer network, with no transfer of a copy, is not conveying.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;An interactive user interface displays "Appropriate Legal Notices"&lt;br/&gt;
to the extent that it includes a convenient and prominently visible&lt;br/&gt;
feature that (1) displays an appropriate copyright notice, and (2)&lt;br/&gt;
tells the user that there is no warranty for the work (except to the&lt;br/&gt;
extent that warranties are provided), that licensees may convey the&lt;br/&gt;
work under this License, and how to view a copy of this License.&amp;nbsp;&amp;nbsp;If&lt;br/&gt;
the interface presents a list of user commands or options, such as a&lt;br/&gt;
menu, a prominent item in the list meets this criterion.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;1. Source Code.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The "source code" for a work means the preferred form of the work&lt;br/&gt;
for making modifications to it.&amp;nbsp;&amp;nbsp;"Object code" means any non-source&lt;br/&gt;
form of a work.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;A "Standard Interface" means an interface that either is an official&lt;br/&gt;
standard defined by a recognized standards body, or, in the case of&lt;br/&gt;
interfaces specified for a particular programming language, one that&lt;br/&gt;
is widely used among developers working in that language.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The "System Libraries" of an executable work include anything, other&lt;br/&gt;
than the work as a whole, that (a) is included in the normal form of&lt;br/&gt;
packaging a Major Component, but which is not part of that Major&lt;br/&gt;
Component, and (b) serves only to enable use of the work with that&lt;br/&gt;
Major Component, or to implement a Standard Interface for which an&lt;br/&gt;
implementation is available to the public in source code form.&amp;nbsp;&amp;nbsp;A&lt;br/&gt;
"Major Component", in this context, means a major essential component&lt;br/&gt;
(kernel, window system, and so on) of the specific operating system&lt;br/&gt;
(if any) on which the executable work runs, or a compiler used to&lt;br/&gt;
produce the work, or an object code interpreter used to run it.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The "Corresponding Source" for a work in object code form means all&lt;br/&gt;
the source code needed to generate, install, and (for an executable&lt;br/&gt;
work) run the object code and to modify the work, including scripts to&lt;br/&gt;
control those activities.&amp;nbsp;&amp;nbsp;However, it does not include the work's&lt;br/&gt;
System Libraries, or general-purpose tools or generally available free&lt;br/&gt;
programs which are used unmodified in performing those activities but&lt;br/&gt;
which are not part of the work.&amp;nbsp;&amp;nbsp;For example, Corresponding Source&lt;br/&gt;
includes interface definition files associated with source files for&lt;br/&gt;
the work, and the source code for shared libraries and dynamically&lt;br/&gt;
linked subprograms that the work is specifically designed to require,&lt;br/&gt;
such as by intimate data communication or control flow between those&lt;br/&gt;
subprograms and other parts of the work.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The Corresponding Source need not include anything that users&lt;br/&gt;
can regenerate automatically from other parts of the Corresponding&lt;br/&gt;
Source.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The Corresponding Source for a work in source code form is that&lt;br/&gt;
same work.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;2. Basic Permissions.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;All rights granted under this License are granted for the term of&lt;br/&gt;
copyright on the Program, and are irrevocable provided the stated&lt;br/&gt;
conditions are met.&amp;nbsp;&amp;nbsp;This License explicitly affirms your unlimited&lt;br/&gt;
permission to run the unmodified Program.&amp;nbsp;&amp;nbsp;The output from running a&lt;br/&gt;
covered work is covered by this License only if the output, given its&lt;br/&gt;
content, constitutes a covered work.&amp;nbsp;&amp;nbsp;This License acknowledges your&lt;br/&gt;
rights of fair use or other equivalent, as provided by copyright law.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You may make, run and propagate covered works that you do not&lt;br/&gt;
convey, without conditions so long as your license otherwise remains&lt;br/&gt;
in force.&amp;nbsp;&amp;nbsp;You may convey covered works to others for the sole purpose&lt;br/&gt;
of having them make modifications exclusively for you, or provide you&lt;br/&gt;
with facilities for running those works, provided that you comply with&lt;br/&gt;
the terms of this License in conveying all material for which you do&lt;br/&gt;
not control copyright.&amp;nbsp;&amp;nbsp;Those thus making or running the covered works&lt;br/&gt;
for you must do so exclusively on your behalf, under your direction&lt;br/&gt;
and control, on terms that prohibit them from making any copies of&lt;br/&gt;
your copyrighted material outside their relationship with you.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Conveying under any other circumstances is permitted solely under&lt;br/&gt;
the conditions stated below.&amp;nbsp;&amp;nbsp;Sublicensing is not allowed; section 10&lt;br/&gt;
makes it unnecessary.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;3. Protecting Users' Legal Rights From Anti-Circumvention Law.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;No covered work shall be deemed part of an effective technological&lt;br/&gt;
measure under any applicable law fulfilling obligations under article&lt;br/&gt;
11 of the WIPO copyright treaty adopted on 20 December 1996, or&lt;br/&gt;
similar laws prohibiting or restricting circumvention of such&lt;br/&gt;
measures.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;When you convey a covered work, you waive any legal power to forbid&lt;br/&gt;
circumvention of technological measures to the extent such circumvention&lt;br/&gt;
is effected by exercising rights under this License with respect to&lt;br/&gt;
the covered work, and you disclaim any intention to limit operation or&lt;br/&gt;
modification of the work as a means of enforcing, against the work's&lt;br/&gt;
users, your or third parties' legal rights to forbid circumvention of&lt;br/&gt;
technological measures.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;4. Conveying Verbatim Copies.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You may convey verbatim copies of the Program's source code as you&lt;br/&gt;
receive it, in any medium, provided that you conspicuously and&lt;br/&gt;
appropriately publish on each copy an appropriate copyright notice;&lt;br/&gt;
keep intact all notices stating that this License and any&lt;br/&gt;
non-permissive terms added in accord with section 7 apply to the code;&lt;br/&gt;
keep intact all notices of the absence of any warranty; and give all&lt;br/&gt;
recipients a copy of this License along with the Program.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You may charge any price or no price for each copy that you convey,&lt;br/&gt;
and you may offer support or warranty protection for a fee.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;5. Conveying Modified Source Versions.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You may convey a work based on the Program, or the modifications to&lt;br/&gt;
produce it from the Program, in the form of source code under the&lt;br/&gt;
terms of section 4, provided that you also meet all of these conditions:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a) The work must carry prominent notices stating that you modified&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;it, and giving a relevant date.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b) The work must carry prominent notices stating that it is&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;released under this License and any conditions added under section&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;7.&amp;nbsp;&amp;nbsp;This requirement modifies the requirement in section 4 to&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"keep intact all notices".&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c) You must license the entire work, as a whole, under this&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;License to anyone who comes into possession of a copy.&amp;nbsp;&amp;nbsp;This&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;License will therefore apply, along with any applicable section 7&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;additional terms, to the whole of the work, and all its parts,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;regardless of how they are packaged.&amp;nbsp;&amp;nbsp;This License gives no&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;permission to license the work in any other way, but it does not&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;invalidate such permission if you have separately received it.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;d) If the work has interactive user interfaces, each must display&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Appropriate Legal Notices; however, if the Program has interactive&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;interfaces that do not display Appropriate Legal Notices, your&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;work need not make them do so.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;A compilation of a covered work with other separate and independent&lt;br/&gt;
works, which are not by their nature extensions of the covered work,&lt;br/&gt;
and which are not combined with it such as to form a larger program,&lt;br/&gt;
in or on a volume of a storage or distribution medium, is called an&lt;br/&gt;
"aggregate" if the compilation and its resulting copyright are not&lt;br/&gt;
used to limit the access or legal rights of the compilation's users&lt;br/&gt;
beyond what the individual works permit.&amp;nbsp;&amp;nbsp;Inclusion of a covered work&lt;br/&gt;
in an aggregate does not cause this License to apply to the other&lt;br/&gt;
parts of the aggregate.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;6. Conveying Non-Source Forms.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You may convey a covered work in object code form under the terms&lt;br/&gt;
of sections 4 and 5, provided that you also convey the&lt;br/&gt;
machine-readable Corresponding Source under the terms of this License,&lt;br/&gt;
in one of these ways:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a) Convey the object code in, or embodied in, a physical product&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(including a physical distribution medium), accompanied by the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Corresponding Source fixed on a durable physical medium&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;customarily used for software interchange.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b) Convey the object code in, or embodied in, a physical product&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(including a physical distribution medium), accompanied by a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;written offer, valid for at least three years and valid for as&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;long as you offer spare parts or customer support for that product&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;model, to give anyone who possesses the object code either (1) a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;copy of the Corresponding Source for all the software in the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;product that is covered by this License, on a durable physical&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;medium customarily used for software interchange, for a price no&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;more than your reasonable cost of physically performing this&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;conveying of source, or (2) access to copy the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Corresponding Source from a network server at no charge.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c) Convey individual copies of the object code with a copy of the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;written offer to provide the Corresponding Source.&amp;nbsp;&amp;nbsp;This&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alternative is allowed only occasionally and noncommercially, and&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;only if you received the object code with such an offer, in accord&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;with subsection 6b.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;d) Convey the object code by offering access from a designated&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;place (gratis or for a charge), and offer equivalent access to the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Corresponding Source in the same way through the same place at no&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;further charge.&amp;nbsp;&amp;nbsp;You need not require recipients to copy the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Corresponding Source along with the object code.&amp;nbsp;&amp;nbsp;If the place to&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;copy the object code is a network server, the Corresponding Source&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;may be on a different server (operated by you or a third party)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;that supports equivalent copying facilities, provided you maintain&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;clear directions next to the object code saying where to find the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Corresponding Source.&amp;nbsp;&amp;nbsp;Regardless of what server hosts the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Corresponding Source, you remain obligated to ensure that it is&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;available for as long as needed to satisfy these requirements.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e) Convey the object code using peer-to-peer transmission, provided&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;you inform other peers where the object code and Corresponding&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Source of the work are being offered to the general public at no&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;charge under subsection 6d.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;A separable portion of the object code, whose source code is excluded&lt;br/&gt;
from the Corresponding Source as a System Library, need not be&lt;br/&gt;
included in conveying the object code work.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;A "User Product" is either (1) a "consumer product", which means any&lt;br/&gt;
tangible personal property which is normally used for personal, family,&lt;br/&gt;
or household purposes, or (2) anything designed or sold for incorporation&lt;br/&gt;
into a dwelling.&amp;nbsp;&amp;nbsp;In determining whether a product is a consumer product,&lt;br/&gt;
doubtful cases shall be resolved in favor of coverage.&amp;nbsp;&amp;nbsp;For a particular&lt;br/&gt;
product received by a particular user, "normally used" refers to a&lt;br/&gt;
typical or common use of that class of product, regardless of the status&lt;br/&gt;
of the particular user or of the way in which the particular user&lt;br/&gt;
actually uses, or expects or is expected to use, the product.&amp;nbsp;&amp;nbsp;A product&lt;br/&gt;
is a consumer product regardless of whether the product has substantial&lt;br/&gt;
commercial, industrial or non-consumer uses, unless such uses represent&lt;br/&gt;
the only significant mode of use of the product.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;"Installation Information" for a User Product means any methods,&lt;br/&gt;
procedures, authorization keys, or other information required to install&lt;br/&gt;
and execute modified versions of a covered work in that User Product from&lt;br/&gt;
a modified version of its Corresponding Source.&amp;nbsp;&amp;nbsp;The information must&lt;br/&gt;
suffice to ensure that the continued functioning of the modified object&lt;br/&gt;
code is in no case prevented or interfered with solely because&lt;br/&gt;
modification has been made.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If you convey an object code work under this section in, or with, or&lt;br/&gt;
specifically for use in, a User Product, and the conveying occurs as&lt;br/&gt;
part of a transaction in which the right of possession and use of the&lt;br/&gt;
User Product is transferred to the recipient in perpetuity or for a&lt;br/&gt;
fixed term (regardless of how the transaction is characterized), the&lt;br/&gt;
Corresponding Source conveyed under this section must be accompanied&lt;br/&gt;
by the Installation Information.&amp;nbsp;&amp;nbsp;But this requirement does not apply&lt;br/&gt;
if neither you nor any third party retains the ability to install&lt;br/&gt;
modified object code on the User Product (for example, the work has&lt;br/&gt;
been installed in ROM).&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The requirement to provide Installation Information does not include a&lt;br/&gt;
requirement to continue to provide support service, warranty, or updates&lt;br/&gt;
for a work that has been modified or installed by the recipient, or for&lt;br/&gt;
the User Product in which it has been modified or installed.&amp;nbsp;&amp;nbsp;Access to a&lt;br/&gt;
network may be denied when the modification itself materially and&lt;br/&gt;
adversely affects the operation of the network or violates the rules and&lt;br/&gt;
protocols for communication across the network.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Corresponding Source conveyed, and Installation Information provided,&lt;br/&gt;
in accord with this section must be in a format that is publicly&lt;br/&gt;
documented (and with an implementation available to the public in&lt;br/&gt;
source code form), and must require no special password or key for&lt;br/&gt;
unpacking, reading or copying.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;7. Additional Terms.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;"Additional permissions" are terms that supplement the terms of this&lt;br/&gt;
License by making exceptions from one or more of its conditions.&lt;br/&gt;
Additional permissions that are applicable to the entire Program shall&lt;br/&gt;
be treated as though they were included in this License, to the extent&lt;br/&gt;
that they are valid under applicable law.&amp;nbsp;&amp;nbsp;If additional permissions&lt;br/&gt;
apply only to part of the Program, that part may be used separately&lt;br/&gt;
under those permissions, but the entire Program remains governed by&lt;br/&gt;
this License without regard to the additional permissions.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;When you convey a copy of a covered work, you may at your option&lt;br/&gt;
remove any additional permissions from that copy, or from any part of&lt;br/&gt;
it.&amp;nbsp;&amp;nbsp;(Additional permissions may be written to require their own&lt;br/&gt;
removal in certain cases when you modify the work.)&amp;nbsp;&amp;nbsp;You may place&lt;br/&gt;
additional permissions on material, added by you to a covered work,&lt;br/&gt;
for which you have or can give appropriate copyright permission.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Notwithstanding any other provision of this License, for material you&lt;br/&gt;
add to a covered work, you may (if authorized by the copyright holders of&lt;br/&gt;
that material) supplement the terms of this License with terms:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a) Disclaiming warranty or limiting liability differently from the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;terms of sections 15 and 16 of this License; or&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b) Requiring preservation of specified reasonable legal notices or&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;author attributions in that material or in the Appropriate Legal&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Notices displayed by works containing it; or&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c) Prohibiting misrepresentation of the origin of that material, or&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;requiring that modified versions of such material be marked in&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reasonable ways as different from the original version; or&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;d) Limiting the use for publicity purposes of names of licensors or&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;authors of the material; or&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e) Declining to grant rights under trademark law for use of some&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;trade names, trademarks, or service marks; or&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;f) Requiring indemnification of licensors and authors of that&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;material by anyone who conveys the material (or modified versions of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;it) with contractual assumptions of liability to the recipient, for&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;any liability that these contractual assumptions directly impose on&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;those licensors and authors.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;All other non-permissive additional terms are considered "further&lt;br/&gt;
restrictions" within the meaning of section 10.&amp;nbsp;&amp;nbsp;If the Program as you&lt;br/&gt;
received it, or any part of it, contains a notice stating that it is&lt;br/&gt;
governed by this License along with a term that is a further&lt;br/&gt;
restriction, you may remove that term.&amp;nbsp;&amp;nbsp;If a license document contains&lt;br/&gt;
a further restriction but permits relicensing or conveying under this&lt;br/&gt;
License, you may add to a covered work material governed by the terms&lt;br/&gt;
of that license document, provided that the further restriction does&lt;br/&gt;
not survive such relicensing or conveying.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If you add terms to a covered work in accord with this section, you&lt;br/&gt;
must place, in the relevant source files, a statement of the&lt;br/&gt;
additional terms that apply to those files, or a notice indicating&lt;br/&gt;
where to find the applicable terms.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Additional terms, permissive or non-permissive, may be stated in the&lt;br/&gt;
form of a separately written license, or stated as exceptions;&lt;br/&gt;
the above requirements apply either way.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;8. Termination.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You may not propagate or modify a covered work except as expressly&lt;br/&gt;
provided under this License.&amp;nbsp;&amp;nbsp;Any attempt otherwise to propagate or&lt;br/&gt;
modify it is void, and will automatically terminate your rights under&lt;br/&gt;
this License (including any patent licenses granted under the third&lt;br/&gt;
paragraph of section 11).&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;However, if you cease all violation of this License, then your&lt;br/&gt;
license from a particular copyright holder is reinstated (a)&lt;br/&gt;
provisionally, unless and until the copyright holder explicitly and&lt;br/&gt;
finally terminates your license, and (b) permanently, if the copyright&lt;br/&gt;
holder fails to notify you of the violation by some reasonable means&lt;br/&gt;
prior to 60 days after the cessation.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Moreover, your license from a particular copyright holder is&lt;br/&gt;
reinstated permanently if the copyright holder notifies you of the&lt;br/&gt;
violation by some reasonable means, this is the first time you have&lt;br/&gt;
received notice of violation of this License (for any work) from that&lt;br/&gt;
copyright holder, and you cure the violation prior to 30 days after&lt;br/&gt;
your receipt of the notice.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Termination of your rights under this section does not terminate the&lt;br/&gt;
licenses of parties who have received copies or rights from you under&lt;br/&gt;
this License.&amp;nbsp;&amp;nbsp;If your rights have been terminated and not permanently&lt;br/&gt;
reinstated, you do not qualify to receive new licenses for the same&lt;br/&gt;
material under section 10.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;9. Acceptance Not Required for Having Copies.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You are not required to accept this License in order to receive or&lt;br/&gt;
run a copy of the Program.&amp;nbsp;&amp;nbsp;Ancillary propagation of a covered work&lt;br/&gt;
occurring solely as a consequence of using peer-to-peer transmission&lt;br/&gt;
to receive a copy likewise does not require acceptance.&amp;nbsp;&amp;nbsp;However,&lt;br/&gt;
nothing other than this License grants you permission to propagate or&lt;br/&gt;
modify any covered work.&amp;nbsp;&amp;nbsp;These actions infringe copyright if you do&lt;br/&gt;
not accept this License.&amp;nbsp;&amp;nbsp;Therefore, by modifying or propagating a&lt;br/&gt;
covered work, you indicate your acceptance of this License to do so.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;10. Automatic Licensing of Downstream Recipients.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Each time you convey a covered work, the recipient automatically&lt;br/&gt;
receives a license from the original licensors, to run, modify and&lt;br/&gt;
propagate that work, subject to this License.&amp;nbsp;&amp;nbsp;You are not responsible&lt;br/&gt;
for enforcing compliance by third parties with this License.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;An "entity transaction" is a transaction transferring control of an&lt;br/&gt;
organization, or substantially all assets of one, or subdividing an&lt;br/&gt;
organization, or merging organizations.&amp;nbsp;&amp;nbsp;If propagation of a covered&lt;br/&gt;
work results from an entity transaction, each party to that&lt;br/&gt;
transaction who receives a copy of the work also receives whatever&lt;br/&gt;
licenses to the work the party's predecessor in interest had or could&lt;br/&gt;
give under the previous paragraph, plus a right to possession of the&lt;br/&gt;
Corresponding Source of the work from the predecessor in interest, if&lt;br/&gt;
the predecessor has it or can get it with reasonable efforts.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You may not impose any further restrictions on the exercise of the&lt;br/&gt;
rights granted or affirmed under this License.&amp;nbsp;&amp;nbsp;For example, you may&lt;br/&gt;
not impose a license fee, royalty, or other charge for exercise of&lt;br/&gt;
rights granted under this License, and you may not initiate litigation&lt;br/&gt;
(including a cross-claim or counterclaim in a lawsuit) alleging that&lt;br/&gt;
any patent claim is infringed by making, using, selling, offering for&lt;br/&gt;
sale, or importing the Program or any portion of it.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;11. Patents.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;A "contributor" is a copyright holder who authorizes use under this&lt;br/&gt;
License of the Program or a work on which the Program is based.&amp;nbsp;&amp;nbsp;The&lt;br/&gt;
work thus licensed is called the contributor's "contributor version".&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;A contributor's "essential patent claims" are all patent claims&lt;br/&gt;
owned or controlled by the contributor, whether already acquired or&lt;br/&gt;
hereafter acquired, that would be infringed by some manner, permitted&lt;br/&gt;
by this License, of making, using, or selling its contributor version,&lt;br/&gt;
but do not include claims that would be infringed only as a&lt;br/&gt;
consequence of further modification of the contributor version.&amp;nbsp;&amp;nbsp;For&lt;br/&gt;
purposes of this definition, "control" includes the right to grant&lt;br/&gt;
patent sublicenses in a manner consistent with the requirements of&lt;br/&gt;
this License.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Each contributor grants you a non-exclusive, worldwide, royalty-free&lt;br/&gt;
patent license under the contributor's essential patent claims, to&lt;br/&gt;
make, use, sell, offer for sale, import and otherwise run, modify and&lt;br/&gt;
propagate the contents of its contributor version.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;In the following three paragraphs, a "patent license" is any express&lt;br/&gt;
agreement or commitment, however denominated, not to enforce a patent&lt;br/&gt;
(such as an express permission to practice a patent or covenant not to&lt;br/&gt;
sue for patent infringement).&amp;nbsp;&amp;nbsp;To "grant" such a patent license to a&lt;br/&gt;
party means to make such an agreement or commitment not to enforce a&lt;br/&gt;
patent against the party.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If you convey a covered work, knowingly relying on a patent license,&lt;br/&gt;
and the Corresponding Source of the work is not available for anyone&lt;br/&gt;
to copy, free of charge and under the terms of this License, through a&lt;br/&gt;
publicly available network server or other readily accessible means,&lt;br/&gt;
then you must either (1) cause the Corresponding Source to be so&lt;br/&gt;
available, or (2) arrange to deprive yourself of the benefit of the&lt;br/&gt;
patent license for this particular work, or (3) arrange, in a manner&lt;br/&gt;
consistent with the requirements of this License, to extend the patent&lt;br/&gt;
license to downstream recipients.&amp;nbsp;&amp;nbsp;"Knowingly relying" means you have&lt;br/&gt;
actual knowledge that, but for the patent license, your conveying the&lt;br/&gt;
covered work in a country, or your recipient's use of the covered work&lt;br/&gt;
in a country, would infringe one or more identifiable patents in that&lt;br/&gt;
country that you have reason to believe are valid.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If, pursuant to or in connection with a single transaction or&lt;br/&gt;
arrangement, you convey, or propagate by procuring conveyance of, a&lt;br/&gt;
covered work, and grant a patent license to some of the parties&lt;br/&gt;
receiving the covered work authorizing them to use, propagate, modify&lt;br/&gt;
or convey a specific copy of the covered work, then the patent license&lt;br/&gt;
you grant is automatically extended to all recipients of the covered&lt;br/&gt;
work and works based on it.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;A patent license is "discriminatory" if it does not include within&lt;br/&gt;
the scope of its coverage, prohibits the exercise of, or is&lt;br/&gt;
conditioned on the non-exercise of one or more of the rights that are&lt;br/&gt;
specifically granted under this License.&amp;nbsp;&amp;nbsp;You may not convey a covered&lt;br/&gt;
work if you are a party to an arrangement with a third party that is&lt;br/&gt;
in the business of distributing software, under which you make payment&lt;br/&gt;
to the third party based on the extent of your activity of conveying&lt;br/&gt;
the work, and under which the third party grants, to any of the&lt;br/&gt;
parties who would receive the covered work from you, a discriminatory&lt;br/&gt;
patent license (a) in connection with copies of the covered work&lt;br/&gt;
conveyed by you (or copies made from those copies), or (b) primarily&lt;br/&gt;
for and in connection with specific products or compilations that&lt;br/&gt;
contain the covered work, unless you entered into that arrangement,&lt;br/&gt;
or that patent license was granted, prior to 28 March 2007.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Nothing in this License shall be construed as excluding or limiting&lt;br/&gt;
any implied license or other defenses to infringement that may&lt;br/&gt;
otherwise be available to you under applicable patent law.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;12. No Surrender of Others' Freedom.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If conditions are imposed on you (whether by court order, agreement or&lt;br/&gt;
otherwise) that contradict the conditions of this License, they do not&lt;br/&gt;
excuse you from the conditions of this License.&amp;nbsp;&amp;nbsp;If you cannot convey a&lt;br/&gt;
covered work so as to satisfy simultaneously your obligations under this&lt;br/&gt;
License and any other pertinent obligations, then as a consequence you may&lt;br/&gt;
not convey it at all.&amp;nbsp;&amp;nbsp;For example, if you agree to terms that obligate you&lt;br/&gt;
to collect a royalty for further conveying from those to whom you convey&lt;br/&gt;
the Program, the only way you could satisfy both those terms and this&lt;br/&gt;
License would be to refrain entirely from conveying the Program.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;13. Use with the GNU Affero General Public License.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Notwithstanding any other provision of this License, you have&lt;br/&gt;
permission to link or combine any covered work with a work licensed&lt;br/&gt;
under version 3 of the GNU Affero General Public License into a single&lt;br/&gt;
combined work, and to convey the resulting work.&amp;nbsp;&amp;nbsp;The terms of this&lt;br/&gt;
License will continue to apply to the part which is the covered work,&lt;br/&gt;
but the special requirements of the GNU Affero General Public License,&lt;br/&gt;
section 13, concerning interaction through a network will apply to the&lt;br/&gt;
combination as such.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;14. Revised Versions of this License.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The Free Software Foundation may publish revised and/or new versions of&lt;br/&gt;
the GNU General Public License from time to time.&amp;nbsp;&amp;nbsp;Such new versions will&lt;br/&gt;
be similar in spirit to the present version, but may differ in detail to&lt;br/&gt;
address new problems or concerns.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Each version is given a distinguishing version number.&amp;nbsp;&amp;nbsp;If the&lt;br/&gt;
Program specifies that a certain numbered version of the GNU General&lt;br/&gt;
Public License "or any later version" applies to it, you have the&lt;br/&gt;
option of following the terms and conditions either of that numbered&lt;br/&gt;
version or of any later version published by the Free Software&lt;br/&gt;
Foundation.&amp;nbsp;&amp;nbsp;If the Program does not specify a version number of the&lt;br/&gt;
GNU General Public License, you may choose any version ever published&lt;br/&gt;
by the Free Software Foundation.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If the Program specifies that a proxy can decide which future&lt;br/&gt;
versions of the GNU General Public License can be used, that proxy's&lt;br/&gt;
public statement of acceptance of a version permanently authorizes you&lt;br/&gt;
to choose that version for the Program.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Later license versions may give you additional or different&lt;br/&gt;
permissions.&amp;nbsp;&amp;nbsp;However, no additional obligations are imposed on any&lt;br/&gt;
author or copyright holder as a result of your choosing to follow a&lt;br/&gt;
later version.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;15. Disclaimer of Warranty.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY&lt;br/&gt;
APPLICABLE LAW.&amp;nbsp;&amp;nbsp;EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT&lt;br/&gt;
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY&lt;br/&gt;
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,&lt;br/&gt;
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR&lt;br/&gt;
PURPOSE.&amp;nbsp;&amp;nbsp;THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM&lt;br/&gt;
IS WITH YOU.&amp;nbsp;&amp;nbsp;SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF&lt;br/&gt;
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;16. Limitation of Liability.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING&lt;br/&gt;
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS&lt;br/&gt;
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY&lt;br/&gt;
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE&lt;br/&gt;
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF&lt;br/&gt;
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD&lt;br/&gt;
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),&lt;br/&gt;
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF&lt;br/&gt;
SUCH DAMAGES.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;17. Interpretation of Sections 15 and 16.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If the disclaimer of warranty and limitation of liability provided&lt;br/&gt;
above cannot be given local legal effect according to their terms,&lt;br/&gt;
reviewing courts shall apply local law that most closely approximates&lt;br/&gt;
an absolute waiver of all civil liability in connection with the&lt;br/&gt;
Program, unless a warranty or assumption of liability accompanies a&lt;br/&gt;
copy of the Program in return for a fee.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; END OF TERMS AND CONDITIONS&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;How to Apply These Terms to Your New Programs&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If you develop a new program, and you want it to be of the greatest&lt;br/&gt;
possible use to the public, the best way to achieve this is to make it&lt;br/&gt;
free software which everyone can redistribute and change under these terms.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;To do so, attach the following notices to the program.&amp;nbsp;&amp;nbsp;It is safest&lt;br/&gt;
to attach them to the start of each source file to most effectively&lt;br/&gt;
state the exclusion of warranty; and each file should have at least&lt;br/&gt;
the "copyright" line and a pointer to where the full notice is found.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;one line to give the program's name and a brief idea of what it does.&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Copyright (C) &amp;lt;year&amp;gt;&amp;nbsp;&amp;nbsp;&amp;lt;name of author&amp;gt;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;This program is free software: you can redistribute it and/or modify&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;it under the terms of the GNU General Public License as published by&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;the Free Software Foundation, either version 3 of the License, or&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(at your option) any later version.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;This program is distributed in the hope that it will be useful,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&amp;nbsp;&amp;nbsp;See the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GNU General Public License for more details.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;You should have received a copy of the GNU General Public License&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;along with this program.&amp;nbsp;&amp;nbsp;If not, see &amp;lt;http://www.gnu.org/licenses/&amp;gt;.&lt;br/&gt;
&lt;br/&gt;
Also add information on how to contact you by electronic and paper mail.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;If the program does terminal interaction, make it output a short&lt;br/&gt;
notice like this when it starts in an interactive mode:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;program&amp;gt;&amp;nbsp;&amp;nbsp;Copyright (C) &amp;lt;year&amp;gt;&amp;nbsp;&amp;nbsp;&amp;lt;name of author&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;This is free software, and you are welcome to redistribute it&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;under certain conditions; type `show c' for details.&lt;br/&gt;
&lt;br/&gt;
The hypothetical commands `show w' and `show c' should show the appropriate&lt;br/&gt;
parts of the General Public License.&amp;nbsp;&amp;nbsp;Of course, your program's commands&lt;br/&gt;
might be different; for a GUI interface, you would use an "about box".&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;You should also get your employer (if you work as a programmer) or school,&lt;br/&gt;
if any, to sign a "copyright disclaimer" for the program, if necessary.&lt;br/&gt;
For more information on this, and how to apply and follow the GNU GPL, see&lt;br/&gt;
&amp;lt;http://www.gnu.org/licenses/&amp;gt;.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;The GNU General Public License does not permit incorporating your program&lt;br/&gt;
into proprietary programs.&amp;nbsp;&amp;nbsp;If your program is a subroutine library, you&lt;br/&gt;
may consider it more useful to permit linking proprietary applications with&lt;br/&gt;
the library.&amp;nbsp;&amp;nbsp;If this is what you want to do, use the GNU Lesser General&lt;br/&gt;
Public License instead of this License.&amp;nbsp;&amp;nbsp;But first, please read&lt;br/&gt;
&amp;lt;http://www.gnu.org/philosophy/why-not-lgpl.html&amp;gt;.&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardkalmanfilter.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardkalmanfilter.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "standardkalmanfilter.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::StandardKalmanFilter::StandardKalmanFilter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterCalculationElements&amp;gt;&amp;amp; calculation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilter{},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_covariance_estimate{boost::dynamic_pointer_cast&amp;lt;const StandardKalmanFilterParameters&amp;gt;(parameters)-&amp;gt;GetInitialCovarianceEstimate()},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_last_standard_calculation{boost::dynamic_pointer_cast&amp;lt;StandardKalmanFilterCalculationElements&amp;gt;(calculation)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_parameters{boost::dynamic_pointer_cast&amp;lt;const StandardKalmanFilterParameters&amp;gt;(parameters)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_state_estimate{boost::dynamic_pointer_cast&amp;lt;const StandardKalmanFilterParameters&amp;gt;(parameters)-&amp;gt;GetInitialStateEstimate()}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_last_standard_calculation);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;GetType() == m_last_standard_calculation-&amp;gt;GetType());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;GetType() == parameters-&amp;gt;GetType());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;GetType() == m_standard_parameters-&amp;gt;GetType());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;GetType() == GetParameters()-&amp;gt;GetType()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; "Initialize each Kalman filter type with the right type of parameters");&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_covariance_estimate = m_standard_parameters-&amp;gt;GetInitialCovarianceEstimate();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_state_estimate = m_standard_parameters-&amp;gt;GetInitialStateEstimate();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Do not initialize the calculation yet&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_standard_calculation-&amp;gt;m_predicted_state = m_standard_parameters-&amp;gt;GetInitialStateEstimate();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_standard_calculation-&amp;gt;m_predicted_covariance = m_standard_parameters-&amp;gt;GetInitialCovarianceEstimate();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for correct dimensionality&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto sz = m_state_estimate.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetControl().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetControl().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetEstimatedMeasurementNoise().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetEstimatedMeasurementNoise().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetObservation().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetObservation().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_covariance_estimate.size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_covariance_estimate.size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetEstimatedProcessNoiseCovariance().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetEstimatedProcessNoiseCovariance().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetStateTransition().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetStateTransition().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_state_estimate.size() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
int ribi::kalman::StandardKalmanFilter::GetStateSize() const noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int sz = boost::numeric_cast&amp;lt;int&amp;gt;(m_state_estimate.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return sz;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::StandardKalmanFilter::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.0";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::StandardKalmanFilter::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-04-28: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt; ribi::kalman::StandardKalmanFilter::PredictState(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input) const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; state_prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(m_standard_parameters-&amp;gt;GetStateTransition(),m_state_estimate)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ Matrix::Prod(m_standard_parameters-&amp;gt;GetControl(),input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return state_prediction;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; ribi::kalman::StandardKalmanFilter::PredictCovariance() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; covariance_prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::MultiProd(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_standard_parameters-&amp;gt;GetStateTransition(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;trans(m_standard_parameters-&amp;gt;GetStateTransition())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ m_standard_parameters-&amp;gt;GetEstimatedProcessNoiseCovariance();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return covariance_prediction;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardKalmanFilter::SupplyMeasurementAndInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurements,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::identity_matrix;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::matrix;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::trans;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;using boost::numeric::ublas::vector;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Debug statements to keep code below clean&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(measurements.size() == input.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_standard_parameters-&amp;gt;GetStateTransition().size2() == m_covariance_estimate.size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(Matrix::Prod(m_standard_parameters-&amp;gt;GetStateTransition(),m_covariance_estimate).size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;==&amp;nbsp;&amp;nbsp;trans(m_standard_parameters-&amp;gt;GetStateTransition()).size1() );&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(matrix&amp;lt;double&amp;gt;(Matrix::Prod(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;matrix&amp;lt;double&amp;gt;(Matrix::Prod(m_standard_parameters-&amp;gt;GetStateTransition(),m_covariance_estimate)),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;trans(m_standard_parameters-&amp;gt;GetStateTransition()))).size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;== m_standard_parameters-&amp;gt;GetEstimatedProcessNoiseCovariance().size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(matrix&amp;lt;double&amp;gt;(Matrix::Prod(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;matrix&amp;lt;double&amp;gt;(Matrix::Prod(m_standard_parameters-&amp;gt;GetStateTransition(),m_covariance_estimate)),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;trans(m_standard_parameters-&amp;gt;GetStateTransition()))).size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;== m_standard_parameters-&amp;gt;GetEstimatedProcessNoiseCovariance().size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Store calculation for KalmanFilterExperiment&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;Clear();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//assert(!m_last_standard_calculation-&amp;gt;IsComplete()); //Can be empty and thus complete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetPreviousStateEstimate(this-&amp;gt;GetStateEstimate()); //1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_last_standard_calculation-&amp;gt;IsComplete() || input.empty()); //Can be empty or incomplete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetPreviousCovarianceEstimate(this-&amp;gt;GetEstimationErrorCovariance()); //2&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// 1/7) State prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const vector&amp;lt;double&amp;gt; state_prediction = PredictState(input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// 2/7) Covariance prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const matrix&amp;lt;double&amp;gt; covariance_prediction = PredictCovariance();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// 3/7) Innovation (y with a squiggle above it)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const vector&amp;lt;double&amp;gt; innovation = measurements - Matrix::Prod(m_standard_parameters-&amp;gt;GetObservation(),state_prediction);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// 4/7) Innovation covariance (S)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const matrix&amp;lt;double&amp;gt; innovation_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::MultiProd(m_standard_parameters-&amp;gt;GetObservation(),covariance_prediction,trans(m_standard_parameters-&amp;gt;GetObservation()))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ m_standard_parameters-&amp;gt;GetEstimatedMeasurementNoise();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// 5/7) Kalman gain (K)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (Matrix::CalcDeterminant(innovation_covariance) == 0.0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::runtime_error("Innovation covariance became degenerate");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const matrix&amp;lt;double&amp;gt; kalman_gain&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::MultiProd(covariance_prediction,trans(m_standard_parameters-&amp;gt;GetObservation()),Matrix::Inverse(innovation_covariance));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// 6/7) Update state prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_state_estimate = state_prediction + Matrix::Prod(kalman_gain,innovation);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// 7/7) Update covariance prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const identity_matrix&amp;lt;double&amp;gt; my_identity_matrix(kalman_gain.size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_covariance_estimate = Matrix::Prod(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;my_identity_matrix&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- Matrix::Prod(kalman_gain,m_standard_parameters-&amp;gt;GetObservation()),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;covariance_prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Store calculation for KalmanFilterExperiment&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetPredictedState(state_prediction); //1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetPredictedCovariance(covariance_prediction); //2&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetInnovation(innovation); //3&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetMeasurement(measurements); //3&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetInnovationCovariance(innovation_covariance); //4&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetKalmanGain(kalman_gain); //5&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetUpdatedState(m_state_estimate); //6&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_standard_calculation-&amp;gt;SetUpdatedCovariance(m_covariance_estimate); //7&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_last_standard_calculation-&amp;gt;IsComplete());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardkalmanfilter.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardkalmanfilter.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STANDARDKALMANFILTER_H&lt;br/&gt;
#define STANDARDKALMANFILTER_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilter.h"&lt;br/&gt;
#include "standardkalmanfilterparameters.h"&lt;br/&gt;
#include "standardkalmanfiltercalculationelements.h"&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///A discrete time Kalman filter&lt;br/&gt;
struct StandardKalmanFilter : public KalmanFilter&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the estimation error covariance ('P'), which is updated during SupplyMeasurementAndInput&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetEstimationErrorCovariance() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_covariance_estimate; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Get the Kalman filter last calculation elements&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; GetLastCalculation() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{ return m_last_standard_calculation; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the (downcasted) calculation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterCalculationElements&amp;gt; GetLastStandardCalculation() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_last_standard_calculation; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt; GetParameters() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{ return m_standard_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The downcasted parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; GetStandardParameters() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_standard_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the number of values a state consists of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int GetStateSize() const noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the current prediction of the state ('x')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetStateEstimate() const noexcept { return m_state_estimate; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const noexcept { return KalmanFilterType::standard; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Give the filter a measurement and input, and it will update its predictions&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Also logs the calculation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SupplyMeasurementAndInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurements,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Let the filter estimate the next state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; PredictState(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input) const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Let the filter estimate the next estimation error covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; PredictCovariance() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Initialize the filter with a first measurent&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit StandardKalmanFilter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterCalculationElements&amp;gt;&amp;amp; calculation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend class StandardKalmanFilterFactory;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~StandardKalmanFilter() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(StandardKalmanFilter*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///P: The estimation error covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_covariance_estimate;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The downcasted parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterCalculationElements&amp;gt; m_last_standard_calculation;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The Kalman filter parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt; m_parameters;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The downcasted parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardKalmanFilterParameters&amp;gt; m_standard_parameters;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///x: The (current prediction of the) state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_state_estimate;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STANDARDKALMANFILTER_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardkalmanfiltercalculationelements.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardkalmanfiltercalculationelements.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "standardkalmanfiltercalculationelements.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::StandardKalmanFilterCalculationElements::StandardKalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Base&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//This class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; innovation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; innovation_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; kalman_gain,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; predicted_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; previous_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; updated_covariance)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;measurement,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;predicted_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;previous_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;updated_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_innovation{innovation},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_innovation_covariance{innovation_covariance},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_kalman_gain{kalman_gain},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_predicted_covariance{predicted_covariance},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_previous_covariance_estimate{previous_covariance_estimate},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_updated_covariance{updated_covariance}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//size may be zero&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = m_innovation.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Base&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == GetMeasurement().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == GetPredictedState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == GetPreviousState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == GetUpdatedState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//This class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_innovation.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_innovation_covariance.size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_innovation_covariance.size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_kalman_gain.size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_kalman_gain.size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_predicted_covariance.size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_predicted_covariance.size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_previous_covariance_estimate.size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_previous_covariance_estimate.size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_updated_covariance.size1());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(sz == m_updated_covariance.size2());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardKalmanFilterCalculationElements::Clear()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterCalculationElements::Clear();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_innovation = boost::numeric::ublas::vector&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_innovation.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_innovation_covariance = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_kalman_gain = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_predicted_covariance = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_previous_covariance_estimate = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_updated_covariance = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::KalmanFilterCalculationElements&amp;gt; ribi::kalman::StandardKalmanFilterCalculationElements::Clone() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; p(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Base&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetMeasurement(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetPredictedState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetPreviousState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetUpdatedState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Derived class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetInnovation(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetInnovationCovariance(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetKalmanGain(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetPredicatedCovariance(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetPreviousCovarianceEstimate(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetUpdatedCovariance()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p-&amp;gt;GetType() == this-&amp;gt;GetType());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return p;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::StandardKalmanFilterCalculationElements::IsComplete() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = m_innovation.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //sz != 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sz == m_innovation.size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_innovation_covariance.size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_innovation_covariance.size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_innovation_covariance.size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_innovation_covariance.size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_kalman_gain.size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_kalman_gain.size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetMeasurement().size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_predicted_covariance.size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_predicted_covariance.size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetPredictedState().size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_previous_covariance_estimate.size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_previous_covariance_estimate.size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetPreviousState().size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_updated_covariance.size1()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == m_updated_covariance.size2()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetUpdatedState().size();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardKalmanFilterCalculationElements::SetInnovation(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; innovation)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_innovation.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_innovation = innovation;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardKalmanFilterCalculationElements::SetInnovationCovariance(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; innovation_covariance)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_innovation_covariance.size1() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_innovation_covariance.size2() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_innovation_covariance = innovation_covariance;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardKalmanFilterCalculationElements::SetKalmanGain(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; kalman_gain)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_kalman_gain.size1() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_kalman_gain.size2() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_kalman_gain = kalman_gain;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardKalmanFilterCalculationElements::SetPredictedCovariance(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; predicted_covariance)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_predicted_covariance.size1() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_predicted_covariance.size2() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_predicted_covariance = predicted_covariance;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardKalmanFilterCalculationElements::SetPreviousCovarianceEstimate(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; previous_covariance_estimate)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_previous_covariance_estimate.size1() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_previous_covariance_estimate.size2() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_previous_covariance_estimate = previous_covariance_estimate;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardKalmanFilterCalculationElements::SetUpdatedCovariance(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; updated_covariance)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_updated_covariance.size1() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_updated_covariance.size2() == 0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_updated_covariance = updated_covariance;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardkalmanfiltercalculationelements.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardkalmanfiltercalculationelements.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STANDARDKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
#define STANDARDKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfiltertype.h"&lt;br/&gt;
#include "kalmanfiltercalculationelements.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///The elements of a standard Kalman filter calculation&lt;br/&gt;
struct StandardKalmanFilterCalculationElements : public KalmanFilterCalculationElements&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit StandardKalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Base&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//This class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; innovation = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; innovation_covariance = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; kalman_gain = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; predicted_covariance = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; previous_covariance_estimate = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; updated_covariance = boost::numeric::ublas::matrix&amp;lt;double&amp;gt;());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Clear the calculation, will set IsComplete to false&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void Clear();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Produce a deep copy of the derived class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; Clone() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the innovation ('y_squiggle')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetInnovation() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_innovation; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain he innovation covariance ('S')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetInnovationCovariance() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_innovation_covariance; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman gain ('K')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetKalmanGain() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_kalman_gain; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the predicted error estimation covariance ('P_predicted')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetPredicatedCovariance() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_predicted_covariance; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the previous_covariance_estimate ('P_prev'/'P_n-1')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetPreviousCovarianceEstimate() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_previous_covariance_estimate; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const { return KalmanFilterType::standard; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the updated error estimation covariance (in the end of each timestep)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetUpdatedCovariance() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_updated_covariance; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Checks if the state is complete and valid&lt;br/&gt;
&amp;nbsp;&amp;nbsp;bool IsComplete() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the innovation ('y_squiggle')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetInnovation(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; innovation);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the innovation covariance ('S')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetInnovationCovariance(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; innovation_covariance);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the Kalman gain ('K')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetKalmanGain(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; kalman_gain);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the predicted error estimation covariance ('P_predicted')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Calculated at step 2 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///2) P_predicted = [...] P_n-1 [...]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetPredictedCovariance(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; predicted_covariance);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the previous_covariance_estimate ('P_prev'/'P_n-1')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is read at step 2 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///2) P_predicted = [...] P_n-1 [...]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetPreviousCovarianceEstimate(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; previous_covariance_estimate);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the updated error estimation covariance (in the end of each timestep)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Calculated at step 7 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///2) P_n = [...] P_predicted&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Fails if already set&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetUpdatedCovariance(const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; updated_covariance);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~StandardKalmanFilterCalculationElements() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(StandardKalmanFilterCalculationElements*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The innovation ('y_squiggle')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_innovation;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The innovation covariance ('S')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_innovation_covariance;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The Kalman gain ('K')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_kalman_gain;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The predicted error estimation covariance ('P_predicted')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Calculated at step 2 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///2) P_predicted = [...] P_n-1 [...]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_predicted_covariance;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The previous_covariance_estimate ('P_prev'/'P_n-1')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is read at step 2 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///2) P_predicted = [...] P_n-1 [...]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_previous_covariance_estimate;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The updated error estimation covariance (in the end of each timestep)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Calculated at step 7 of the algorithm:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///2) P_n = [...] P_predicted&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_updated_covariance;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STANDARDKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardkalmanfilterfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardkalmanfilterfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "standardkalmanfilterfactory.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::StandardKalmanFilter&amp;gt; ribi::kalman::StandardKalmanFilterFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters-&amp;gt;GetType() == KalmanFilterType::standard);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilterCalculationElements&amp;gt; calculation{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilterCalculationElements&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(calculation);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardKalmanFilter&amp;gt; kalman_filter{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardKalmanFilter(calculation,parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(kalman_filter);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(kalman_filter-&amp;gt;GetType() == KalmanFilterType::standard);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return kalman_filter;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardkalmanfilterfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardkalmanfilterfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STANDARDKALMANFILTERFACTORY_H&lt;br/&gt;
#define STANDARDKALMANFILTERFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "standardkalmanfilter.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Factory for StandardKalmanFilter&lt;br/&gt;
struct StandardKalmanFilterFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;StandardKalmanFilter&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STANDARDKALMANFILTERFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardkalmanfilterparameters.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardkalmanfilterparameters.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "standardkalmanfilterparameters.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::StandardKalmanFilterParameters::StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilterParameters{control,initial_state_estimate,observation,state_transition},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_estimated_measurement_noise{estimated_measurement_noise},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_estimated_process_noise_covariance{estimated_process_noise_covariance},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_initial_covariance_estimate{initial_covariance_estimate}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for correct dimensionality&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = GetInitialStateEstimate().size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//assert(sz &amp;gt;= 0); //Inevitable for std::size_t&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetEstimatedMeasurementNoise().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetEstimatedMeasurementNoise().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetEstimatedProcessNoiseCovariance().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetEstimatedProcessNoiseCovariance().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetInitialCovarianceEstimate().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetInitialCovarianceEstimate().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::StandardKalmanFilterParameters::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.1";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::StandardKalmanFilterParameters::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-04-28: version 1.0: initial version",&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-03: version 1.1: inhertic from KalmanFilterParameters"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::StandardKalmanFilterParameters::HasParameterType(const KalmanFilterParameterType type) noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; type == KalmanFilterParameterType::control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::estimated_measurement_noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::estimated_process_noise_covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::initial_covariance_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::state_transition;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::StandardKalmanFilterParameters::IsAboutEqual(const StandardKalmanFilterParameters&amp;amp; lhs, const StandardKalmanFilterParameters&amp;amp; rhs) noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Matrix::MatricesAreAboutEqual(lhs.GetControl(),rhs.GetControl())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetEstimatedMeasurementNoise(),rhs.GetEstimatedMeasurementNoise())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetInitialCovarianceEstimate(),rhs.GetInitialCovarianceEstimate())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::VectorsAreAboutEqual(lhs.GetInitialStateEstimate(),rhs.GetInitialStateEstimate())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetObservation(),rhs.GetObservation())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetEstimatedProcessNoiseCovariance(),rhs.GetEstimatedProcessNoiseCovariance())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetStateTransition(),rhs.GetStateTransition());&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardkalmanfilterparameters.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardkalmanfilterparameters.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STANDARDKALMANFILTERPARAMETERS_H&lt;br/&gt;
#define STANDARDKALMANFILTERPARAMETERS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/checked_delete.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilterparameters.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Parameters for the standard Kalman filter&lt;br/&gt;
struct StandardKalmanFilterParameters : public KalmanFilterParameters&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit StandardKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; estimated_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; estimated_process_noise_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; initial_covariance_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the (estimated) measurement noise ('R')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetEstimatedMeasurementNoise() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_estimated_measurement_noise; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///P: The initial estimation error covariance estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetInitialCovarianceEstimate() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_initial_covariance_estimate; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the process noise covariance ('Q')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetEstimatedProcessNoiseCovariance() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_estimated_process_noise_covariance; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const noexcept { return KalmanFilterType::standard; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if two parameter sets are equal with a fuzzy compare&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsAboutEqual(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const StandardKalmanFilterParameters&amp;amp; lhs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const StandardKalmanFilterParameters&amp;amp; rhs) noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if this parameter set has a certain type of KalmanFilterParameter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool HasParameterType(const KalmanFilterParameterType type) noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~StandardKalmanFilterParameters() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(StandardKalmanFilterParameters*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///R: Estimated measurement noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_estimated_measurement_noise;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Q: The estimated process noise covariance&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_estimated_process_noise_covariance;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///P: The initial estimation error covariance estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_initial_covariance_estimate;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STANDARDKALMANFILTERPARAMETERS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardwhitenoisesystem.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardwhitenoisesystem.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "standardwhitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;iostream&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/io.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/random/lagged_fibonacci.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/random/normal_distribution.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::StandardWhiteNoiseSystem::StandardWhiteNoiseSystem(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: WhiteNoiseSystem{parameters},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_parameters{boost::dynamic_pointer_cast&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt;(parameters)}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::StandardWhiteNoiseSystem::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.0";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::StandardWhiteNoiseSystem::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-04-28: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardWhiteNoiseSystem::GoToNextState()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Create a no-input vector&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto sz = GetCurrentState().size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; input(sz,0.0);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return GoToNextState(input);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::StandardWhiteNoiseSystem::GoToNextState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//First do a perfect transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(input.size() == GetCurrentState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetStateTransition().size1() == GetCurrentState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetStateTransition().size2() == GetCurrentState().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetControl().size1() == input.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetControl().size2() == input.size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; new_state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(m_parameters-&amp;gt;GetStateTransition(),GetCurrentState())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ Matrix::Prod(m_parameters-&amp;gt;GetControl(),input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Add process noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto sz = new_state.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(new_state.size() == m_parameters-&amp;gt;GetProcessNoise().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (std::size_t i = 0; i!=sz; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new_state(i) = GetRandomNormal(new_state(i),m_parameters-&amp;gt;GetProcessNoise()(i));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;SetNewCurrentState(new_state);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt; ribi::kalman::StandardWhiteNoiseSystem::Measure() const noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto sz = GetCurrentState().size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetCurrentState().size() == m_parameters-&amp;gt;GetMeasurementNoise().size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; measured(sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (std::size_t i = 0; i!=sz; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;measured(i) = GetRandomNormal(GetCurrentState()(i),m_parameters-&amp;gt;GetMeasurementNoise()(i));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return measured;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardwhitenoisesystem.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardwhitenoisesystem.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STANDARDWHITENOISESYSTEM_H&lt;br/&gt;
#define STANDARDWHITENOISESYSTEM_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
#include "whitenoisesystem.h"&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct StandardWhiteNoiseSystem : public WhiteNoiseSystem&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::standard; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///without any input&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void GoToNextState();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void GoToNextState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Measure a value from this system with normally distributed noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; Measure() const noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///StandardWhiteNoiseSystem can only be created by a StandardWhiteNoiseSystemFactory&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit StandardWhiteNoiseSystem(const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend class StandardWhiteNoiseSystemFactory;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~StandardWhiteNoiseSystem() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(StandardWhiteNoiseSystem*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The parameters for the white noise system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const StandardWhiteNoiseSystemParameters&amp;gt; m_parameters;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STANDARDWHITENOISESYSTEM_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardwhitenoisesystemfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardwhitenoisesystemfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "standardwhitenoisesystemfactory.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::StandardWhiteNoiseSystem&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::StandardWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::shared_ptr&amp;lt;const ribi::kalman::StandardWhiteNoiseSystemParameters&amp;gt; parameters{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardWhiteNoiseSystem&amp;gt; system{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new StandardWhiteNoiseSystem(parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(system);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return system;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::StandardWhiteNoiseSystem&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;ribi::kalman::StandardWhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters-&amp;gt;GetType() == WhiteNoiseSystemType::standard);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardWhiteNoiseSystemParameters&amp;gt; standard_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= boost::dynamic_pointer_cast&amp;lt;StandardWhiteNoiseSystemParameters&amp;gt;(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(standard_parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;StandardWhiteNoiseSystem&amp;gt; system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetControl(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetInitialState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetMeasurementNoise(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetProcessNoise(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;standard_parameters-&amp;gt;GetStateTransition());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(system);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return system;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardwhitenoisesystemfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardwhitenoisesystemfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STANDARDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
#define STANDARDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "standardwhitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct StandardWhiteNoiseSystemFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;StandardWhiteNoiseSystem&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;StandardWhiteNoiseSystem&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STANDARDWHITENOISESYSTEMFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardwhitenoisesystemparameters.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardwhitenoisesystemparameters.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "standardwhitenoisesystemparameters.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::StandardWhiteNoiseSystemParameters::StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: WhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state_transition)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::StandardWhiteNoiseSystemParameters::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.0";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::StandardWhiteNoiseSystemParameters::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-04-28: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::StandardWhiteNoiseSystemParameters::IsAboutEqual(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const StandardWhiteNoiseSystemParameters&amp;amp; lhs, const StandardWhiteNoiseSystemParameters&amp;amp; rhs) noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Matrix::MatricesAreAboutEqual(lhs.GetControl(),rhs.GetControl())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::VectorsAreAboutEqual(lhs.GetInitialState(),rhs.GetInitialState())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::VectorsAreAboutEqual(lhs.GetMeasurementNoise(),rhs.GetMeasurementNoise())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::VectorsAreAboutEqual(lhs.GetProcessNoise(),rhs.GetProcessNoise())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetStateTransition(),rhs.GetStateTransition());&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/standardwhitenoisesystemparameters.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/standardwhitenoisesystemparameters.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STANDARDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
#define STANDARDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/checked_delete.hpp&amp;gt;&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct StandardWhiteNoiseSystemParameters : public WhiteNoiseSystemParameters&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit StandardWhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType GetType() const noexcept { return WhiteNoiseSystemType::standard; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check two parameter sets for equality using a fuzzy comparison&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsAboutEqual(const StandardWhiteNoiseSystemParameters&amp;amp; lhs, const StandardWhiteNoiseSystemParameters&amp;amp; rhs) noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~StandardWhiteNoiseSystemParameters() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(StandardWhiteNoiseSystemParameters*);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STANDARDWHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/steadystatekalmanfilter.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/steadystatekalmanfilter.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "steadystatekalmanfilter.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
#include "kalmanfilter.h"&lt;br/&gt;
#include "kalmanfilterparameters.h"&lt;br/&gt;
#include "steadystatekalmanfilterparameters.h"&lt;br/&gt;
#include "trace.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::SteadyStateKalmanFilter::SteadyStateKalmanFilter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt;&amp;amp; calculation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilter{},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_last_calculation{boost::dynamic_pointer_cast&amp;lt;SteadyStateKalmanFilterCalculationElements&amp;gt;(calculation)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_parameters{boost::dynamic_pointer_cast&amp;lt;const SteadyStateKalmanFilterParameters&amp;gt;(parameters)},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_state_estimate{dynamic_cast&amp;lt;const SteadyStateKalmanFilterParameters*&amp;gt;(parameters.get())-&amp;gt;GetInitialStateEstimate()}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_last_calculation);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; "Initialize each Kalman filter type with the right type of parameters");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for correct dimensionality&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const auto sz = m_state_estimate.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetControl().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetControl().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetEstimatedOptimalKalmanGain().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetEstimatedOptimalKalmanGain().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetObservation().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetObservation().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetStateTransition().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters-&amp;gt;GetStateTransition().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_state_estimate.size() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Initialize the last calculation with null values&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//NEW 2013-05-23&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_calculation-&amp;gt;SetMeasurement(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;&amp;nbsp;boost::numeric::ublas::zero_vector&amp;lt;double&amp;gt;(m_state_estimate.size()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_calculation-&amp;gt;SetPredictedState(m_parameters-&amp;gt;GetInitialStateEstimate());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_calculation-&amp;gt;SetPreviousStateEstimate(m_parameters-&amp;gt;GetInitialStateEstimate());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_calculation-&amp;gt;SetUpdatedState(m_parameters-&amp;gt;GetInitialStateEstimate());&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
int ribi::kalman::SteadyStateKalmanFilter::GetStateSize() const noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const int sz = boost::numeric_cast&amp;lt;int&amp;gt;(m_state_estimate.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return sz;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::SteadyStateKalmanFilter::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.1";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::SteadyStateKalmanFilter::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-01: version 1.0: initial version",&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-06: version 1.1: inherits from KalmanFilter"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::vector&amp;lt;double&amp;gt; ribi::kalman::SteadyStateKalmanFilter::PredictState(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input) const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; term_a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= m_parameters-&amp;gt;GetStateTransition()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- Matrix::Prod(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_parameters-&amp;gt;GetEstimatedOptimalKalmanGain(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_parameters-&amp;gt;GetObservation()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_measured must be set before calling PredictState!&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_last_calculation-&amp;gt;GetMeasurement().empty());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; state_prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(term_a,this-&amp;gt;GetStateEstimate())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ Matrix::Prod(m_parameters-&amp;gt;GetControl(),input)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ Matrix::Prod(m_parameters-&amp;gt;GetEstimatedOptimalKalmanGain(),m_last_calculation-&amp;gt;GetMeasurement());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return state_prediction;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::SteadyStateKalmanFilter::SupplyMeasurementAndInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurements,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(measurements.size() == input.size());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Store the calculation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_calculation-&amp;gt;Clear();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_last_calculation-&amp;gt;IsComplete());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_calculation-&amp;gt;SetPreviousStateEstimate(this-&amp;gt;GetStateEstimate());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//m_last_calculation-&amp;gt;SetMeasurement must be set before calling PredictState!&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_calculation-&amp;gt;SetMeasurement(measurements);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// 1/1) State prediction&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; state_prediction = PredictState(input);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_state_estimate = state_prediction;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Store the calculation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_calculation-&amp;gt;SetPredictedState(state_prediction);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_last_calculation-&amp;gt;SetUpdatedState(GetStateEstimate());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_last_calculation-&amp;gt;IsComplete());&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/steadystatekalmanfilter.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/steadystatekalmanfilter.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STEADYSTATEKALMANFILTER_H&lt;br/&gt;
#define STEADYSTATEKALMANFILTER_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilter.h"&lt;br/&gt;
#include "steadystatekalmanfilterparameters.h"&lt;br/&gt;
#include "steadystatekalmanfiltercalculationelements.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///A discrete time Kalman filter&lt;br/&gt;
struct SteadyStateKalmanFilter : public KalmanFilter&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;SteadyStateKalmanFilter(const SteadyStateKalmanFilter&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;SteadyStateKalmanFilter&amp;amp; operator=(const SteadyStateKalmanFilter&amp;amp;) = delete;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Clear the calculation, will set IsComplete to false&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//void Clear();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Get the Kalman filter last calculation elements&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; GetLastCalculation() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{ return m_last_calculation; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt; GetParameters() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{ return m_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the number of values a state consists of&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int GetStateSize() const noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the current prediction of the state ('x')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetStateEstimate() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp; { return m_state_estimate; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const noexcept { return KalmanFilterType::steady_state; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Give the filter a measurement and input, and it will update its predictions&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SupplyMeasurementAndInput(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurements,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Let the filter estimate the next state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; PredictState(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input) const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Initialize the filter with a first measurent&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit SteadyStateKalmanFilter(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt;&amp;amp; calculation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend class SteadyStateKalmanFilterFactory;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~SteadyStateKalmanFilter() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(SteadyStateKalmanFilter*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The last calculation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;SteadyStateKalmanFilterCalculationElements&amp;gt; m_last_calculation;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The downcasted parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const SteadyStateKalmanFilterParameters&amp;gt; m_parameters;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///x: The (current prediction of the) state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_state_estimate;&lt;br/&gt;
&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STEADYSTATEKALMANFILTER_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/steadystatekalmanfiltercalculationelements.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/steadystatekalmanfiltercalculationelements.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "steadystatekalmanfiltercalculationelements.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include "kalmanfiltercalculationelementsfactory.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::SteadyStateKalmanFilterCalculationElements::SteadyStateKalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state)&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;measurement,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;predicted_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;previous_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;updated_state)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//... nothing to check&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::KalmanFilterCalculationElements&amp;gt; ribi::kalman::SteadyStateKalmanFilterCalculationElements::Clone() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; p {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new SteadyStateKalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Base&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetMeasurement(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetPredictedState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetPreviousState(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this-&amp;gt;GetUpdatedState()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//Derived class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//... no additional data members&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p-&amp;gt;GetType() == this-&amp;gt;GetType());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return p;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::SteadyStateKalmanFilterCalculationElements::IsComplete() const&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = GetMeasurement().size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; sz != 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetMeasurement().size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetPreviousState().size()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; sz == GetUpdatedState().size();&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/steadystatekalmanfiltercalculationelements.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/steadystatekalmanfiltercalculationelements.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STEADYSTATEKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
#define STEADYSTATEKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "kalmanfiltercalculationelements.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///The elements of a steady-state Kalman filter calculation&lt;br/&gt;
struct SteadyStateKalmanFilterCalculationElements : public KalmanFilterCalculationElements&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit SteadyStateKalmanFilterCalculationElements(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; measurement = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; predicted_state = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; previous_state_estimate = boost::numeric::ublas::vector&amp;lt;double&amp;gt;(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; updated_state = boost::numeric::ublas::vector&amp;lt;double&amp;gt;());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Produce a deep copy of the derived class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; Clone() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const { return KalmanFilterType::steady_state; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Checks if the state is complete and valid&lt;br/&gt;
&amp;nbsp;&amp;nbsp;bool IsComplete() const;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~SteadyStateKalmanFilterCalculationElements() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(SteadyStateKalmanFilterCalculationElements*);&lt;br/&gt;
&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STEADYSTATEKALMANFILTERCALCULATIONELEMENTS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/steadystatekalmanfilterfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/steadystatekalmanfilterfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "steadystatekalmanfilterfactory.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include "kalmanfiltercalculationelementsfactory.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::SteadyStateKalmanFilter&amp;gt; ribi::kalman::SteadyStateKalmanFilterFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(parameters-&amp;gt;GetType() == KalmanFilterType::steady_state);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;KalmanFilterCalculationElements&amp;gt; calculation {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;KalmanFilterCalculationElementsFactory::Create(parameters-&amp;gt;GetType())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(calculation);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;SteadyStateKalmanFilter&amp;gt; kalman_filter {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new SteadyStateKalmanFilter(calculation,parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(kalman_filter);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(kalman_filter-&amp;gt;GetType() == KalmanFilterType::steady_state);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return kalman_filter;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/steadystatekalmanfilterfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/steadystatekalmanfilterfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STEADYSTATEKALMANFILTERFACTORY_H&lt;br/&gt;
#define STEADYSTATEKALMANFILTERFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "steadystatekalmanfilter.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Factory for SteadyStateKalmanFilter&lt;br/&gt;
struct SteadyStateKalmanFilterFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;SteadyStateKalmanFilter&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const KalmanFilterParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STEADYSTATEKALMANFILTERFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/steadystatekalmanfilterparameters.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/steadystatekalmanfilterparameters.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
&lt;br/&gt;
&lt;br/&gt;
#include "steadystatekalmanfilterparameters.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::SteadyStateKalmanFilterParameters::SteadyStateKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; estimated_optimal_kalman_gain,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: KalmanFilterParameters(control,initial_state_estimate,observation,state_transition),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_estimated_optimal_kalman_gain{estimated_optimal_kalman_gain}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for correct dimensionality&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = GetInitialStateEstimate().size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//assert(sz &amp;gt;= 0); //Inevitable for std::size_t&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetEstimatedOptimalKalmanGain().size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(GetEstimatedOptimalKalmanGain().size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; ribi::kalman::SteadyStateKalmanFilterParameters::CalculateOptimalKalmanGain(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; initial_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; a = state_transition;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; c = observation;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; p = initial_covariance;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; r = measurement_noise;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; term_a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::MultiProd(a,p,boost::numeric::ublas::trans(c));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (Matrix::CalcDeterminant(term_a + r) == 0.0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::runtime_error("Optimal Kalman gain matrix is degenerate");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; k&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;= Matrix::Prod(term_a,Matrix::Inverse(term_a + r));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return k;&lt;br/&gt;
&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::SteadyStateKalmanFilterParameters::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.1";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::SteadyStateKalmanFilterParameters::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-01: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-03: version 1.1: inherit from KalmanFilterParameters"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::SteadyStateKalmanFilterParameters::HasParameterType(const KalmanFilterParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; type == KalmanFilterParameterType::control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::estimated_optimal_kalman_gain&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::initial_state_estimate&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::observation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;|| type == KalmanFilterParameterType::state_transition;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::SteadyStateKalmanFilterParameters::IsAboutEqual(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const SteadyStateKalmanFilterParameters&amp;amp; lhs,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const SteadyStateKalmanFilterParameters&amp;amp; rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Matrix::MatricesAreAboutEqual(lhs.GetControl(),rhs.GetControl())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetEstimatedOptimalKalmanGain(),rhs.GetEstimatedOptimalKalmanGain())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::VectorsAreAboutEqual(lhs.GetInitialStateEstimate(),rhs.GetInitialStateEstimate())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetObservation(),rhs.GetObservation())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetStateTransition(),rhs.GetStateTransition());&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/steadystatekalmanfilterparameters.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/steadystatekalmanfilterparameters.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef STEADYSTATEKALMANFILTERPARAMETERS_H&lt;br/&gt;
#define STEADYSTATEKALMANFILTERPARAMETERS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/checked_delete.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "kalmanfilterparameters.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///Parameters for the standard Kalman filter&lt;br/&gt;
struct SteadyStateKalmanFilterParameters : public KalmanFilterParameters&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit SteadyStateKalmanFilterParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; estimated_optimal_kalman_gain,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state_estimate,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Calculate the optimal Kalman gain&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; CalculateOptimalKalmanGain(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; initial_covariance,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; observation,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the (estimated) optimal Kalman gain ('K')&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetEstimatedOptimalKalmanGain() const&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_estimated_optimal_kalman_gain; }&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the Kalman filter type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;KalmanFilterType GetType() const { return KalmanFilterType::steady_state; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if two parameter sets are equal with a fuzzy compare&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsAboutEqual(const SteadyStateKalmanFilterParameters&amp;amp; lhs, const SteadyStateKalmanFilterParameters&amp;amp; rhs);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check if this parameter set has a certain type of KalmanFilterParameter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool HasParameterType(const KalmanFilterParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Can only be deleted by boost::checked_delete&lt;br/&gt;
&amp;nbsp;&amp;nbsp;~SteadyStateKalmanFilterParameters() noexcept {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;friend void boost::checked_delete&amp;lt;&amp;gt;(SteadyStateKalmanFilterParameters*);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///K: Estimated optimal Kalman gain&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_estimated_optimal_kalman_gain;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // STEADYSTATEKALMANFILTERPARAMETERS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystem.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystem.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include "whitenoisesystem.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/random.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::WhiteNoiseSystem::WhiteNoiseSystem(const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: m_current_state{parameters-&amp;gt;GetInitialState()},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_parameters{parameters}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_parameters);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
double ribi::kalman::WhiteNoiseSystem::GetRandomNormal(const double mean, const double sigma) noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::normal_distribution&amp;lt;double&amp;gt; norm_dist(mean, sigma);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static boost::lagged_fibonacci19937 engine;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const double value = norm_dist.operator () &amp;lt;boost::lagged_fibonacci19937&amp;gt;((engine));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return value;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::WhiteNoiseSystem::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.0";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::WhiteNoiseSystem::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-05-03: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
void ribi::kalman::WhiteNoiseSystem::SetNewCurrentState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; new_current_state)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_current_state.size() == new_current_state.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m_current_state = new_current_state;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystem.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystem.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef WHITENOISESYSTEM_H&lt;br/&gt;
#define WHITENOISESYSTEM_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystemtype.h"&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct WhiteNoiseSystem&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystem(const WhiteNoiseSystem&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystem&amp;amp; operator=(const WhiteNoiseSystem&amp;amp;) = delete;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual ~WhiteNoiseSystem() noexcept {}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; GetParameters() const noexcept { return m_parameters; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual WhiteNoiseSystemType GetType() const noexcept = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Update reality, that is, let the real system (i.e. reality) go to its next state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual void GoToNextState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; input) = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Measure a value from this system with normally distributed noise&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual const boost::numeric::ublas::vector&amp;lt;double&amp;gt; Measure() const = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Peek what the real value is&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; PeekAtRealState() const noexcept { return m_current_state; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;protected:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///An ABC can only be constructed by derived classes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit WhiteNoiseSystem(const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain a random number from a normal distribution&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///From http://www.richelbilderbeek.nl/CppGetRandomNormal.htm&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static double GetRandomNormal(const double mean = 0.0, const double sigma = 1.0) noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The real state of the system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetCurrentState() const noexcept { return m_current_state; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Set the new current state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void SetNewCurrentState(const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; new_current_state);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The real state of the system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_current_state;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;const WhiteNoiseSystemParameters&amp;gt; m_parameters;&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // WHITENOISESYSTEM_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemfactory.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemfactory.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "whitenoisesystemfactory.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include "gapsfilledwhitenoisesystemfactory.h"&lt;br/&gt;
#include "laggedwhitenoisesystemfactory.h"&lt;br/&gt;
#include "standardwhitenoisesystemfactory.h"&lt;br/&gt;
&lt;br/&gt;
const boost::shared_ptr&amp;lt;ribi::kalman::WhiteNoiseSystem&amp;gt; ribi::kalman::WhiteNoiseSystemFactory::Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::shared_ptr&amp;lt;WhiteNoiseSystem&amp;gt; p;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (parameters-&amp;gt;GetType())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemType::gaps_filled:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p = GapsFilledWhiteNoiseSystemFactory::Create(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemType::lagged:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p = LaggedWhiteNoiseSystemFactory::Create(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemType::standard:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;p = StandardWhiteNoiseSystemFactory::Create(parameters);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemType::n_types:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented white noise system");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(p);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return p;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemfactory.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemfactory.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef WHITENOISESYSTEMFACTORY_H&lt;br/&gt;
#define WHITENOISESYSTEMFACTORY_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;&lt;br/&gt;
#include "whitenoisesystem.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct WhiteNoiseSystemFactory&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::shared_ptr&amp;lt;WhiteNoiseSystem&amp;gt; Create(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::shared_ptr&amp;lt;WhiteNoiseSystemParameters&amp;gt;&amp;amp; parameters);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // WHITENOISESYSTEMFACTORY_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemparameter.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemparameter.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "whitenoisesystemparameter.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include &amp;lt;stdexcept&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;ribi::kalman::WhiteNoiseSystemParameterType&amp;gt; ribi::kalman::WhiteNoiseSystemParameter::GetAll()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;WhiteNoiseSystemParameterType&amp;gt; v {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::initial_state_real,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::measurement_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameterType::state_transition,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(boost::numeric_cast&amp;lt;int&amp;gt;(v.size()) == static_cast&amp;lt;int&amp;gt;(WhiteNoiseSystemParameterType::n_parameters)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; "All parameters must be in");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::WhiteNoiseSystemParameter::IsMatrix(const WhiteNoiseSystemParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::control: return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::initial_state_real: return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::measurement_frequency: return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::real_measurement_noise: return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::real_process_noise: return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::state_transition: return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"n_parameters is not an implemented type of WhiteNoiseSystemParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::WhiteNoiseSystemParameter::IsVector(const WhiteNoiseSystemParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return !ribi::kalman::WhiteNoiseSystemParameter::IsMatrix(type);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::WhiteNoiseSystemParameter::ToDescription(const WhiteNoiseSystemParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::control:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix for converting input to state change");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::initial_state_real:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Vector with the real initial state");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::measurement_frequency:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Vector containing after which number of timesteps a measurement is taken");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::real_measurement_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Vector with the real standard deviations of the measurement noise per state");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::real_process_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Vector with the real standard deviations of the process noise per state");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::state_transition:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Matrix that contains the internal physics of the system; the effect of current state on the next state");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::WhiteNoiseSystemParameter::ToName(const WhiteNoiseSystemParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::control:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Control");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::initial_state_real:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Real initial state");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::measurement_frequency:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Measurement frequencies");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::real_measurement_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Real measurement noise");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::real_process_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Real process noise");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::state_transition:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("State transition");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::WhiteNoiseSystemParameter::ToSymbol(const WhiteNoiseSystemParameterType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;switch (type)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::control:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("B");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::initial_state_real:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("x");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::measurement_frequency:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("f");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::real_measurement_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("R"); //Shouldn't be 'r', as it is a vector?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::real_process_noise:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("Q"); //Shouldn't be 'q', as it is a vector?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::state_transition:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return std::string("A");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case WhiteNoiseSystemParameterType::n_parameters:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!"Unimplemented type of WhiteNoiseSystemParameterType");&lt;br/&gt;
&amp;nbsp;&amp;nbsp;throw std::logic_error(__func__);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemparameter.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemparameter.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef WHITENOISESYSTEMPARAMETER_H&lt;br/&gt;
#define WHITENOISESYSTEMPARAMETER_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;string&amp;gt;&lt;br/&gt;
#include &amp;lt;vector&amp;gt;&lt;br/&gt;
#include "whitenoisesystemparametertype.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///A single WhiteNoiseSystemParameter&lt;br/&gt;
///for example, the state transition matrix&lt;br/&gt;
/// - is a matrix&lt;br/&gt;
/// - is not a vector&lt;br/&gt;
/// - has a description like 'Matrix that [...]'&lt;br/&gt;
/// - has the name 'State transition matrix'&lt;br/&gt;
/// - has the symbol 'A'&lt;br/&gt;
struct WhiteNoiseSystemParameter&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain all WhiteNoiseSystemParameterType values, except n_parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;WhiteNoiseSystemParameterType&amp;gt; GetAll();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is the type a matrix?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsMatrix(const WhiteNoiseSystemParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Is the type a vector?&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsVector(const WhiteNoiseSystemParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the full name of a type, e.g. 'Matrix to capture the physics of the system'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToDescription(const WhiteNoiseSystemParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the full name of a type, e.g. 'State transition'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToName(const WhiteNoiseSystemParameterType type);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the symbol of a type, e.g. 'A'&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToSymbol(const WhiteNoiseSystemParameterType type);&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // WHITENOISESYSTEMPARAMETER_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemparameters.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemparameters.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "whitenoisesystemparameters.h"&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include "matrix.h"&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::WhiteNoiseSystemParameters::WhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;: m_control{control},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_initial_state{initial_state},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_real_measurement_noise{real_measurement_noise},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_real_process_noise{real_process_noise},&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m_state_transition{state_transition}&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Check for correct dimensionality&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const size_t sz = initial_state.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//assert(sz &amp;gt;= 0); //Inevitable for std::size_t&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_control.size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_control.size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_initial_state.size() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_real_measurement_noise.size() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_real_process_noise.size() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_state_transition.size1() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_state_transition.size2() == sz);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::WhiteNoiseSystemParameters::GetVersion() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return "1.0";&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;std::string&amp;gt; ribi::kalman::WhiteNoiseSystemParameters::GetVersionHistory() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"2013-04-28: version 1.0: initial version"&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::WhiteNoiseSystemParameters::IsAboutEqual(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const WhiteNoiseSystemParameters&amp;amp; lhs, const WhiteNoiseSystemParameters&amp;amp; rhs) noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Matrix::MatricesAreAboutEqual(lhs.GetControl(),rhs.GetControl())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::VectorsAreAboutEqual(lhs.GetInitialState(),rhs.GetInitialState())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::VectorsAreAboutEqual(lhs.GetMeasurementNoise(),rhs.GetMeasurementNoise())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::VectorsAreAboutEqual(lhs.GetProcessNoise(),rhs.GetProcessNoise())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; Matrix::MatricesAreAboutEqual(lhs.GetStateTransition(),rhs.GetStateTransition());&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemparameters.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemparameters.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef WHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
#define WHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/matrix.hpp&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/ublas/vector.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystemtype.h"&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
///ABC of the parameters of a white noise system&lt;br/&gt;
struct WhiteNoiseSystemParameters&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameters(const WhiteNoiseSystemParameters&amp;amp;) = delete;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;WhiteNoiseSystemParameters&amp;amp; operator=(const WhiteNoiseSystemParameters&amp;amp;) = delete;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual ~WhiteNoiseSystemParameters() noexcept {}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The control matrix to determine the influence of the input (in GoToNextState)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetControl() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_control; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the real initial state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetInitialState() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_initial_state; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The real standard deviation of the noise in the state transition&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///(used in WhiteNoiseSystem::GoToNextState)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetProcessNoise() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_real_process_noise; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The real amount of noise in the system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///A noise of zero indicates a system that can be measured accurately to infinite precision&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; GetMeasurementNoise() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_real_measurement_noise; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The state transitions in the system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///(used in WhiteNoiseSystem::GoToNextState)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; GetStateTransition() const noexcept&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ return m_state_transition; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the type as an enum&lt;br/&gt;
&amp;nbsp;&amp;nbsp;virtual WhiteNoiseSystemType GetType() const noexcept = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string GetVersion() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Obtain the version history of this class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;std::string&amp;gt; GetVersionHistory() noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///Check two parameter sets for equality using a fuzzy comparison&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static bool IsAboutEqual(const WhiteNoiseSystemParameters&amp;amp; lhs, const WhiteNoiseSystemParameters&amp;amp; rhs) noexcept;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;protected:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///An ABC can only be constructed by derived classes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;explicit WhiteNoiseSystemParameters(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; initial_state,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt;&amp;amp; real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt;&amp;amp; state_transition);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The control matrix to determine the influence of the input (in GoToNextState)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_control;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The real initial state&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_initial_state;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The real amount of noise in the system&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///A noise of zero indicates a system that can be measured accurately to infinite precision&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_real_measurement_noise;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The standard deviation of the noise in the state transition (in GoToNextState)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::vector&amp;lt;double&amp;gt; m_real_process_noise;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;///The state transitions in the system, used in GoToNextState&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const boost::numeric::ublas::matrix&amp;lt;double&amp;gt; m_state_transition;&lt;br/&gt;
&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // WHITENOISESYSTEMPARAMETERS_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemparametertype.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemparametertype.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#include "whitenoisesystemparametertype.h"&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;cassert&amp;gt;&lt;br/&gt;
#include &amp;lt;boost/numeric/conversion/cast.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator&amp;lt;(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) &amp;lt; static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator==(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) == static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator!=(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return !(lhs == rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemparametertype.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemparametertype.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef WHITENOISESYSTEMPARAMETERTYPE_H&lt;br/&gt;
#define WHITENOISESYSTEMPARAMETERTYPE_H&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
enum class WhiteNoiseSystemParameterType&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;control,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;initial_state_real,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;measurement_frequency,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;real_measurement_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;real_process_noise,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;state_transition,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;n_parameters&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
bool operator&amp;lt;(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs);&lt;br/&gt;
bool operator==(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs);&lt;br/&gt;
bool operator!=(const WhiteNoiseSystemParameterType lhs, const WhiteNoiseSystemParameterType rhs);&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // WHITENOISESYSTEMPARAMETERTYPE_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemtype.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemtype.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystemtype.h"&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator==(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) == static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator!=(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) != static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
bool ribi::kalman::operator&amp;lt;(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//Must cast enum class to integer, because of a bug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//in GCC version 4.4.0:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return static_cast&amp;lt;int&amp;gt;(lhs) &amp;lt; static_cast&amp;lt;int&amp;gt;(rhs);&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemtype.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemtype.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef WHITENOISESYSTEMTYPE_H&lt;br/&gt;
#define WHITENOISESYSTEMTYPE_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;string&amp;gt;&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
enum class WhiteNoiseSystemType&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;gaps_filled,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;lagged,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;standard,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;n_types&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
bool operator==(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs);&lt;br/&gt;
bool operator!=(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs);&lt;br/&gt;
bool operator&amp;lt;(const WhiteNoiseSystemType lhs, const WhiteNoiseSystemType rhs);&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // WHITENOISESYSTEMTYPE_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemtypes.cpp&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemtypes.cpp" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystemtypes.h"&lt;br/&gt;
&lt;br/&gt;
boost::bimap&amp;lt;ribi::kalman::WhiteNoiseSystemType,std::string&amp;gt; ribi::kalman::WhiteNoiseSystemTypes::m_map;&lt;br/&gt;
&lt;br/&gt;
const boost::bimap&amp;lt;ribi::kalman::WhiteNoiseSystemType,std::string&amp;gt; ribi::kalman::WhiteNoiseSystemTypes::CreateMap()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Test();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;boost::bimap&amp;lt;WhiteNoiseSystemType,std::string&amp;gt; m;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m.insert(boost::bimap&amp;lt;WhiteNoiseSystemType,std::string&amp;gt;::value_type(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType::gaps_filled,std::string("gaps_filled")));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m.insert(boost::bimap&amp;lt;WhiteNoiseSystemType,std::string&amp;gt;::value_type(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType::lagged,std::string("lagged")));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;m.insert(boost::bimap&amp;lt;WhiteNoiseSystemType,std::string&amp;gt;::value_type(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType::standard,std::string("standard")));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return m;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
const std::vector&amp;lt;ribi::kalman::WhiteNoiseSystemType&amp;gt; ribi::kalman::WhiteNoiseSystemTypes::GetAllTypes()&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;WhiteNoiseSystemType&amp;gt; v {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType::gaps_filled,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType::lagged,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WhiteNoiseSystemType::standard&lt;br/&gt;
&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(static_cast&amp;lt;int&amp;gt;(v.size()) == static_cast&amp;lt;int&amp;gt;(WhiteNoiseSystemType::n_types));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return v;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
#ifndef NDEBUG&lt;br/&gt;
void ribi::kalman::WhiteNoiseSystemTypes::Test() noexcept&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static bool is_tested = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (is_tested) return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;is_tested = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::vector&amp;lt;WhiteNoiseSystemType&amp;gt; v = GetAllTypes();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::size_t sz = v.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (std::size_t i=0; i!=sz; ++i)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(i &amp;lt; v.size());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const WhiteNoiseSystemType t = v[i];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::string s = ToStr(t);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(!s.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const WhiteNoiseSystemType u = ToType(s);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(u == t);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
#endif&lt;br/&gt;
&lt;br/&gt;
const std::string ribi::kalman::WhiteNoiseSystemTypes::ToStr(const WhiteNoiseSystemType type)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (m_map.left.empty()) m_map = CreateMap();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_map.left.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_map.left.count(type) == 1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const std::string s = m_map.left.find(type)-&amp;gt;second;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return s;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
ribi::kalman::WhiteNoiseSystemType ribi::kalman::WhiteNoiseSystemTypes::ToType(const std::string&amp;amp; s)&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (m_map.right.empty()) m_map = CreateMap();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(!m_map.right.empty());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(m_map.right.count(s) == 1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;const WhiteNoiseSystemType t = m_map.right.find(s)-&amp;gt;second;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return t;&lt;br/&gt;
}&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;./CppKalmanFilter/whitenoisesystemtypes.h&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;!-- start of code --&gt;
&lt;table summary="./CppKalmanFilter/whitenoisesystemtypes.h" border = "1"&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;
#ifndef WHITENOISESYSTEMTYPES_H&lt;br/&gt;
#define WHITENOISESYSTEMTYPES_H&lt;br/&gt;
&lt;br/&gt;
#include &amp;lt;string&amp;gt;&lt;br/&gt;
#include &amp;lt;vector&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#pragma GCC diagnostic push&lt;br/&gt;
#pragma GCC diagnostic ignored "-Weffc++"&lt;br/&gt;
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"&lt;br/&gt;
#include &amp;lt;boost/bimap.hpp&amp;gt;&lt;br/&gt;
#pragma GCC diagnostic pop&lt;br/&gt;
&lt;br/&gt;
#include "whitenoisesystemtype.h"&lt;br/&gt;
&lt;br/&gt;
namespace ribi {&lt;br/&gt;
namespace kalman {&lt;br/&gt;
&lt;br/&gt;
struct WhiteNoiseSystemTypes&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::vector&amp;lt;WhiteNoiseSystemType&amp;gt; GetAllTypes();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const std::string ToStr(const WhiteNoiseSystemType type);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static WhiteNoiseSystemType ToType(const std::string&amp;amp; s);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static boost::bimap&amp;lt;WhiteNoiseSystemType,std::string&amp;gt; m_map;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static const boost::bimap&amp;lt;WhiteNoiseSystemType,std::string&amp;gt; CreateMap();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#ifndef NDEBUG&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static void Test() noexcept;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;#endif&lt;br/&gt;
&lt;br/&gt;
};&lt;br/&gt;
&lt;br/&gt;
} //~namespace kalman&lt;br/&gt;
} //~namespace ribi&lt;br/&gt;
&lt;br/&gt;
#endif // WHITENOISESYSTEMTYPES_H&lt;br/&gt;
&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;!-- end of the code --&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;a href="Cpp.htm"&gt;Go back to Richel Bilderbeek's C++ page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="index.htm"&gt;Go back to Richel Bilderbeek's homepage&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://validator.w3.org/check?uri=referer"&gt;&lt;img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This page has been created by the &lt;a href="Tools.htm"&gt;tool&lt;/a&gt; &lt;a href="ToolCodeToHtml.htm"&gt;CodeToHtml&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
