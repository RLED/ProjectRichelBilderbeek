 
<title>DoFilterOperation</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Subject>C++ DoFilterOperation</o:Subject>
  <o:Author>Richel Bilderbeek</o:Author>
  <o:Keywords>C++ Richel Bilderbeek DoFilterOperation convolution convolute do filter operation</o:Keywords>
  <o:Description>From http://www.richelbilderbeek.nl</o:Description>
  <o:LastAuthor>Richel Bilderbeek</o:LastAuthor>
  <o:Revision>17</o:Revision>
  <o:TotalTime>201</o:TotalTime>
  <o:Created>2008-07-23T13:39:00Z</o:Created>
  <o:LastSaved>2008-07-23T15:08:00Z</o:LastSaved>
  <o:Pages>4</o:Pages>
  <o:Words>988</o:Words>
  <o:Characters>5636</o:Characters>
  <o:Category>C++ Richel Bilderbeek DoFilterOperation</o:Category>
  <o:Manager>Richel Bilderbeek</o:Manager>
  <o:Company>Richel Bilderbeek</o:Company>
  <o:Lines>46</o:Lines>
  <o:Paragraphs>11</o:Paragraphs>
  <o:CharactersWithSpaces>6921</o:CharactersWithSpaces>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
 
</head>

 

 

<p><a
href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>

<p><a
href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h1>(<a href="Cpp.htm">C++</a>)
<a href="CppDoFilterOperation.htm">DoFilterOperation</a></h1>

<p>&nbsp;</p>

<p><a href="CppGraphics.htm">Graphics</a> and <a
href="CppMath.htm">math</a> <a href="CppCodeSnippets.htm"> code Snippet</a> to perform a
filter operation (also called a convolution) on an image. This image is a 2D <a
href="CppVector.htm">std::vector</a> of <a href="CppInt.htm">int</a>
(y-x-ordered).</p>

<p>&nbsp;</p>

<p>The <a href="Tools.htm">tool</a> <a
href="ToolFilterOperationer.htm">FilterOperationer</a> demonstrates the use
of   <a
href="CppDoFilterOperation.htm">DoFilterOperation</a>.</p>

<p>&nbsp;</p>

<p>* <a href="CppDoFilterOperation.PNG">View an
example image of 'DoFilterOperation'</a>.</p>

<p>* <a href="CppDoFilterOperation.txt">View the
code of 'DoFilterOperation' in plain text</a>.</p>

<p>&nbsp;</p>

 

<p>&nbsp;</p>

<p><a href="CppInclude.htm">#include</a>
&lt;<a href="CppVectorH.htm">vector</a>&gt;</p>

<p><a href="CppInclude.htm">#include</a>
&lt;<a href="CppCassertH.htm">cassert</a>&gt;</p>

<p>&nbsp;</p>

<p>//Return a y-x-ordered 2D
std::vector with the intensitief of grey</p>

<p>//values from range [0,255]
(0=black,255=white) after the filter operation</p>

<p>//From
http://www.richelbilderbeek.nl/CppDoFilterOperation.htm</p>

<p><b> <a href="CppConst.htm">const</a> </b>  <a href="CppVector.htm">std::vector</a>&lt;<a
href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;
&gt; DoFilterOperation(</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a
href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;
&gt;&amp; source, //y-x-ordered</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a
href="CppVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;
&gt;&amp; filter) //y-x-ordered</p>

<p>{</p>

<p> 
 <a href="CppAssert.htm">assert</a>(!source.empty());</p>

<p> 
 <a href="CppAssert.htm">assert</a>(!filter.empty());</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
width = source[0].size();</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
height = source.size();</p>

<p> 
 <a href="CppVector.htm">std::vector</a>&lt;<a href="CppVector.htm">std::vector</a>&lt;<b><a
href="CppInt.htm">int</a></b>&gt; &gt; v(height, <a href="CppVector.htm">std::vector</a>&lt;<b><a
href="CppInt.htm">int</a></b>&gt;(width));</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
maxx = source[0].size();</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
maxy = source.size();</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
midX = filter[0].size() / 2;</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
midY = filter.size()      / 2;</p>

<p>&nbsp;</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <a href="CppPair.htm">std::pair</a>&lt;<b><a
href="CppDouble.htm">double</a></b>,<b> <a href="CppDouble.htm">double</a></b>&gt;
filterRange = GetFilterRange(filter);</p>

<p> 
 <a href="CppAssert.htm">assert</a>(filterRange.first &lt;
filterRange.second);</p>

<p>&nbsp;</p>

<p> 
 <b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b>
y=0; y!=maxy; ++y)</p>

<p> 
 {</p>

<p>   
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
writeY = y;</p>

<p>   
 <a href="CppAssert.htm">assert</a>(writeY &gt;= 0 &amp;&amp; writeY &lt;
<b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(v.size())
);</p>

<p>   
 <a href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;&amp;
vLine = v[writeY];</p>

<p>   
 <b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b>
x=0; x!=maxx; ++x)</p>

<p>   
 {</p>

<p>       //The x and y values are the topleft coordinate of where</p>

<p>       //    the filter will be
applied to. This coordinat can be out of</p>

<p>       //    the range, but at
least one pixel of where the filter will be</p>

<p>       //    applied to will be
in range</p>

<p>       //The pixel value is normalized to the area the</p>

<p>       //    filter operation
took place on</p>

<p>       //The outcome of the filter operation is written to</p>

<p>       //    (x + midX, y +
midY), which HAS to be in range</p>

<p>       <b><a href="CppConst.htm">const</a></b> <b><a
href="CppDouble.htm">double</a></b> unscaledPixelValue =
GetFilterOperationPixel(source,x-midX,y-midY,filter);</p>

<p>       //Scale the unscaledPixelValue.</p>

<p>       //The maximal value of unscaledPixelValue is the sum of all
positive</p>

<p>       //values in the filter * 255.</p>

<p>       //The minimum value of unscaledPixelValue is the sum of all
negative</p>

<p>       //values in the filter * 255.</p>

<p>       //The scaled pixel value must be obtained by transforming the
unscaled</p>

<p>       //range [min,max] to [0,256&gt;.</p>

<p>       <b><a href="CppConst.htm">const</a></b> <b><a
href="CppDouble.htm">double</a></b> relUnscaledRange</p>

<p>         = (unscaledPixelValue - filterRange.first)</p>

<p>         / (filterRange.second - filterRange.first);</p>

<p>       <a href="CppAssert.htm">assert</a>(relUnscaledRange &gt;= 0.0
&amp;&amp; relUnscaledRange &lt;= 1.0);</p>

<p>       <b><a href="CppConst.htm">const</a></b> <b><a
href="CppDouble.htm">double</a></b> scaledRange = relUnscaledRange * 255;</p>

<p>       <a href="CppAssert.htm">assert</a>(scaledRange &gt;= 0.0
&amp;&amp; scaledRange &lt; 256.0);</p>

<p>       <b><a href="CppConst.htm">const</a></b> <b><a
href="CppInt.htm">int</a></b> pixel = scaledRange;</p>

<p>       <b><a href="CppConst.htm">const</a></b> <b><a
href="CppInt.htm">int</a></b> writeX = x;</p>

<p>       <a href="CppAssert.htm">assert</a>(writeX &gt;= 0 &amp;&amp;
writeX &lt; width);</p>

<p>       vLine[writeX] = pixel;</p>

<p>  
    }</p>

<p> 
 }</p>

<p> 
 <a href="CppAssert.htm">assert</a>(source[0].size()==v[0].size());</p>

<p> 
 <a href="CppAssert.htm">assert</a>(source.size()==v.size());</p>

<p> 
 <b><a href="CppReturn.htm">return</a></b> v;</p>

<p>}</p>

<p>&nbsp;</p>

</div>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

 

<p>&nbsp;</p>

<p>//The sourceX and sourceY values are
the topleft coordinate of where</p>

<p>//  
 the filter will be applied to. This coordinat can be out of</p>

<p>//  
 the range, but at least one pixel of where the filter will be</p>

<p>//  
 applied to will be in range. If there are no pixels in range,</p>

<p>//  
 an assertion will fail.</p>

<p>//The pixel value is normalized to
the area the</p>

<p>//  
 filter operation took place on. Therefore, this area must be non-zero</p>

<p>//The outcome of this filter
operation will be written to</p>

<p>//  
 (x + midX, y + midY), which HAS to be in range</p>

<p>//From
http://www.richelbilderbeek.nl/CppDoFilterOperation.htm</p>

<p><b> <a href="CppConst.htm">const</a> </b>  <b><a href="CppDouble.htm">double</a></b>
GetFilterOperationPixel(</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a
href="CppVector.htm">std::vector</a>&lt;<b><a href="CppInt.htm">int</a></b>&gt;
&gt;&amp; source, //y-x-ordered</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
sourceX,</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
sourceY,</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a
href="CppVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;
&gt;&amp; filter) //y-x-ordered</p>

<p>{</p>

<p> 
 <a href="CppAssert.htm">assert</a>(!source.empty());</p>

<p> 
 <a href="CppAssert.htm">assert</a>(!filter.empty());</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
sourceMaxY = source.size();</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
sourceMaxX = source[0].size();</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
filterMaxY = filter.size();</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
filterMaxX = filter[0].size();</p>

<p>&nbsp;</p>

<p> 
 <b><a href="CppDouble.htm">double</a></b> result = 0.0;</p>

<p> 
 <b><a href="CppInt.htm">int</a></b> nPixels = 0;</p>

<p> 
 <b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b>
y=0; y!=filterMaxY; ++y)</p>

<p> 
 {</p>

<p>   
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
readY = sourceY + y;</p>

<p>   
 <b><a href="CppIf.htm">if</a></b> ( readY &lt; 0 || readY &gt;=
sourceMaxY) <b><a href="CppContinue.htm">continue</a></b>;</p>

<p>   
 <a href="CppAssert.htm">assert</a>(y &gt;= 0);</p>

<p>   
 <a href="CppAssert.htm">assert</a>(y &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a
href="CppInt.htm">int</a></b>&gt;(filter.size()));</p>

<p>   
 <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a
href="CppDouble.htm">double</a></b>&gt;&amp; lineFilter = filter[y];</p>

<p>   
 <a href="CppAssert.htm">assert</a>(readY &gt;= 0);</p>

<p>   
 <a href="CppAssert.htm">assert</a>(readY &lt; <b><a
href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppInt.htm">int</a></b>&gt;(source.size()));</p>

<p>   
 <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a
href="CppInt.htm">int</a></b>&gt;&amp; lineSource = source[readY];</p>

<p>   
 <b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b>
x=0; x!=filterMaxX; ++x)</p>

<p>   
 {</p>

<p>       <b><a href="CppConst.htm">const</a></b> <b><a
href="CppInt.htm">int</a></b> readX = sourceX + x;</p>

<p>       <b><a href="CppIf.htm">if</a></b> ( readX &lt; 0 || readX
&gt;= sourceMaxX) <b><a href="CppContinue.htm">continue</a></b>;</p>

<p>       <a href="CppAssert.htm">assert</a>(x &gt;= 0);</p>

<p>       <a href="CppAssert.htm">assert</a>(x &lt; filterMaxX);</p>

<p>       <a href="CppAssert.htm">assert</a>(readX &gt;= 0);</p>

<p>       <a href="CppAssert.htm">assert</a>(readX &lt; sourceMaxX);</p>

<p>       <b><a href="CppConst.htm">const</a></b> <b><a
href="CppDouble.htm">double</a></b> deltaResult = <b><a
href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;(lineSource[readX])
* lineFilter[x];</p>

<p>       result += deltaResult;</p>

<p>       ++nPixels;</p>

<p>   
 }</p>

<p> 
 }</p>

<p> 
 <a href="CppAssert.htm">assert</a>(nPixels!=0);</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppDouble.htm">double</a></b>
filteredValue = result / <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a
href="CppDouble.htm">double</a></b>&gt;(nPixels);</p>

<p> 
 <b><a href="CppReturn.htm">return</a></b> filteredValue;</p>

<p>}</p>

<p>&nbsp;</p>

</div>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

 

<p>&nbsp;</p>

<p>//Obtains the range a filter can
have</p>

<p>//Assumes the every element has a
maximum value of 255</p>

<p>//From
http://www.richelbilderbeek.nl/CppDoFilterOperation.htm</p>

<p><b> <a href="CppConst.htm">const</a> </b>  std::pair&lt;<b><a
href="CppDouble.htm">double</a></b>,<b> <a href="CppDouble.htm">double</a></b>&gt;
GetFilterRange(<b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<a
href="CppVector.htm">std::vector</a>&lt;<b><a href="CppDouble.htm">double</a></b>&gt;
&gt;&amp; filter)</p>

<p>{</p>

<p>
 <a href="CppAssert.htm">assert</a>(!filter.empty());</p>

<p>
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
maxx = filter[0].size();</p>

<p>
 <b><a href="CppConst.htm">const</a></b> <b><a href="CppInt.htm">int</a></b>
maxy = filter.size();</p>

<p>
 <a href="CppAssert.htm">assert</a>(maxx + maxy &gt; 2 &amp;&amp;
&quot;Filter size must be bigger then 1x1&quot;);</p>

<p>
 <b><a href="CppDouble.htm">double</a></b> min = 0.0;</p>

<p>
 <b><a href="CppDouble.htm">double</a></b> max = 0.0;</p>

<p>
 <b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b>
y=0; y!=maxy; ++y)</p>

<p>
 {</p>

<p> 
 <a href="CppAssert.htm">assert</a>(y &gt;= 0);</p>

<p> 
 <a href="CppAssert.htm">assert</a>(y  
 &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;int&gt;(filter.size())
);</p>

<p>&nbsp;</p>

<p> 
 <b><a href="CppConst.htm">const</a></b> <a href="CppVector.htm">std::vector</a>&lt;<b><a
href="CppDouble.htm">double</a></b>&gt;&amp; lineFilter = filter[y];</p>

<p> 
 <b><a href="CppFor.htm">for</a></b> (<b><a href="CppInt.htm">int</a></b>
x=0; x!=maxx; ++x)</p>

<p> 
 {</p>

<p>     <a href="CppAssert.htm">assert</a>(x &gt;= 0);</p>

<p>     <a href="CppAssert.htm">assert</a>(x    &lt; <b><a href="CppStatic_cast.htm">static_cast</a></b>&lt;<b><a
href="CppInt.htm">int</a></b>&gt;(lineFilter.size()) );</p>

<p>&nbsp;</p>

<p>     <b><a href="CppConst.htm">const</a></b> <b><a
href="CppDouble.htm">double</a></b> value = lineFilter[x];</p>

<p>     <b><a href="CppIf.htm">if</a></b> (value &lt; 0.0) min
+=value;</p>

<p>     <b><a href="CppElse.htm">else</a></b> <b><a href="CppIf.htm">if</a></b>
(value &gt; 0.0) max +=value;</p>

<p> 
 }</p>

<p>
 }</p>

<p>
 <b><a href="CppConst.htm">const</a></b> <a href="CppPair.htm">std::pair</a>&lt;<b><a
href="CppDouble.htm">double</a></b>,<b><a href="CppDouble.htm">double</a></b>&gt;
range</p>

<p>
 = <a href="CppMake_pair.htm">std::make_pair</a>(min * 255.0, max *
255.0);</p>

<p class=MsoNormal style='border:none;mso-border-alt:solid windowtext .5pt;

padding:0in;mso-padding-alt:1.0pt 4.0pt 1.0pt 4.0pt'>   
 <b><a href="CppReturn.htm">return</a></b> range;</p>

<p>}</p>

<p>&nbsp;</p>

</div>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><a
href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>

<p><a
href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>

<p>&nbsp;</p>

</div>

</body>

</html>
