<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>Bristol</title>
  <meta name="description" content="C++ Bristol"/>
  <meta name="keywords" content="C++ Bristol "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="ProjectBristol.htm">Bristol</a></h1>
<p>&nbsp;</p>
<h2>./ProjectBristol/ComputerGenerated.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/ComputerGenerated.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;ComputerGenerated.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 30 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "Sim4Interpreter.h"<br/>
#include "OptionsFile.h"<br/>
#include "SimulationFile.h"<br/>
<br/>
//Below, only computer generated code...<br/>
//&nbsp;&nbsp;COMPUTER GENERATED CODE<br/>
void Sim4Interpreter::interpretSetDconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setDconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation D's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newDconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newDconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setDConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation D's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newDconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setDConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation D's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setDconstA(newDconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetFconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setFconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation F's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newFconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newFconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setFConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation F's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newFconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setFConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation F's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setFconstA(newFconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetGconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setGconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation G's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newGconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newGconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setGConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation G's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newGconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setGConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation G's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setGconstA(newGconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetMconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setMconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation M's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newMconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newMconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setMConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation M's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newMconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setMConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation M's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setMconstA(newMconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetNconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setNconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation N's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newNconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newNconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setNConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation N's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newNconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setNConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation N's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setNconstA(newNconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetPconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setPconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation P's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newPconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newPconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setPConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation P's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newPconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setPConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation P's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setPconstA(newPconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetQconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setQconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation Q's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newQconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newQconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setQConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation Q's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newQconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setQConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation Q's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setQconstA(newQconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetRconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setRconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation R's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newRconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newRconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setRConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation R's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newRconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setRConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation R's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setRconstA(newRconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetWconstA(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setWconstA' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation W's parameter A." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newWconstA=-1.0;																					<br/>
	if (isDouble(nextCommand,newWconstA)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setWConstA [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation W's parameter A as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newWconstA&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setWConstA [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation W's parameter A to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstA 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setWconstA(newWconstA);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetDconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setDconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation D's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newDconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newDconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setDConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation D's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newDconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setDConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation D's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setDconstB(newDconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetFconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setFconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation F's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newFconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newFconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setFConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation F's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newFconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setFConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation F's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setFconstB(newFconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetGconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setGconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation G's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newGconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newGconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setGConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation G's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newGconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setGConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation G's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setGconstB(newGconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetMconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setMconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation M's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newMconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newMconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setMConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation M's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newMconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setMConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation M's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setMconstB(newMconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetNconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setNconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation N's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newNconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newNconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setNConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation N's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newNconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setNConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation N's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setNconstB(newNconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetPconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setPconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation P's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newPconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newPconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setPConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation P's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newPconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setPConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation P's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setPconstB(newPconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetQconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setQconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation Q's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newQconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newQconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setQConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation Q's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newQconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setQConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation Q's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setQconstB(newQconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetRconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setRconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation R's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newRconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newRconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setRConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation R's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newRconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setRConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation R's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setRconstB(newRconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetWconstB(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setWconstB' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation W's parameter B." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newWconstB=-1.0;																					<br/>
	if (isDouble(nextCommand,newWconstB)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setWConstB [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation W's parameter B as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newWconstB&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setWConstB [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation W's parameter B to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstB 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setWconstB(newWconstB);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetDconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setDconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation D's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newDconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newDconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setDConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation D's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newDconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setDConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation D's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setDconstC(newDconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetFconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setFconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation F's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newFconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newFconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setFConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation F's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newFconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setFConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation F's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setFconstC(newFconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetGconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setGconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation G's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newGconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newGconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setGConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation G's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newGconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setGConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation G's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setGconstC(newGconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetMconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setMconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation M's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newMconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newMconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setMConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation M's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newMconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setMConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation M's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setMconstC(newMconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetNconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setNconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation N's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newNconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newNconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setNConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation N's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newNconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setNConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation N's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setNconstC(newNconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetPconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setPconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation P's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newPconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newPconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setPConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation P's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newPconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setPConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation P's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setPconstC(newPconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetQconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setQconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation Q's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newQconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newQconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setQConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation Q's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newQconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setQConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation Q's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setQconstC(newQconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetRconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setRconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation R's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newRconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newRconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setRConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation R's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newRconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setRConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation R's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setRconstC(newRconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetWconstC(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setWconstC' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation W's parameter C." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newWconstC=-1.0;																					<br/>
	if (isDouble(nextCommand,newWconstC)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setWConstC [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation W's parameter C as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newWconstC&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setWConstC [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation W's parameter C to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstC 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setWconstC(newWconstC);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetDconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setDconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation D's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newDconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newDconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setDConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation D's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newDconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setDConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation D's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setDconstD(newDconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetFconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setFconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation F's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newFconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newFconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setFConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation F's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newFconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setFConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation F's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setFconstD(newFconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetGconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setGconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation G's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newGconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newGconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setGConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation G's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newGconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setGConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation G's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setGconstD(newGconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetMconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setMconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation M's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newMconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newMconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setMConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation M's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newMconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setMConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation M's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setMconstD(newMconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetNconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setNconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation N's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newNconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newNconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setNConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation N's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newNconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setNConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation N's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setNconstD(newNconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetPconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setPconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation P's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newPconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newPconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setPConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation P's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newPconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setPConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation P's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setPconstD(newPconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetQconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setQconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation Q's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newQconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newQconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setQConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation Q's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newQconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setQConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation Q's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setQconstD(newQconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetRconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setRconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation R's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newRconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newRconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setRConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation R's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newRconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setRConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation R's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setRconstD(newRconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetWconstD(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setWconstD' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation W's parameter D." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newWconstD=-1.0;																					<br/>
	if (isDouble(nextCommand,newWconstD)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setWConstD [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation W's parameter D as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newWconstD&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setWConstD [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation W's parameter D to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstD 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setWconstD(newWconstD);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetDconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setDconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation D's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newDconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newDconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setDConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation D's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newDconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setDConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation D's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setDconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setDconstE(newDconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetFconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setFconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation F's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newFconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newFconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setFConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation F's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newFconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setFConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation F's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setFconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setFconstE(newFconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetGconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setGconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation G's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newGconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newGconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setGConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation G's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newGconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setGConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation G's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setGconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setGconstE(newGconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetMconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setMconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation M's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newMconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newMconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setMConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation M's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newMconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setMConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation M's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setMconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setMconstE(newMconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetNconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setNconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation N's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newNconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newNconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setNConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation N's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newNconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setNConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation N's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setNconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setNconstE(newNconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetPconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setPconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation P's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newPconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newPconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setPConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation P's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newPconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setPConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation P's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setPconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setPconstE(newPconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetQconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setQconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation Q's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newQconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newQconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setQConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation Q's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newQconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setQConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation Q's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setQconstE(newQconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetRconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setRconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation R's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newRconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newRconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setRConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation R's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newRconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setRConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation R's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setRconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setRconstE(newRconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
void Sim4Interpreter::interpretSetWconstE(const unsigned int&amp; index)										<br/>
{																											<br/>
	if (index+1==mCommand.size())																			<br/>
	{&nbsp;&nbsp; //User typed 'setWconstE' only																		<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the VALUE of equation W's parameter E." &lt;&lt; std::endl				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	const std::string nextCommand = mCommand[index+1];														<br/>
	double newWconstE=-1.0;																					<br/>
	if (isDouble(nextCommand,newWconstE)==false)															<br/>
	{&nbsp;&nbsp; //User typed 'setWConstE [non-double]'																<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please specify the value of equation W's parameter E as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl;																					<br/>
		return;																								<br/>
	}																										<br/>
																											<br/>
	if (newWconstE&lt;0.0)																						<br/>
	{&nbsp;&nbsp; //User typed 'setWConstE [non-posive double]'														<br/>
		std::cout &lt;&lt; std::endl																				<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please set the VALUE of equation W's parameter E to a POSITIVE number." &lt;&lt; std::endl	<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setWconstE 1.5'"	&lt;&lt; std::endl											<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;																		<br/>
		return;																								<br/>
	}																										<br/>
	//Success. OptionsFile handles the feedback to the user													<br/>
	mOptionsFile.setWconstE(newWconstE);																	<br/>
}																											<br/>
//----------------------------------------------------------------------------------						<br/>
//<br/>
// COMPUTER GENERATED CODE<br/>
// OptionsFile<br/>
//<br/>
//----------------------------------------------------------------------------------<br/>
//&nbsp;&nbsp;COMPUTER GENERATED CODE<br/>
void OptionsFile::setDconstA(const double&amp; DconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's D constant A to 'DconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setDconstA(DconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation D's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; DconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setDconstA(DconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation D's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; DconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setFconstA(const double&amp; FconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's F constant A to 'FconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setFconstA(FconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation F's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; FconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setFconstA(FconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation F's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; FconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setGconstA(const double&amp; GconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's G constant A to 'GconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setGconstA(GconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation G's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; GconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setGconstA(GconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation G's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; GconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setMconstA(const double&amp; MconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's M constant A to 'MconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setMconstA(MconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation M's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; MconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setMconstA(MconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation M's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; MconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setNconstA(const double&amp; NconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's N constant A to 'NconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setNconstA(NconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation N's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; NconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setNconstA(NconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation N's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; NconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setPconstA(const double&amp; PconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's P constant A to 'PconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setPconstA(PconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation P's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; PconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setPconstA(PconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation P's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; PconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setQconstA(const double&amp; QconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's Q constant A to 'QconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setQconstA(QconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation Q's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; QconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setQconstA(QconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation Q's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; QconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setRconstA(const double&amp; RconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's R constant A to 'RconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setRconstA(RconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation R's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; RconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setRconstA(RconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation R's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; RconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setWconstA(const double&amp; WconstA)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's W constant A to 'WconstA'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setWconstA(WconstA);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation W's, constant A' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; WconstA &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setWconstA(WconstA);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation W's, constant A' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; WconstA &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setDconstB(const double&amp; DconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's D constant B to 'DconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setDconstB(DconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation D's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; DconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setDconstB(DconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation D's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; DconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setFconstB(const double&amp; FconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's F constant B to 'FconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setFconstB(FconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation F's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; FconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setFconstB(FconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation F's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; FconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setGconstB(const double&amp; GconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's G constant B to 'GconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setGconstB(GconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation G's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; GconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setGconstB(GconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation G's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; GconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setMconstB(const double&amp; MconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's M constant B to 'MconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setMconstB(MconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation M's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; MconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setMconstB(MconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation M's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; MconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setNconstB(const double&amp; NconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's N constant B to 'NconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setNconstB(NconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation N's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; NconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setNconstB(NconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation N's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; NconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setPconstB(const double&amp; PconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's P constant B to 'PconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setPconstB(PconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation P's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; PconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setPconstB(PconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation P's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; PconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setQconstB(const double&amp; QconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's Q constant B to 'QconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setQconstB(QconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation Q's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; QconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setQconstB(QconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation Q's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; QconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setRconstB(const double&amp; RconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's R constant B to 'RconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setRconstB(RconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation R's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; RconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setRconstB(RconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation R's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; RconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setWconstB(const double&amp; WconstB)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's W constant B to 'WconstB'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setWconstB(WconstB);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation W's, constant B' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; WconstB &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setWconstB(WconstB);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation W's, constant B' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; WconstB &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setDconstC(const double&amp; DconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's D constant C to 'DconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setDconstC(DconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation D's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; DconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setDconstC(DconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation D's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; DconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setFconstC(const double&amp; FconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's F constant C to 'FconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setFconstC(FconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation F's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; FconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setFconstC(FconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation F's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; FconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setGconstC(const double&amp; GconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's G constant C to 'GconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setGconstC(GconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation G's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; GconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setGconstC(GconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation G's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; GconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setMconstC(const double&amp; MconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's M constant C to 'MconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setMconstC(MconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation M's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; MconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setMconstC(MconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation M's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; MconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setNconstC(const double&amp; NconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's N constant C to 'NconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setNconstC(NconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation N's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; NconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setNconstC(NconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation N's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; NconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setPconstC(const double&amp; PconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's P constant C to 'PconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setPconstC(PconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation P's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; PconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setPconstC(PconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation P's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; PconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setQconstC(const double&amp; QconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's Q constant C to 'QconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setQconstC(QconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation Q's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; QconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setQconstC(QconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation Q's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; QconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setRconstC(const double&amp; RconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's R constant C to 'RconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setRconstC(RconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation R's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; RconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setRconstC(RconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation R's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; RconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setWconstC(const double&amp; WconstC)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's W constant C to 'WconstC'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setWconstC(WconstC);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation W's, constant C' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; WconstC &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setWconstC(WconstC);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation W's, constant C' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; WconstC &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setDconstD(const double&amp; DconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's D constant D to 'DconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setDconstD(DconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation D's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; DconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setDconstD(DconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation D's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; DconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setFconstD(const double&amp; FconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's F constant D to 'FconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setFconstD(FconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation F's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; FconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setFconstD(FconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation F's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; FconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setGconstD(const double&amp; GconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's G constant D to 'GconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setGconstD(GconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation G's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; GconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setGconstD(GconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation G's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; GconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setMconstD(const double&amp; MconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's M constant D to 'MconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setMconstD(MconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation M's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; MconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setMconstD(MconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation M's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; MconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setNconstD(const double&amp; NconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's N constant D to 'NconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setNconstD(NconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation N's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; NconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setNconstD(NconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation N's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; NconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setPconstD(const double&amp; PconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's P constant D to 'PconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setPconstD(PconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation P's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; PconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setPconstD(PconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation P's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; PconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setQconstD(const double&amp; QconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's Q constant D to 'QconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setQconstD(QconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation Q's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; QconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setQconstD(QconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation Q's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; QconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setRconstD(const double&amp; RconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's R constant D to 'RconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setRconstD(RconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation R's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; RconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setRconstD(RconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation R's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; RconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setWconstD(const double&amp; WconstD)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's W constant D to 'WconstD'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setWconstD(WconstD);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation W's, constant D' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; WconstD &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setWconstD(WconstD);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation W's, constant D' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; WconstD &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setDconstE(const double&amp; DconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's D constant E to 'DconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setDconstE(DconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation D's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; DconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setDconstE(DconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation D's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; DconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setFconstE(const double&amp; FconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's F constant E to 'FconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setFconstE(FconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation F's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; FconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setFconstE(FconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation F's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; FconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setGconstE(const double&amp; GconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's G constant E to 'GconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setGconstE(GconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation G's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; GconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setGconstE(GconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation G's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; GconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setMconstE(const double&amp; MconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's M constant E to 'MconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setMconstE(MconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation M's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; MconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setMconstE(MconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation M's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; MconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setNconstE(const double&amp; NconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's N constant E to 'NconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setNconstE(NconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation N's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; NconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setNconstE(NconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation N's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; NconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setPconstE(const double&amp; PconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's P constant E to 'PconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setPconstE(PconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation P's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; PconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setPconstE(PconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation P's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; PconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setQconstE(const double&amp; QconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's Q constant E to 'QconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setQconstE(QconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation Q's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; QconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setQconstE(QconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation Q's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; QconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setRconstE(const double&amp; RconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's R constant E to 'RconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setRconstE(RconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation R's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; RconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setRconstE(RconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation R's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; RconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setWconstE(const double&amp; WconstE)										<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));&nbsp;&nbsp;<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all equation's W constant E to 'WconstE'									<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setWconstE(WconstE);&nbsp;&nbsp; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set 'equation W's, constant E' of all Simulation Files to "			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; WconstE &lt;&lt; std::endl &lt;&lt; std::endl;											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setWconstE(WconstE);								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Set 'equation W's, constant E' of Simulation File #"				<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; WconstE &lt;&lt; std::endl &lt;&lt; std::endl;		<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setD(const EnumD&amp; enumD)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation D to 'enumD'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setD(enumD);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation D of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumDtoString(enumD) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setD(enumD);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation D of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumDtoString(enumD)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setF(const EnumF&amp; enumF)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation F to 'enumF'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setF(enumF);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation F of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumFtoString(enumF) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setF(enumF);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation F of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumFtoString(enumF)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setG(const EnumG&amp; enumG)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation G to 'enumG'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setG(enumG);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation G of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumGtoString(enumG) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setG(enumG);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation G of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumGtoString(enumG)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setM(const EnumM&amp; enumM)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation M to 'enumM'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setM(enumM);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation M of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumMtoString(enumM) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setM(enumM);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation M of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumMtoString(enumM)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setN(const EnumN&amp; enumN)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation N to 'enumN'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setN(enumN);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation N of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumNtoString(enumN) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setN(enumN);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation N of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumNtoString(enumN)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setP(const EnumP&amp; enumP)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation P to 'enumP'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setP(enumP);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation P of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumPtoString(enumP) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setP(enumP);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation P of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumPtoString(enumP)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setQ(const EnumQ&amp; enumQ)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation Q to 'enumQ'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setQ(enumQ);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation Q of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumQtoString(enumQ) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setQ(enumQ);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation Q of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumQtoString(enumQ)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setR(const EnumR&amp; enumR)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation R to 'enumR'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setR(enumR);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation R of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumRtoString(enumR) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setR(enumR);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation R of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumRtoString(enumR)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void OptionsFile::setW(const EnumW&amp; enumW)												<br/>
{																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));	<br/>
																							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mUsesSimFile==-1)																	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; //Set all SimFile's equation W to 'enumW'											<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned int nSimFile = mSimulationFile.size();								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setW(enumW);			<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation W of all Simulation Files to "							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; enumWtoString(enumW) &lt;&lt; std::endl &lt;&lt; std::endl;							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else																					<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{																						<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mSimulationFile[mUsesSimFile].setW(enumW);										<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; std::endl															<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Set equation W of Simulation File #"								<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; enumWtoString(enumW)							<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; std::endl &lt;&lt; std::endl;													<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}																						<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
//----------------------------------------------------------------------------------<br/>
//<br/>
// COMPUTER GENERATED CODE<br/>
// SimulationFile<br/>
//<br/>
//----------------------------------------------------------------------------------<br/>
//&nbsp;&nbsp;COMPUTER GENERATED CODE<br/>
void SimulationFile::setDconstA(const double&amp; DconstA)									<br/>
{																						<br/>
	mParameters.paramsD.A = DconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setFconstA(const double&amp; FconstA)									<br/>
{																						<br/>
	mParameters.paramsF.A = FconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setGconstA(const double&amp; GconstA)									<br/>
{																						<br/>
	mParameters.paramsG.A = GconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setMconstA(const double&amp; MconstA)									<br/>
{																						<br/>
	mParameters.paramsM.A = MconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setNconstA(const double&amp; NconstA)									<br/>
{																						<br/>
	mParameters.paramsN.A = NconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setPconstA(const double&amp; PconstA)									<br/>
{																						<br/>
	mParameters.paramsP.A = PconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setQconstA(const double&amp; QconstA)									<br/>
{																						<br/>
	mParameters.paramsQ.A = QconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setRconstA(const double&amp; RconstA)									<br/>
{																						<br/>
	mParameters.paramsR.A = RconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setWconstA(const double&amp; WconstA)									<br/>
{																						<br/>
	mParameters.paramsW.A = WconstA;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setDconstB(const double&amp; DconstB)									<br/>
{																						<br/>
	mParameters.paramsD.B = DconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setFconstB(const double&amp; FconstB)									<br/>
{																						<br/>
	mParameters.paramsF.B = FconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setGconstB(const double&amp; GconstB)									<br/>
{																						<br/>
	mParameters.paramsG.B = GconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setMconstB(const double&amp; MconstB)									<br/>
{																						<br/>
	mParameters.paramsM.B = MconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setNconstB(const double&amp; NconstB)									<br/>
{																						<br/>
	mParameters.paramsN.B = NconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setPconstB(const double&amp; PconstB)									<br/>
{																						<br/>
	mParameters.paramsP.B = PconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setQconstB(const double&amp; QconstB)									<br/>
{																						<br/>
	mParameters.paramsQ.B = QconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setRconstB(const double&amp; RconstB)									<br/>
{																						<br/>
	mParameters.paramsR.B = RconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setWconstB(const double&amp; WconstB)									<br/>
{																						<br/>
	mParameters.paramsW.B = WconstB;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setDconstC(const double&amp; DconstC)									<br/>
{																						<br/>
	mParameters.paramsD.C = DconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setFconstC(const double&amp; FconstC)									<br/>
{																						<br/>
	mParameters.paramsF.C = FconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setGconstC(const double&amp; GconstC)									<br/>
{																						<br/>
	mParameters.paramsG.C = GconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setMconstC(const double&amp; MconstC)									<br/>
{																						<br/>
	mParameters.paramsM.C = MconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setNconstC(const double&amp; NconstC)									<br/>
{																						<br/>
	mParameters.paramsN.C = NconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setPconstC(const double&amp; PconstC)									<br/>
{																						<br/>
	mParameters.paramsP.C = PconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setQconstC(const double&amp; QconstC)									<br/>
{																						<br/>
	mParameters.paramsQ.C = QconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setRconstC(const double&amp; RconstC)									<br/>
{																						<br/>
	mParameters.paramsR.C = RconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setWconstC(const double&amp; WconstC)									<br/>
{																						<br/>
	mParameters.paramsW.C = WconstC;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setDconstD(const double&amp; DconstD)									<br/>
{																						<br/>
	mParameters.paramsD.D = DconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setFconstD(const double&amp; FconstD)									<br/>
{																						<br/>
	mParameters.paramsF.D = FconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setGconstD(const double&amp; GconstD)									<br/>
{																						<br/>
	mParameters.paramsG.D = GconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setMconstD(const double&amp; MconstD)									<br/>
{																						<br/>
	mParameters.paramsM.D = MconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setNconstD(const double&amp; NconstD)									<br/>
{																						<br/>
	mParameters.paramsN.D = NconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setPconstD(const double&amp; PconstD)									<br/>
{																						<br/>
	mParameters.paramsP.D = PconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setQconstD(const double&amp; QconstD)									<br/>
{																						<br/>
	mParameters.paramsQ.D = QconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setRconstD(const double&amp; RconstD)									<br/>
{																						<br/>
	mParameters.paramsR.D = RconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setWconstD(const double&amp; WconstD)									<br/>
{																						<br/>
	mParameters.paramsW.D = WconstD;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setDconstE(const double&amp; DconstE)									<br/>
{																						<br/>
	mParameters.paramsD.E = DconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setFconstE(const double&amp; FconstE)									<br/>
{																						<br/>
	mParameters.paramsF.E = FconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setGconstE(const double&amp; GconstE)									<br/>
{																						<br/>
	mParameters.paramsG.E = GconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setMconstE(const double&amp; MconstE)									<br/>
{																						<br/>
	mParameters.paramsM.E = MconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setNconstE(const double&amp; NconstE)									<br/>
{																						<br/>
	mParameters.paramsN.E = NconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setPconstE(const double&amp; PconstE)									<br/>
{																						<br/>
	mParameters.paramsP.E = PconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setQconstE(const double&amp; QconstE)									<br/>
{																						<br/>
	mParameters.paramsQ.E = QconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setRconstE(const double&amp; RconstE)									<br/>
{																						<br/>
	mParameters.paramsR.E = RconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
void SimulationFile::setWconstE(const double&amp; WconstE)									<br/>
{																						<br/>
	mParameters.paramsW.E = WconstE;													<br/>
	writeToFile();																		<br/>
}																						<br/>
//----------------------------------------------------------------------------------&nbsp;&nbsp; <br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Enumerations.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Enumerations.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Enumerations.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue Jun 07 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "Enumerations.h"<br/>
//----------------------------------------------------------------------------------<br/>
// EnumD<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumDtoString(const EnumD&amp; enumD)<br/>
{<br/>
	switch(enumD)<br/>
	{<br/>
		case enumDdefault: return "enumDdefault";<br/>
		//case enumDsizeOnly: return "enumDsizeOnly";<br/>
		//case enumDconstant: return "enumDconstant";<br/>
	}<br/>
	assert(!"ERROR in 'std::string enumDToString(const EnumD&amp; enumD)'");<br/>
	exit(1);<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumD stringToEnumD(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumDdefault") return enumDdefault;<br/>
	//if (myString=="enumDsizeOnly") return enumDsizeOnly;<br/>
	if (myString=="enumDconstant") return enumDdefault; //Backwards compatible<br/>
	assert(!"ERROR in 'EnumD StringToEnumD(const std::string&amp; myString)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumD userInputToEnumD(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumDdefault;<br/>
		//case 1: return enumDconstant;<br/>
		//case 2: return enumDsizeOnly;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumD");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
// EnumF<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumFtoString(const EnumF&amp; enumF)<br/>
{<br/>
	switch(enumF)<br/>
	{<br/>
		//case enumFgauss: return "enumFgauss";<br/>
		case enumFdefault: return "enumFdefault";<br/>
		//case enumFconstant: return "enumFconstant";<br/>
	}<br/>
	assert(!"ERROR in 'std::string enumFToString(const EnumF&amp; enumF)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumF stringToEnumF(const std::string&amp; myString)<br/>
{<br/>
	//if (myString=="enumFgauss") return enumFgauss;<br/>
	if (myString=="enumFdefault") return enumFdefault;<br/>
	if (myString=="enumFconstant") return enumFdefault;<br/>
	std::cout &lt;&lt; "ERROR: myString equals: " &lt;&lt; myString &lt;&lt; std::endl;<br/>
	assert(!"ERROR in 'EnumF StringToEnumF(const std::string&amp; myString)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumF userInputToEnumF(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
//		case 0: return enumFconstant;<br/>
		case 0: return enumFdefault;<br/>
//		case 2: return enumFgauss;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumF");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
// EnumG<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumGtoString(const EnumG&amp; enumG)<br/>
{<br/>
	switch(enumG)<br/>
	{<br/>
		case enumGplastic: return "enumGplastic";<br/>
		case enumGconstant: return "enumGconstant";<br/>
	}<br/>
	assert(!"ERROR in 'std::string enumGToString(const EnumG&amp; enumG)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumG stringToEnumG(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumGplastic") return enumGplastic;<br/>
	if (myString=="enumGconstant") return enumGconstant;<br/>
	if (myString=="enumGfixed") return enumGconstant; //Backwards compatible<br/>
	assert(!"ERROR in 'EnumG StringToEnumG(const std::string&amp; myString)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumG userInputToEnumG(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumGconstant;<br/>
		case 1: return enumGplastic;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumG");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
// EnumM<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumMtoString(const EnumM&amp; enumM)<br/>
{<br/>
	switch(enumM)<br/>
	{<br/>
		case enumMdefault : return "enumMdefault";<br/>
		case enumMconstant: return "enumMconstant";<br/>
		//case enumMzero: return "enumMzero";<br/>
	}<br/>
	assert(!"std::string enumMtoString(const EnumM&amp; enumM)");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumM stringToEnumM(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumMdefault") return enumMdefault;<br/>
	if (myString=="enumMconstant") return enumMconstant;<br/>
	assert(!"EnumM StringToEnumM(const std::string&amp; myString)");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumM userInputToEnumM(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumMconstant;<br/>
		case 1: return enumMdefault;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumM");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
// EnumN<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumNtoString(const EnumN&amp; enumN)<br/>
{<br/>
	switch(enumN)<br/>
	{<br/>
		case enumNplastic : return "enumNplastic";<br/>
		case enumNconstant: return "enumNconstant";<br/>
	}<br/>
	assert(!"Unknown value of enumN");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumN stringToEnumN(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumNplastic") return enumNplastic;<br/>
	if (myString=="enumNconstant") return enumNconstant;<br/>
	if (myString=="enumNdefault") return enumNplastic; //Backwards compatibility<br/>
	std::cout &lt;&lt; "ERROR: myString equals: " &lt;&lt; myString &lt;&lt; std::endl;<br/>
	assert(!("Cannot convert myString to enumN"));<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumN userInputToEnumN(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumNplastic;<br/>
		case 1: return enumNconstant;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumN");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
// EnumP<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumPtoString(const EnumP&amp; enumP)<br/>
{<br/>
	switch(enumP)<br/>
	{<br/>
		case enumPplastic: return "enumPplastic";<br/>
		//case enumPplasticB: return "enumPplasticB";<br/>
		//case enumPnonPlastic: return "enumPnonPlastic";<br/>
		case enumPconstant: return "enumPconstant";<br/>
	}<br/>
	assert(!"ERROR in 'std::string enumPToString(const EnumP&amp; enumP)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumP stringToEnumP(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumPplastic") return enumPplastic;<br/>
	//if (myString=="enumPplasticB") return enumPplasticB;<br/>
	//if (myString=="enumPnonPlastic") return enumPnonPlastic;<br/>
	if (myString=="enumPconstant") return enumPconstant; //Backwards compatible<br/>
	if (myString=="enumPplastic") return enumPplastic; //Backwards compatible<br/>
	std::cout &lt;&lt; "ERROR in 'EnumP StringToEnumP(const std::string&amp; myString)'" &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; myString &lt;&lt; std::endl;<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumP userInputToEnumP(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumPconstant;<br/>
		case 1: return enumPplastic;<br/>
//		case 2: return enumPplasticB;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnump");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//&nbsp;&nbsp;EnumQ<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumQtoString(const EnumQ&amp; enumQ)<br/>
{<br/>
	switch(enumQ)<br/>
	{<br/>
		case enumQdefault: return "enumQdefault";<br/>
		case enumQconstant: return "enumQconstant";<br/>
	}<br/>
	assert(!"ERROR in 'std::string enumQToString(const EnumQ&amp; enumQ)'");<br/>
	exit(1);<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumQ stringToEnumQ(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumQdefault") return enumQdefault;<br/>
	if (myString=="enumQconstant") return enumQconstant;<br/>
	assert(!"ERROR in 'EnumQ StringToEnumQ(const std::string&amp; myString)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumQ userInputToEnumQ(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumQconstant;<br/>
		case 1: return enumQdefault;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumQ");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//&nbsp;&nbsp;EnumR<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumRtoString(const EnumR&amp; enumR)<br/>
{<br/>
	switch(enumR)<br/>
	{<br/>
		case enumRconstant: return "enumRconstant";<br/>
		case enumRlogistic: return "enumRlogistic";<br/>
		case enumRcosine&nbsp;&nbsp;: return "enumRcosine";<br/>
	}<br/>
	assert(!"ERROR in 'std::string enumRToString(const EnumR&amp; enumR)'");<br/>
	exit(1);<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumR stringToEnumR(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumRconstant") return enumRconstant;<br/>
	if (myString=="enumRlogistic") return enumRlogistic;<br/>
	if (myString=="enumRcosine") return enumRcosine;<br/>
	assert(!"ERROR in 'EnumR StringToEnumR(const std::string&amp; myString)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumR userInputToEnumR(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumRconstant;<br/>
		case 1: return enumRlogistic;<br/>
		case 2: return enumRcosine;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumR");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//&nbsp;&nbsp;EnumW<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumWtoString(const EnumW&amp; enumW)<br/>
{<br/>
	switch(enumW)<br/>
	{<br/>
		case enumWzero: return "enumWzero";<br/>
		case enumWuniform: return "enumWuniform";<br/>
	}<br/>
	assert(!"ERROR in 'std::string enumWToString(const EnumW&amp; enumW)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumW stringToEnumW(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumWzero") return enumWzero;<br/>
	if (myString=="enumWuniform") return enumWuniform;<br/>
	if (myString=="enumWZero") return enumWzero; //Backwards compampatible<br/>
	if (myString=="enumWUniform") return enumWuniform; //Backwards compatible<br/>
	if (myString=="enumSigmaZero") return enumWzero; //Backwards compatible<br/>
	if (myString=="enumSigmaUniform") return enumWuniform; //Backwards compatible<br/>
<br/>
	std::cout &lt;&lt; "ERROR: myString: '"&lt;&lt; myString &lt;&lt; "'" &lt;&lt; std::endl;<br/>
	assert(!"Unknown myString for EnumW");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumW userInputToEnumW(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumWzero;<br/>
		case 1: return enumWuniform;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumW");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
// EnumReproductionMode<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumReproductionModeToString(const EnumReproductionMode&amp; enumReproductionMode)<br/>
{<br/>
	switch(enumReproductionMode)<br/>
	{<br/>
		case enumReproductionModeFraction: return "enumReproductionModeFraction";<br/>
		case enumReproductionModeAmount: return "enumReproductionModeAmount";<br/>
	}<br/>
	assert(!"Unknown enumReproductionMode");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumReproductionMode stringToEnumReproductionMode(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumReproductionModeFraction") return enumReproductionModeFraction;<br/>
	if (myString=="enumReproductionModeAmount") return enumReproductionModeAmount;<br/>
	std::cout &lt;&lt; "ERROR: myString: '"&lt;&lt; myString &lt;&lt; "'" &lt;&lt; std::endl;<br/>
	assert(!"Unknown myString for EnumReprodictionMode");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumReproductionMode userInputToEnumReproductionMode(const int&amp; index)<br/>
{<br/>
	switch(index)<br/>
	{<br/>
		case 0: return enumReproductionModeFraction;<br/>
		case 1: return enumReproductionModeAmount;<br/>
	}<br/>
	assert(!"Unknown index in userInputToEnumReproductionMode");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//&nbsp;&nbsp;EnumInitializationMode<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumInitializationModetoString(const EnumInitializationMode&amp; enumInitializationMode)<br/>
{<br/>
	switch(enumInitializationMode)<br/>
	{<br/>
		case enumInitializationModeSame: return "enumInitializationModeSame";<br/>
		case enumInitializationModeUniform: return "enumInitializationModeUniform";<br/>
	}<br/>
	assert(!"ERROR in 'std::string enumInitializationModeToString(const EnumInitializationMode&amp; enumInitializationMode)'");<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumInitializationMode stringToEnumInitializationMode(const std::string&amp; myString)<br/>
{<br/>
	if (myString=="enumInitializationModeSame") return enumInitializationModeSame;<br/>
	if (myString=="enumInitializationModeUniform") return enumInitializationModeUniform;<br/>
	std::cout &lt;&lt; "ERROR in 'EnumInitializationMode StringToEnumInitializationMode(const std::string&amp; myString)'" &lt;&lt; std::endl;<br/>
	exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//&nbsp;&nbsp;EnumConclusion<br/>
//----------------------------------------------------------------------------------<br/>
std::string enumConclusionToString(const EnumConclusion&amp; conclusion)<br/>
{<br/>
	switch (conclusion)<br/>
	{<br/>
		case CcNoError: <br/>
			return "No error";<br/>
		case CcPopExtinct : <br/>
			return "Population went extinct";<br/>
		case CcPopSizeTooBig : <br/>
			return "Population size got too big";<br/>
		case CcNoffspringTooBigSingleParent : <br/>
			return "A single parent created too much offspring, in G: increase a";<br/>
		case CcNoffspringTooBigAllParents : <br/>
			return "All parents together created too much offspring, in G: increase a";<br/>
		case CcNoOffspringProduced :<br/>
			return "No offspring produced";<br/>
		case CcMeanPopSizeSmall:<br/>
			return "Mean population size was small";<br/>
		case CcMeanPopSizeLarge:<br/>
			return "Mean population size was large";<br/>
		case CcMeanBodySizeSmall:<br/>
			return "Mean Body size remained small";<br/>
		case CcMeanBodySizeLarge:<br/>
			return "Mean Body size remained large";<br/>
		case CcChanceToDieSmall:<br/>
			return "Mean chance to die small, in D: increase a and c, decrease b";<br/>
		case CcChanceToDieLarge:<br/>
			return "Mean chance to die large, in D: decrease a and c, increase b";<br/>
		case CcFractionBiomassPerOffspringInitialLarge:<br/>
			return "Mean Fraction Biomass Per Offspring Initail Large, decrease G, by decreasing a";<br/>
<br/>
	}<br/>
	assert(!"UNKNOWN Enum used in EnumConclusionToString");<br/>
	exit(1);<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void coutConclusions(std::vector&lt;EnumConclusion&gt;&amp; conclusions)<br/>
{<br/>
	const unsigned int nConclusions = conclusions.size();<br/>
	std::cout &lt;&lt; "Drawing " &lt;&lt; nConclusions &lt;&lt; " conclusions..." &lt;&lt; std::endl;<br/>
	for (unsigned int i = 0; i&lt;nConclusions; ++i)<br/>
	{<br/>
		std::cout &lt;&lt; enumConclusionToString(conclusions[i]) &lt;&lt; std::endl;<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Enumerations.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Enumerations.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Enumerations.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Wed Jun 01 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __ENUMERATIONS_H<br/>
#define __ENUMERATIONS_H<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert.h&gt;<br/>
<br/>
enum EnumD<br/>
{<br/>
	enumDdefault<br/>
};<br/>
<br/>
enum EnumF<br/>
{<br/>
	enumFdefault<br/>
};<br/>
<br/>
enum EnumG<br/>
{<br/>
	enumGplastic,<br/>
	enumGconstant<br/>
};<br/>
<br/>
enum EnumM<br/>
{<br/>
	enumMdefault,<br/>
	enumMconstant<br/>
};<br/>
<br/>
enum EnumN<br/>
{<br/>
	enumNplastic,<br/>
	enumNconstant<br/>
};<br/>
<br/>
std::string enumNtoString(const EnumN&amp;);<br/>
EnumN stringToEnumN(const std::string&amp;);<br/>
<br/>
enum EnumP<br/>
{<br/>
	enumPplastic,<br/>
	enumPconstant<br/>
};<br/>
<br/>
enum EnumQ<br/>
{<br/>
	enumQdefault,<br/>
	enumQconstant<br/>
};<br/>
<br/>
<br/>
enum EnumR<br/>
{<br/>
	enumRconstant,<br/>
	enumRlogistic,<br/>
	enumRcosine<br/>
};<br/>
<br/>
enum EnumW<br/>
{<br/>
	enumWzero,<br/>
	enumWuniform<br/>
};<br/>
<br/>
enum EnumReproductionMode<br/>
{<br/>
	enumReproductionModeFraction,<br/>
	enumReproductionModeAmount<br/>
};<br/>
<br/>
enum EnumInitializationMode<br/>
{<br/>
	enumInitializationModeSame,<br/>
	enumInitializationModeUniform<br/>
};<br/>
<br/>
std::string enumInitializationModetoString(const EnumInitializationMode&amp;);<br/>
EnumInitializationMode stringToEnumInitializationMode(const std::string&amp;);<br/>
<br/>
<br/>
<br/>
enum EnumConclusion<br/>
{<br/>
	CcNoError,<br/>
	CcNoOffspringProduced,<br/>
	CcPopExtinct,<br/>
	CcPopSizeTooBig,<br/>
	CcNoffspringTooBigSingleParent,<br/>
	CcNoffspringTooBigAllParents,<br/>
	CcMeanPopSizeSmall,<br/>
	CcMeanPopSizeLarge,<br/>
	CcMeanBodySizeSmall,<br/>
	CcMeanBodySizeLarge,<br/>
	CcChanceToDieSmall,<br/>
	CcChanceToDieLarge,<br/>
	CcFractionBiomassPerOffspringInitialLarge<br/>
};<br/>
<br/>
<br/>
enum EnumErrorCode<br/>
{<br/>
	EcNoError,<br/>
	EcPopExtinct,<br/>
	EcPopSizeTooBig,<br/>
	EcNoffspringTooBigSingleParent,<br/>
	EcNoffspringTooBigAllParents<br/>
};<br/>
<br/>
std::string enumDtoString(const EnumD&amp;);<br/>
std::string enumFtoString(const EnumF&amp;);<br/>
std::string enumGtoString(const EnumG&amp;);<br/>
std::string enumMtoString(const EnumM&amp;);<br/>
std::string enumPtoString(const EnumP&amp;);<br/>
std::string enumQtoString(const EnumQ&amp;);<br/>
std::string enumRtoString(const EnumR&amp;);<br/>
std::string enumWtoString(const EnumW&amp;);<br/>
std::string enumConclusionToString(const EnumConclusion&amp;);<br/>
std::string enumReproductionModeToString(const EnumReproductionMode&amp;);<br/>
<br/>
EnumD stringToEnumD(const std::string&amp;);<br/>
EnumF stringToEnumF(const std::string&amp;);<br/>
EnumG stringToEnumG(const std::string&amp;);<br/>
EnumM stringToEnumM(const std::string&amp;);<br/>
EnumP stringToEnumP(const std::string&amp;);<br/>
EnumQ stringToEnumQ(const std::string&amp;);<br/>
EnumR stringToEnumR(const std::string&amp;);<br/>
EnumW stringToEnumW(const std::string&amp;);<br/>
EnumReproductionMode stringToEnumReproductionMode(const std::string&amp;);<br/>
<br/>
EnumD userInputToEnumD(const int&amp;);<br/>
EnumF userInputToEnumF(const int&amp;);<br/>
EnumG userInputToEnumG(const int&amp;);<br/>
EnumM userInputToEnumM(const int&amp;);<br/>
EnumN userInputToEnumN(const int&amp;);<br/>
EnumP userInputToEnumP(const int&amp;);<br/>
EnumQ userInputToEnumQ(const int&amp;);<br/>
EnumR userInputToEnumR(const int&amp;);<br/>
EnumW userInputToEnumW(const int&amp;);<br/>
EnumReproductionMode userInputToEnumReproductionMode(const int&amp;);<br/>
<br/>
//Misc<br/>
void coutConclusions(std::vector&lt;EnumConclusion&gt;&amp;);<br/>
<br/>
<br/>
<br/>
#endif //#ifndef __ENUMERATIONS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Experiment.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Experiment.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Experiment.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Fri Jun 17 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "Experiment.h"<br/>
//----------------------------------------------------------------------------------<br/>
Experiment::Experiment(const OptionsFile&amp; optionsFile) :<br/>
	mOptionsFile(optionsFile)<br/>
{<br/>
	//How RAII can you get?<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Experiment::execute() const<br/>
{<br/>
	clock_t timeStart = clock();<br/>
<br/>
	#ifdef NDEBUG<br/>
		std::cout &lt;&lt; "Starting experiment in NO DEBUG mode" &lt;&lt; std::endl;<br/>
	#else<br/>
		std::cout &lt;&lt; "Starting experiment in DEBUG mode" &lt;&lt; std::endl;<br/>
	#endif<br/>
	const unsigned int nSims = mOptionsFile.getNsimFiles();<br/>
	std::vector&lt;std::vector&lt;EnumConclusion&gt; &gt; conclusions(nSims);<br/>
	std::vector&lt;MeasurementsTable&gt; measurements(nSims);<br/>
	std::vector&lt;SimulationFile&gt; simFile(nSims);<br/>
	for(unsigned int i=0; i&lt;nSims; ++i)<br/>
	{<br/>
		std::cout &lt;&lt; "\n\nSTARTING SIMULATION "&lt;&lt;i&lt;&lt;"/"&lt;&lt;nSims&lt;&lt;"\n\n";<br/>
		simFile[i]=mOptionsFile.getSimFile(i);<br/>
		const std::auto_ptr&lt;Simulation&gt; pSimulation(new Simulation(mOptionsFile,simFile[i]));<br/>
		pSimulation-&gt;execute(measurements[i],conclusions[i]);<br/>
	}<br/>
	<br/>
	for(unsigned int i=0; i&lt;nSims; ++i) <br/>
	{<br/>
		std::cout &lt;&lt; "\n\nDRAWING CONCLUSIONS "&lt;&lt;i&lt;&lt;"/"&lt;&lt;nSims&lt;&lt;"\n\n";<br/>
		drawConclusions(measurements[i],conclusions[i]);<br/>
		coutConclusions(conclusions[i]);<br/>
	}<br/>
	<br/>
	//Saving measurements in output file<br/>
	if (mOptionsFile.getDoWriteOutputFile()==true) <br/>
	{<br/>
		for (unsigned int i=0; i&lt;nSims; ++i)<br/>
		{<br/>
			const std::string outputFile = mOptionsFile.getOutputFileName(i);<br/>
			measurements[i].saveToSingleFile(outputFile);<br/>
			measurements[i].saveToMultipleFiles(outputFile);<br/>
		}<br/>
	}<br/>
<br/>
	clock_t timeEnd = clock();<br/>
	std::cout &lt;&lt; "Simulation took " &lt;&lt; (difftime(timeEnd,timeStart) / CLK_TCK) &lt;&lt; " seconds." &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "Program ended..." &lt;&lt; std::endl;<br/>
	<br/>
	//Plotting output graphically<br/>
	if (mOptionsFile.getDoPlot()==true) plotMeasurementsTable(measurements);<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Experiment.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Experiment.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Experiment.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Fri Jun 17 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
/// Goal of this class is to do all simulations contained in an OptionsFile<br/>
<br/>
#ifndef __EXPERIMENT_H<br/>
#define __EXPERIMENT_H<br/>
<br/>
#include &lt;time.h&gt;<br/>
#include "OptionsFile.h"<br/>
#include "Simulation.h"<br/>
<br/>
class Experiment<br/>
{<br/>
	public:<br/>
	Experiment(const OptionsFile&amp;);<br/>
	void execute() const;<br/>
<br/>
	private:<br/>
	const OptionsFile mOptionsFile;<br/>
};<br/>
<br/>
#endif //#ifndef __EXPERIMENT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/FunctionsSingleton.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/FunctionsSingleton.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;FunctionsSingleton.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Wed May 25 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "FunctionsSingleton.h"<br/>
//----------------------------------------------------------------------------------<br/>
FunctionsSingleton * FunctionsSingleton::mpInstance = NULL;<br/>
//----------------------------------------------------------------------------------<br/>
FunctionsSingleton::FunctionsSingleton() :<br/>
	mAlpha(0.0),<br/>
	mBeta( 0.0),<br/>
	mGamma(0.0)<br/>
{ <br/>
	const std::auto_ptr&lt;ParameterSetD&gt; paramsD(new ParameterSetD);<br/>
	const std::auto_ptr&lt;ParameterSetF&gt; paramsF(new ParameterSetF);<br/>
	const std::auto_ptr&lt;ParameterSetG&gt; paramsG(new ParameterSetG);<br/>
	const std::auto_ptr&lt;ParameterSetM&gt; paramsM(new ParameterSetM);<br/>
	const std::auto_ptr&lt;ParameterSetN&gt; paramsN(new ParameterSetN);<br/>
	const std::auto_ptr&lt;ParameterSetP&gt; paramsP(new ParameterSetP);<br/>
	const std::auto_ptr&lt;ParameterSetQ&gt; paramsQ(new ParameterSetQ);<br/>
	const std::auto_ptr&lt;ParameterSetR&gt; paramsR(new ParameterSetR);<br/>
	const std::auto_ptr&lt;ParameterSetW&gt; paramsW(new ParameterSetW);<br/>
	mpD.reset(new StrategyDdefault(paramsD.get()));<br/>
	mpF.reset(new StrategyFdefault(paramsF.get()));<br/>
	mpG.reset(new StrategyGconstant(paramsG.get()));<br/>
	mpM.reset(new StrategyMdefault(paramsM.get()));<br/>
	mpN.reset(new StrategyNplastic(paramsN.get()));<br/>
	mpP.reset(new StrategyPconstant(paramsP.get()));<br/>
	mpQ.reset(new StrategyQdefault(paramsQ.get()));<br/>
	mpR.reset(new StrategyRconstant(paramsR.get()));<br/>
	mpW.reset(new StrategyWzero(paramsW.get()));<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
FunctionsSingleton * FunctionsSingleton::instance()<br/>
{<br/>
	if (mpInstance==NULL) mpInstance = new FunctionsSingleton();<br/>
	return mpInstance;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
std::vector&lt;double&gt; FunctionsSingleton::distributeResources(const std::vector&lt;double&gt;&amp; popBodySize, const double&amp; totalResources) const <br/>
{<br/>
	const unsigned int popSize = popBodySize.size();<br/>
	const double equalShare = totalResources / static_cast&lt;double&gt;(popSize);<br/>
	std::vector&lt;double&gt; resource(popSize);<br/>
<br/>
	double sumResources = 0.0;<br/>
	for(unsigned int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		resource[i] = W(popBodySize[i],equalShare);<br/>
		sumResources+=resource[i];<br/>
	}<br/>
	<br/>
	if (sumResources&gt;totalResources)<br/>
	{<br/>
		//Scale down<br/>
		const double scale = totalResources / sumResources;<br/>
		assert(scale&lt;1.0);<br/>
		for(unsigned int i=0; i&lt;popSize; ++i) <br/>
		{<br/>
			resource[i] *= scale;<br/>
		}<br/>
	}<br/>
<br/>
	#ifndef NDEBUG<br/>
	//Check again to be sure<br/>
	double sumResourcesDebug = 0.0;<br/>
	for(unsigned int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		sumResources+=resource[i];<br/>
	}<br/>
	assert(sumResourcesDebug&lt;=sumResources);<br/>
	#endif<br/>
	<br/>
	return resource;<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setD(const EnumD&amp; enumD, const ParameterSetD* params)<br/>
{<br/>
	switch (enumD)<br/>
	{<br/>
		case enumDdefault&nbsp;&nbsp;: mpD.reset(new StrategyDdefault(params)); return;<br/>
		//case enumDsizeOnly : mpD.reset(new StrategyDsizeOnly(params)); return;<br/>
		//case enumDconstant : mpD.reset(new StrategyDconstant(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setD(const EnumD&amp; enumD, const ParameterSet&amp; params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setF(const EnumF&amp; enumF, const ParameterSetF* params)<br/>
{<br/>
	switch (enumF)<br/>
	{<br/>
		//case enumFgauss&nbsp;&nbsp;&nbsp;&nbsp;: mpF.reset(new StrategyFgauss(params)); return;<br/>
		case enumFdefault&nbsp;&nbsp;: mpF.reset(new StrategyFdefault(params)); return;<br/>
		//case enumFconstant : mpF.reset(new StrategyFconstant(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setF(const EnumF&amp; enumF, const ParameterSet&amp; params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setG(const EnumG&amp; enumG, const ParameterSetG* params)<br/>
{<br/>
	switch (enumG)<br/>
	{<br/>
		case enumGplastic&nbsp;&nbsp;: mpG.reset(new StrategyGplastic(params)); return;<br/>
		case enumGconstant : mpG.reset(new StrategyGconstant(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setG(const EnumG&amp; enumG, const ParameterSet&amp; params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setM(const EnumM&amp; enumM, const ParameterSetM* params)<br/>
{<br/>
	switch (enumM)<br/>
	{<br/>
		case enumMdefault : mpM.reset(new StrategyMdefault(params)); return;<br/>
		case enumMconstant: mpM.reset(new StrategyMconstant(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setM(const EnumM&amp; enumM, const ParameterSetM&amp; params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setN(const EnumN&amp; enumN, const ParameterSetN* params)<br/>
{<br/>
	switch (enumN)<br/>
	{<br/>
		case enumNplastic&nbsp;&nbsp;: mpN.reset(new StrategyNplastic(params)); return;<br/>
		case enumNconstant : mpN.reset(new StrategyNconstant(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setN(const EnumN&amp; enumN, const ParameterSetN&amp; params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setP(const EnumP&amp; enumP, const ParameterSetP* params)<br/>
{<br/>
	switch (enumP)<br/>
	{<br/>
		case enumPplastic&nbsp;&nbsp;: mpP.reset(new StrategyPplastic(params)); return;<br/>
		//case enumPplasticB&nbsp;&nbsp;: mpP.reset(new StrategyPplasticB(params)); return;<br/>
		//case enumPnonPlastic: mpP.reset(new StrategyPnonPlastic(params)); return;<br/>
		case enumPconstant&nbsp;&nbsp;: mpP.reset(new StrategyPconstant(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setP(const EnumP&amp; enumP, const ParameterSet&amp; params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setQ(const EnumQ&amp; enumQ, const ParameterSetQ* params)<br/>
{<br/>
	switch (enumQ)<br/>
	{<br/>
		case enumQdefault: mpQ.reset(new StrategyQdefault(params)); return;<br/>
		case enumQconstant: mpQ.reset(new StrategyQconstant(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setQ(const EnumQ&amp; enumQ, const ParameterSet&amp; params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setR(const EnumR&amp; enumR, const ParameterSetR* params)<br/>
{<br/>
	switch (enumR)<br/>
	{<br/>
		case enumRconstant: mpR.reset(new StrategyRconstant(params)); return;<br/>
		case enumRlogistic: mpR.reset(new StrategyRlogistic(params)); return;<br/>
		case enumRcosine&nbsp;&nbsp;: mpR.reset(new StrategyRcosine(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setR(const EnumR&amp; enumR, const ParameterSet&amp; params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setW(const EnumW&amp; enumW, const ParameterSetW* params)<br/>
{<br/>
	switch(enumW)<br/>
	{<br/>
		case enumWzero: mpW.reset(new StrategyWzero(params)); return;<br/>
		case enumWuniform: mpW.reset(new StrategyWuniform(params)); return;<br/>
	}<br/>
	processError("void FunctionsSingleton::setW(const EnumW&amp; enumW, const ParameterSetW* params)");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setAlpha(double A)<br/>
{<br/>
	if (A&lt;=0.0) <br/>
	{<br/>
		std::cout &lt;&lt; "WARNING! A&lt;=0.0! Set to 1.0." &lt;&lt; std::endl;<br/>
		A = 1.0;<br/>
	}<br/>
	mAlpha = A;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setBeta(double B)<br/>
{<br/>
	if (B&lt;=0.0) <br/>
	{<br/>
		std::cout &lt;&lt; "WARNING! B&lt;=0.0! Set to 1.0." &lt;&lt; std::endl;<br/>
		B = 1.0;<br/>
	}<br/>
	mBeta = B;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::setGamma(double C)<br/>
{<br/>
	if (C&lt;=0.0) <br/>
	{<br/>
		std::cout &lt;&lt; "WARNING! A&lt;=0.0! Set to 1.0." &lt;&lt; std::endl;<br/>
		C = 1.0;<br/>
	}<br/>
	mGamma = C;<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::coutAll() const<br/>
{<br/>
	std::cout &lt;&lt; getD() &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; getF() &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; getG() &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; getM() &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; getN() &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; getP() &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; getQ() &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; getR() &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; getW() &lt;&lt; std::endl;<br/>
	<br/>
	std::cout &lt;&lt; "Alpha: " &lt;&lt; mAlpha &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "Beta: "&nbsp;&nbsp;&lt;&lt; mBeta&nbsp;&nbsp;&lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "Gamma: " &lt;&lt; mGamma &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void FunctionsSingleton::processError(const std::string&amp; errorMessage) const<br/>
{<br/>
	std::cout &lt;&lt; "ERROR!!!" &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "Message: " &lt;&lt; errorMessage &lt;&lt; std::endl;<br/>
	std::exit(1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/FunctionsSingleton.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/FunctionsSingleton.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;FunctionsSingleton.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Wed May 25 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
///The function of FunctionsSingleton is to embody all formulae used in the simulation<br/>
///<br/>
///To be sure a simulation has only one set of formulae, I used the Singleton pattern (ref. 1).<br/>
///The different kinds of functions it can contain, are put in the Strategy Pattern (ref. 1).<br/>
///The Strategy pattern uses polymorphism, therefore a pointer to the derived Strategy class.<br/>
///Instead of the standard 'evil' pointer, I used the std::auto_ptr (ref. 2)<br/>
///<br/>
///The FunctionsSingleton is default initialized and later it is set with an SimulationFile.<br/>
///The SoilMite class has a static pointer to FunctionsSingleton, so all individuals always have the same mathematical behaviour<br/>
///Before the class Experiment executes a Simulation, it changes the FunctionsSingleton with a SimulationFile.<br/>
///<br/>
///<br/>
///References:<br/>
///1) Design Patterns. By Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. ISBN: 0-201-63361-2<br/>
///2) Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions. By Herb Sutter. ISBN: 0-201-61562-2<br/>
<br/>
#ifndef __FUNCTIONS_SINGLETON_H<br/>
#define __FUNCTIONS_SINGLETON_H<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;memory&gt;<br/>
#include &lt;string&gt;<br/>
<br/>
#include "StrategyD.h"<br/>
#include "StrategyF.h"<br/>
#include "StrategyG.h"<br/>
#include "StrategyM.h"<br/>
#include "StrategyN.h"<br/>
#include "StrategyP.h"<br/>
#include "StrategyQ.h"<br/>
#include "StrategyR.h"<br/>
#include "StrategyW.h"<br/>
<br/>
#include "Enumerations.h"<br/>
#include "HelperFunctions.h"<br/>
#include "SimulationFile.h"<br/>
#include "random.h"<br/>
<br/>
class FunctionsSingleton<br/>
{<br/>
	public:<br/>
	static FunctionsSingleton * instance();<br/>
<br/>
	double D(const double&amp; s, const double&amp; v) const { assert(mpD.get()!=NULL); return mpD-&gt;eval(s,v); }<br/>
	double F(const double&amp; r, const double&amp; s) const { assert(mpF.get()!=NULL); return mpF-&gt;eval(r,s); }<br/>
	double G(const double&amp; f, const double&amp; v) const { assert(mpG.get()!=NULL); return mpG-&gt;eval(f,v); }<br/>
	double M(const double&amp; s, const double&amp; v) const { assert(mpM.get()!=NULL); return mpM-&gt;eval(s,v); }<br/>
	double N(const double&amp; f, const double&amp; v) const { assert(mpN.get()!=NULL); return mpN-&gt;eval(f,v); }<br/>
	double P(const double&amp; f, const double&amp; v) const { assert(mpP.get()!=NULL); return mpP-&gt;eval(f,v); }<br/>
	double Q(const double&amp; v) const { assert(mpQ.get()!=NULL); return mpQ-&gt;eval(v); }<br/>
	double R(const double&amp; x, const double&amp; t) const { assert(mpR.get()!=NULL); return mpR-&gt;eval(x,t); }<br/>
	double W(const double&amp; s, const double&amp; equalShare) const { assert(mpW.get()!=NULL); return mpW-&gt;eval(s,equalShare); }<br/>
<br/>
	std::vector&lt;double&gt; FunctionsSingleton::distributeResources(const std::vector&lt;double&gt;&amp;, const double&amp;) const;<br/>
	/* 01-08-2005: Replaced by eval()<br/>
	void distributeResources(const double&amp; totalResources, std::vector&lt;double&gt;&amp; vectorResources) const <br/>
	{ <br/>
		mpW-&gt;distributeResources(totalResources, vectorResources);<br/>
	}*/<br/>
<br/>
	//Setting functions and their parameters<br/>
	void setD(const EnumD&amp;, const ParameterSetD*);<br/>
	void setF(const EnumF&amp;, const ParameterSetF*);<br/>
	void setG(const EnumG&amp;, const ParameterSetG*);<br/>
	void setM(const EnumM&amp;, const ParameterSetM*);<br/>
	void setN(const EnumN&amp;, const ParameterSetN*);<br/>
	void setP(const EnumP&amp;, const ParameterSetP*);<br/>
	void setQ(const EnumQ&amp;, const ParameterSetQ*);<br/>
	void setR(const EnumR&amp;, const ParameterSetR*);<br/>
	void setW(const EnumW&amp;, const ParameterSetW*);<br/>
<br/>
	//Getting the formulas<br/>
	std::string getD() const { return mpD-&gt;getString(); }<br/>
	std::string getF() const { return mpF-&gt;getString(); }<br/>
	std::string getG() const { return mpG-&gt;getString(); }<br/>
	std::string getM() const { return mpM-&gt;getString(); }<br/>
	std::string getN() const { return mpN-&gt;getString(); }<br/>
	std::string getP() const { return mpP-&gt;getString(); }<br/>
	std::string getQ() const { return mpQ-&gt;getString(); }<br/>
	std::string getR() const { return mpR-&gt;getString(); }<br/>
	std::string getW() const { return mpW-&gt;getString(); }<br/>
<br/>
	//Getting the formulas<br/>
	std::string getD(const double&amp; s, const double&amp; v) const { return mpD-&gt;getString(s,v); }<br/>
	std::string getF(const double&amp; r, const double&amp; s) const { return mpF-&gt;getString(r,s); }<br/>
	std::string getG(const double&amp; f, const double&amp; v) const { return mpG-&gt;getString(f,v); }<br/>
	std::string getM(const double&amp; s, const double&amp; v) const { return mpM-&gt;getString(s,v); }<br/>
	std::string getN(const double&amp; f, const double&amp; v) const { return mpN-&gt;getString(f,v); }<br/>
	std::string getP(const double&amp; f, const double&amp; v) const { return mpP-&gt;getString(f,v); }<br/>
	std::string getQ(const double&amp; v) const { return mpQ-&gt;getString(v); }<br/>
	std::string getR(const double&amp; x, const double&amp; t) const { return mpR-&gt;getString(x,t); }<br/>
<br/>
	//Environmental parameters<br/>
	double getAlpha() const { return mAlpha; }<br/>
	double getBeta()&nbsp;&nbsp;const { return mBeta ; }<br/>
	double getGamma() const { return mGamma; }<br/>
	void setAlpha(double);<br/>
	void setBeta( double);<br/>
	void setGamma(double);<br/>
<br/>
	//Misc<br/>
	void coutAll() const;<br/>
	<br/>
	protected:<br/>
	FunctionsSingleton();<br/>
<br/>
	private:<br/>
	static FunctionsSingleton * mpInstance;<br/>
	<br/>
	std::auto_ptr&lt;StrategyDbase&gt; mpD;<br/>
	std::auto_ptr&lt;StrategyFbase&gt; mpF;<br/>
	std::auto_ptr&lt;StrategyGbase&gt; mpG;<br/>
	std::auto_ptr&lt;StrategyMbase&gt; mpM;<br/>
	std::auto_ptr&lt;StrategyNbase&gt; mpN;<br/>
	std::auto_ptr&lt;StrategyPbase&gt; mpP;<br/>
	std::auto_ptr&lt;StrategyQbase&gt; mpQ;<br/>
	std::auto_ptr&lt;StrategyRbase&gt; mpR;<br/>
	std::auto_ptr&lt;StrategyWbase&gt; mpW;<br/>
<br/>
	double mAlpha, mBeta, mGamma;<br/>
<br/>
	<br/>
	//Misc<br/>
	void processError(const std::string&amp;) const;<br/>
<br/>
};<br/>
<br/>
#endif //#ifndef __FUNCTIONS_SINGLETON_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Gnuplot.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Gnuplot.cpp" border = "1"><tr><td><code>
//<br/>
//&nbsp;&nbsp;Gnuplot - a C++ class interface with Gnuplot<br/>
//<br/>
//<br/>
//&nbsp;&nbsp;Created by Richel Bilderbeek on Fri Jun 10 2005.<br/>
//&nbsp;&nbsp;Open source.<br/>
//<br/>
//&nbsp;&nbsp;Richel Bilderbeek<br/>
//&nbsp;&nbsp;Vinkenstraat 54b<br/>
//&nbsp;&nbsp;9713 TJ Groningen<br/>
//&nbsp;&nbsp;The Netherlands<br/>
//&nbsp;&nbsp;(0031)-(0)50-3115529<br/>
//&nbsp;&nbsp;E-mail: richelbilderbeek@fastmail.fm<br/>
//&nbsp;&nbsp;<br/>
//&nbsp;&nbsp;Feel free to contact me when having made additional functionality or<br/>
//&nbsp;&nbsp;have outsmarted me on this interface<br/>
//<br/>
//----------------------------------------------------------------------------------<br/>
#include "Gnuplot.h"<br/>
//----------------------------------------------------------------------------------<br/>
//#define EXTENSIVE_LOG<br/>
//----------------------------------------------------------------------------------<br/>
unsigned int Gnuplot::mTempFileNumber = 0;<br/>
//----------------------------------------------------------------------------------<br/>
Gnuplot::Gnuplot() :<br/>
	mGnuPipe(NULL),<br/>
	mTerminal("X11"),<br/>
	mStyle("lines"),<br/>
	mCurrentWindowNumber(0),<br/>
	mMaxCommandSize(4096)<br/>
{<br/>
	const std::string fileName = readFileName();<br/>
	if (fileExists(fileName)==false)<br/>
	{<br/>
		std::cout &lt;&lt; "\nGnuplot location was not found"<br/>
			&lt;&lt; "\nTherefore, change the line in 'GnuplotLocation.txt"<br/>
			&lt;&lt; "\nto your Gnuplot location.\n";<br/>
		exit(1);<br/>
	}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mGnuPipe = popen((fileName+" -persist").c_str(),"w");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mGnuPipe==NULL) assert(!"Couldn't open connection to gnuplot");<br/>
	setLineStyles();<br/>
	addWindow();<br/>
	changeWindow(0);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///This reads the location of Gnuplot from the config file called GnuplotLocation.txt<br/>
///If it cannot find this file, it is created with a default value<br/>
std::string Gnuplot::readFileName() const<br/>
{<br/>
	const std::string fileName = "GnuplotLocation.txt";<br/>
	std::string returnFileName;<br/>
	if (fileExists(fileName)==true)<br/>
	{<br/>
		std::ifstream file(fileName.c_str());<br/>
		assert(file.is_open()==true);<br/>
		file &gt;&gt; returnFileName;<br/>
		file.close();<br/>
	}<br/>
	else<br/>
	{<br/>
		std::ofstream file(fileName.c_str());<br/>
		assert(file.is_open()==true);<br/>
		returnFileName ="/sw/bin/gnuplot";<br/>
		file &lt;&lt; returnFileName &lt;&lt; '\n';<br/>
		file.close();<br/>
	}<br/>
	return returnFileName;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
Gnuplot::~Gnuplot()<br/>
{<br/>
	const unsigned int nWindows = mWindowData.size();<br/>
	for(unsigned i=0; i&lt;nWindows; ++i)<br/>
	{<br/>
		mCurrentWindowNumber = i;<br/>
		emptyPlot();<br/>
	}<br/>
	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (pclose(mGnuPipe) == -1) assert(!"Problem closing communication to Gnuplot");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::emptyPlot()<br/>
{&nbsp;&nbsp;&nbsp;&nbsp; <br/>
	const unsigned int nPlots = mWindowData[mCurrentWindowNumber].tempFileName.size();<br/>
	for (unsigned int i=0; i&lt;nPlots; ++i)<br/>
	{<br/>
		dot("Removing file: " + mWindowData[mCurrentWindowNumber].tempFileName[i]);<br/>
		remove(mWindowData[mCurrentWindowNumber].tempFileName[i].c_str());<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Fiund out more terminal types using 'set terminal' in Gnuplot<br/>
void Gnuplot::setTerminal(const GnuplotTerminal&amp; terminal)<br/>
{<br/>
	switch(terminal)<br/>
	{<br/>
		case terminalAqua : mTerminal = "aqua"; break;<br/>
		case terminalX11&nbsp;&nbsp;: mTerminal = "x11" ; break;<br/>
		default: assert(!"Unknown GnuplotTerminal");<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::setStyle(const GnuplotStyle&amp; style)<br/>
{<br/>
	switch(style)<br/>
	{<br/>
		case styleLines&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: mStyle = "lines"; break;<br/>
		case stylePoints&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : mStyle = "points"; break;<br/>
		case styleLinespoints&nbsp;&nbsp;: mStyle = "linespoints"; break;<br/>
		case styleImpulses&nbsp;&nbsp;&nbsp;&nbsp; : mStyle = "impulses"; break;<br/>
		case styleDots&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : mStyle = "dots"; break;<br/>
		case styleSteps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: mStyle = "steps"; break;<br/>
		case styleErrorbars&nbsp;&nbsp;&nbsp;&nbsp;: mStyle = "errorbars"; break;<br/>
		case styleBoxes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: mStyle = "boxes"; break;<br/>
		case styleBoxerrorbars : mStyle = "boxerrorbars"; break;<br/>
		default: assert(!"Unknown GnuplotStyle"); <br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::execute(const std::string&amp; cmdstr) const<br/>
{<br/>
	dot("Command sent to Gnuplot: " + static_cast&lt;std::string&gt;(cmdstr));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fputs((cmdstr+"\n").c_str(),mGnuPipe);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fflush(mGnuPipe);<br/>
	usleep(150000);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::setYlabel(const std::string&amp; label)<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string command = "set ylabel \""+label+"\"";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;execute(command.c_str());<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::setXlabel(const std::string&amp; label)<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string command = "set xlabel \""+label+"\"";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;execute(command.c_str());<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Change to plotting windows to 'windowNumber'. If this window number is beyond<br/>
///the amount of windows created, a new window will be created and that window<br/>
///will be set as the plotting window<br/>
void Gnuplot::changeWindow(const unsigned int&amp; windowNumber)<br/>
{<br/>
	if (windowNumber==mCurrentWindowNumber) return;<br/>
	if (windowNumber&gt;=mWindowData.size()) <br/>
	{<br/>
		addWindow();<br/>
		mCurrentWindowNumber = mWindowData.size()-1;<br/>
	}<br/>
	else<br/>
	{<br/>
		mCurrentWindowNumber=windowNumber;<br/>
	}<br/>
	const std::string myCommand = "set terminal "+mTerminal+" "+itoa(mCurrentWindowNumber+1);<br/>
	execute(myCommand.c_str());<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Creates an extra 'nWindows' display windows. <br/>
void Gnuplot::addWindow(const unsigned int&amp; nWindows)<br/>
{<br/>
	for (unsigned int i=0; i&lt;nWindows; ++i)<br/>
	{<br/>
		WindowData temp;<br/>
		mWindowData.push_back(temp);<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::plot(const std::string &amp;equation, const std::string &amp;title)<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string myCommand;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (mWindowData[mCurrentWindowNumber].tempFileName.size() &gt; 0)<br/>
		myCommand = "replot " + equation + " title \"" + title + "\" with " + mStyle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
		myCommand = "plot " + equation + " title \"" + title + "\" with " + mStyle;<br/>
<br/>
	execute(myCommand.c_str());<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::plot(const std::vector&lt;double&gt;&amp; x, const std::string &amp;title)<br/>
{<br/>
	const std::string tempFileName = createTempFileName();<br/>
	createTempFile(tempFileName,x);<br/>
	plotTempFile2D(tempFileName,title);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::plot(const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y, const std::string &amp;title)<br/>
{<br/>
	const std::string tempFileName = createTempFileName();<br/>
	createTempFile(tempFileName,x,y);<br/>
	plotTempFile2D(tempFileName,title);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::plot(const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y, const std::vector&lt;double&gt;&amp; z, const std::string &amp;title)<br/>
{<br/>
	const std::string tempFileName = createTempFileName();<br/>
&nbsp;&nbsp; 	createTempFile(tempFileName,x,y,z);<br/>
	plotTempFile3D(tempFileName,title);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::plotTempFile2D(const std::string&amp; tempFileName, const std::string&amp; title)<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string myCommand;<br/>
	const unsigned int nSerie = mWindowData[mCurrentWindowNumber].tempFileName.size();<br/>
	//Linestyles are nice, but don't work on my terminal...<br/>
	///if (nSerie&gt;12) std::cout &lt;&lt; "MAKE MORE LINESTYLES!!!" &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//if ( nSerie== 0)<br/>
	//	myCommand = "plot \"" + tempFileName + "\" ls "+itoa(nSerie)+" title \"" + title + "\" with " + mStyle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//else<br/>
	//	myCommand = "replot \"" + tempFileName + "\" ls "+itoa(nSerie)+" title \"" + title + "\" with " + mStyle;<br/>
	<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( nSerie== 0)<br/>
		myCommand = "plot \"" + tempFileName + "\" title \"" + title + "\" with " + mStyle;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
		myCommand = "replot \"" + tempFileName + "\" title \"" + title + "\" with " + mStyle;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;execute(myCommand.c_str());<br/>
	usleep(500000);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mWindowData[mCurrentWindowNumber].tempFileName.push_back(tempFileName);<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::plotTempFile3D(const std::string&amp; tempFileName, const std::string&amp; title)<br/>
{<br/>
	//Does not work on my computer. Should be something like this...<br/>
	execute("set pm3d");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string myCommand;<br/>
&nbsp;&nbsp; if (mWindowData[mCurrentWindowNumber].tempFileName.size() == 0)<br/>
		myCommand = "splot \"" + tempFileName + "\" title \"" + title + "\" with pm3d palette";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
		myCommand = "replot \"" + tempFileName + "\" title \"" + title + "\" with pm3d palette";<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;execute(myCommand.c_str());<br/>
	usleep(500000);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mWindowData[mCurrentWindowNumber].tempFileName.push_back(tempFileName);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
std::string Gnuplot::createTempFileName()<br/>
{<br/>
	++mTempFileNumber;<br/>
	const std::string tempFileName = "GnuplotTemp"+itoa(mTempFileNumber);<br/>
	dot("Created temp file '" + tempFileName);<br/>
	return(tempFileName);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::createTempFile(const std::string&amp; tempFileName, const std::vector&lt;double&gt;&amp; x)<br/>
{<br/>
	std::ofstream file(tempFileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	const unsigned int size = x.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i = 0; i &lt; size; i++) file &lt;&lt; x[i] &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;file.close();<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::createTempFile(const std::string&amp; tempFileName, const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y)<br/>
{<br/>
	assert(x.size()==y.size());<br/>
<br/>
	std::ofstream file(tempFileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	const unsigned int size = x.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i = 0; i &lt; size; i++) file &lt;&lt; x[i] &lt;&lt; " " &lt;&lt; y[i] &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::createTempFile(const std::string&amp; tempFileName, const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y, const std::vector&lt;double&gt;&amp; z)<br/>
{<br/>
	assert(x.size()==y.size());<br/>
	assert(y.size()==z.size());<br/>
<br/>
	std::ofstream file(tempFileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	const unsigned int size = x.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (unsigned int i = 0; i &lt; size; i++) file &lt;&lt; x[i] &lt;&lt; " " &lt;&lt; y[i] &lt;&lt; " " &lt;&lt; z[i] &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Gnuplot::setLineStyles()<br/>
{<br/>
	//Does not work on all terminals. Like mine... :-(<br/>
	//execute("set style line&nbsp;&nbsp;1 lt pal frac 0.0 lw 2");<br/>
	//execute("set style line&nbsp;&nbsp;2 lt pal frac 0.0 lw 4");<br/>
	//execute("set style line&nbsp;&nbsp;3 lt pal frac 0.2 lw 2");<br/>
	//execute("set style line&nbsp;&nbsp;4 lt pal frac 0.2 lw 4");<br/>
	//execute("set style line&nbsp;&nbsp;5 lt pal frac 0.4 lw 2");<br/>
	//execute("set style line&nbsp;&nbsp;6 lt pal frac 0.4 lw 4");<br/>
	//execute("set style line&nbsp;&nbsp;7 lt pal frac 0.6 lw 2");<br/>
	//execute("set style line&nbsp;&nbsp;8 lt pal frac 0.6 lw 4");<br/>
	//execute("set style line&nbsp;&nbsp;9 lt pal frac 0.8 lw 2");<br/>
	//execute("set style line 10 lt pal frac 0.8 lw 4");<br/>
	//execute("set style line 11 lt pal frac 1.0 lw 2");<br/>
	//execute("set style line 12 lt pal frac 1.0 lw 4");<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Logging when in developmental phase<br/>
void Gnuplot::dot(const std::string&amp; debugString) const<br/>
{<br/>
	#ifdef EXTENSIVE_LOG<br/>
	std::cout &lt;&lt; "DOT: " &lt;&lt; debugString &lt;&lt; std::endl;<br/>
	#endif<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Converts an integer to a string<br/>
std::string Gnuplot::itoa(const int&amp; number) const<br/>
{<br/>
	std::ostringstream o;<br/>
	if (!(o &lt;&lt; number)) { assert(!"ERROR in itoa"); exit(1); }<br/>
	return o.str();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Converts a double to a string<br/>
std::string Gnuplot::ftoa(const double&amp; number) const<br/>
{<br/>
	std::ostringstream o;<br/>
	if (!(o &lt;&lt; number)) { assert(!"ERROR in ftoa"); exit(1); }<br/>
	return o.str();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Checks if a file exists<br/>
bool Gnuplot::fileExists(const std::string&amp; fileName) const<br/>
{<br/>
	std::fstream fin;<br/>
	fin.open(fileName.c_str(),std::ios::in);<br/>
	if( fin.is_open() )<br/>
	{<br/>
		fin.close();<br/>
		return true;<br/>
	}<br/>
	fin.close();<br/>
	return false;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Gnuplot.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Gnuplot.h" border = "1"><tr><td><code>
//<br/>
//&nbsp;&nbsp;Gnuplot - a C++ class interface with Gnuplot<br/>
//<br/>
//<br/>
//&nbsp;&nbsp;Created by Richel Bilderbeek on Fri Jun 10 2005.<br/>
//&nbsp;&nbsp;Open source.<br/>
//<br/>
//&nbsp;&nbsp;Richel Bilderbeek<br/>
//&nbsp;&nbsp;Vinkenstraat 54b<br/>
//&nbsp;&nbsp;9713 TJ Groningen<br/>
//&nbsp;&nbsp;The Netherlands<br/>
//&nbsp;&nbsp;(0031)-(0)50-3115529<br/>
//&nbsp;&nbsp;E-mail: richelbilderbeek@fastmail.fm<br/>
//&nbsp;&nbsp;<br/>
//&nbsp;&nbsp;Feel free to contact me when having made additional functionality or<br/>
//&nbsp;&nbsp;have outsmarted me on this interface<br/>
// <br/>
//<br/>
<br/>
#ifndef __GNUPLOT_H<br/>
#define __GNUPLOT_H<br/>
<br/>
#include &lt;string&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;sstream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert.h&gt;<br/>
<br/>
enum GnuplotStyle<br/>
{<br/>
	styleLines,<br/>
	stylePoints,<br/>
	styleLinespoints,<br/>
	styleImpulses,<br/>
	styleDots,<br/>
	styleSteps,<br/>
	styleErrorbars,<br/>
	styleBoxes,<br/>
	styleBoxerrorbars,<br/>
};<br/>
<br/>
///Fiund out more terminal types using 'set terminal' in Gnuplot<br/>
enum GnuplotTerminal<br/>
{<br/>
	terminalX11,<br/>
	terminalAqua<br/>
};<br/>
<br/>
struct WindowData<br/>
{<br/>
	std::vector&lt;std::string&gt; tempFileName;<br/>
};<br/>
<br/>
class Gnuplot<br/>
{<br/>
	private:<br/>
	FILE * mGnuPipe;<br/>
	std::string mTerminal;<br/>
	std::string mStyle;<br/>
	std::vector&lt;WindowData&gt; mWindowData;<br/>
	unsigned int mCurrentWindowNumber;<br/>
	const unsigned int mMaxCommandSize;<br/>
	static unsigned int mTempFileNumber;<br/>
<br/>
	void setLineStyles();<br/>
	std::string readFileName() const;<br/>
	std::string createTempFileName();<br/>
	void createTempFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;);<br/>
	void createTempFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;);<br/>
	void createTempFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;);<br/>
	void plotTempFile2D(const std::string&amp;, const std::string&amp;);<br/>
	void plotTempFile3D(const std::string&amp;, const std::string&amp;);<br/>
<br/>
	void dot(const std::string&amp; debugString = ".") const;<br/>
	<br/>
	public:<br/>
	Gnuplot();<br/>
	~Gnuplot();<br/>
<br/>
	void execute(const std::string&amp;) const;<br/>
<br/>
	void addWindow(const unsigned int&amp; nWindows = 1);<br/>
	void changeWindow(const unsigned int&amp;);<br/>
	<br/>
	void setTerminal(const GnuplotTerminal&amp;);<br/>
	void setStyle(const GnuplotStyle&amp;);<br/>
	void setYlabel(const std::string&amp;);<br/>
	void setXlabel(const std::string&amp;);<br/>
<br/>
	void plot(const std::string &amp;, const std::string&amp; title = "y");<br/>
	void plot(const std::vector&lt;double&gt;&amp;, const std::string&amp; title = "y");<br/>
	void plot(const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;, const std::string&amp; title = "data");<br/>
	void plot(const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;, const std::vector&lt;double&gt;&amp;, const std::string&amp; title = "z");<br/>
<br/>
	void emptyPlot();<br/>
<br/>
	//Helper functions<br/>
	std::string itoa(const int&amp;) const;<br/>
	std::string ftoa(const double&amp;) const;<br/>
	bool fileExists(const std::string&amp; fileName) const;<br/>
<br/>
	<br/>
};<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/GnuplotLocation.txt</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/GnuplotLocation.txt" border = "1"><tr><td><code>
/Volumes/Gnufink/sw/bin/gnuplot<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/HelperFunctions.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/HelperFunctions.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;HelperFunctions.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 24 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
//----------------------------------------------------------------------------------<br/>
#include "HelperFunctions.h"<br/>
//----------------------------------------------------------------------------------<br/>
//void dot(const std::string&amp; debugMessage)<br/>
//{<br/>
//	#ifndef NDOT<br/>
//	std::cout &lt;&lt; debugMessage &lt;&lt; std::endl;<br/>
//	#endif<br/>
//}<br/>
//----------------------------------------------------------------------------------<br/>
//void cout(const std::string&amp; outputMessage)<br/>
//{<br/>
//	std::cout &lt;&lt; outputMessage &lt;&lt; std::endl;<br/>
//}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b)<br/>
{<br/>
&nbsp;&nbsp;return (a&lt;b?a:b);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b, const T&amp; c)<br/>
{<br/>
&nbsp;&nbsp;const T temp = min(a,b);<br/>
&nbsp;&nbsp;return (temp&lt;c? temp:c);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b, const T&amp; c, const T&amp; d)<br/>
{<br/>
&nbsp;&nbsp;const T temp = min(a,b,c);<br/>
&nbsp;&nbsp;return (temp&lt;d? temp:d);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b, const T&amp; c, const T&amp; d, const T&amp; e)<br/>
{<br/>
&nbsp;&nbsp;const T temp = min(a,b,c,d);<br/>
&nbsp;&nbsp;return (temp&lt;e? temp:e);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b, const T&amp; c, const T&amp; d, const T&amp; e, const T&amp; f)<br/>
{<br/>
&nbsp;&nbsp;const T temp = min(a,b,c,d,e);<br/>
&nbsp;&nbsp;return (temp&lt;f? temp:f);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b, const T&amp; c, const T&amp; d, const T&amp; e, const T&amp; f, const T&amp; g)<br/>
{<br/>
&nbsp;&nbsp;const T temp = min(a,b,c,d,e,f);<br/>
&nbsp;&nbsp;return (temp&lt;g? temp:g);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b, const T&amp; c, const T&amp; d, const T&amp; e, const T&amp; f, const T&amp; g, const T&amp; h)<br/>
{<br/>
&nbsp;&nbsp;const T temp = min(a,b,c,d,e,f,g);<br/>
&nbsp;&nbsp;return (temp&lt;h? temp:h);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b, const T&amp; c, const T&amp; d, const T&amp; e, const T&amp; f, const T&amp; g, const T&amp; h, const T&amp; i)<br/>
{<br/>
&nbsp;&nbsp;const T temp = min(a,b,c,d,e,f,g,h);<br/>
&nbsp;&nbsp;return (temp&lt;i? temp:i);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp; a, const T&amp; b, const T&amp; c, const T&amp; d, const T&amp; e, const T&amp; f, const T&amp; g, const T&amp; h, const T&amp; i, const T&amp; j)<br/>
{<br/>
&nbsp;&nbsp;const T temp = min(a,b,c,d,e,f,g,h,i);<br/>
&nbsp;&nbsp;return (temp&lt;j? temp:j);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
/// Determines the mean and standard deviation of an array<br/>
/// Returns whether successfull<br/>
template &lt;class T&gt;<br/>
bool SafeMeanAndStdDev(const T * pArray, const int&amp; arraysize, double &amp;rMean, double &amp;rStdDev)<br/>
{<br/>
	if (arraysize&gt;1)<br/>
	{<br/>
		double Sum=0.0, SumSquared=0.0;<br/>
		for (int counter=0;counter&lt;arraysize;++counter)<br/>
		{<br/>
			Sum+=pArray[counter];<br/>
			SumSquared+=(pArray[counter]*pArray[counter]);<br/>
		}//Next counter<br/>
		rMean=(Sum/arraysize);<br/>
		//Safe part:<br/>
		double numerator=((arraysize*SumSquared)-(Sum*Sum));<br/>
		if (numerator&lt;0) {numerator=0;}<br/>
		rStdDev=sqrt(numerator/(arraysize*(arraysize-1)));<br/>
		return true;<br/>
	}<br/>
	else<br/>
	{<br/>
		rMean = 0.0; <br/>
		rStdDev = 0.0;<br/>
		cout("Arraysize must be larger then 1!");<br/>
		return false;<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
/// Determines the mean and standard deviation of a vector<br/>
/// Returns whether successfull<br/>
bool SafeMeanAndStdDev(const std::vector&lt;double&gt;&amp; pArray, double &amp;rMean, double &amp;rStdDev)<br/>
{<br/>
	const unsigned int arraysize = pArray.size();<br/>
	const double arraysizeD = static_cast&lt;double&gt;(arraysize);<br/>
	if (arraysize&lt;2)<br/>
	{<br/>
		rMean = 0.0;<br/>
		rStdDev = 0.0;<br/>
		std::cout &lt;&lt; "Arraysize must be larger then 1!" &lt;&lt; std::endl;<br/>
		return false;<br/>
	}<br/>
	<br/>
	double Sum=0.0, SumSquared=0.0;<br/>
	for (unsigned int counter=0;counter&lt;arraysize;++counter)<br/>
	{<br/>
		Sum+=pArray[counter];<br/>
		SumSquared+=(pArray[counter]*pArray[counter]);<br/>
	}<br/>
	rMean=(Sum/arraysize);<br/>
	//Safe part:<br/>
	double numerator=((arraysizeD*SumSquared)-(Sum*Sum));<br/>
	if (numerator&lt;0.0) {numerator=0.0;}<br/>
	rStdDev=sqrt(numerator/(arraysizeD*(arraysizeD-1.0)));<br/>
	return true;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
/// Determines the mean and standard deviation of a vector<br/>
/// Returns whether successfull<br/>
bool SafeMean(const std::vector&lt;double&gt;&amp; pArray, double &amp; rMean)<br/>
{<br/>
	const unsigned int arraysize = pArray.size();<br/>
	if (arraysize&lt;2)<br/>
	{<br/>
		std::cout &lt;&lt; "Arraysize must be larger then 1!" &lt;&lt; std::endl;<br/>
		rMean=0.0;<br/>
		return false;<br/>
	}<br/>
	double Sum=0.0;<br/>
	for (unsigned int counter=0;counter&lt;arraysize;++counter)<br/>
	{<br/>
		Sum+=pArray[counter];<br/>
	}<br/>
	rMean=(Sum/arraysize);<br/>
	return true;<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SafeMeanSplit(const double&amp; splitValue, std::vector&lt;double&gt;&amp; table, double &amp; rMeanTraitJuvenile, double&amp; rMeanTraitAdult)<br/>
{<br/>
	const unsigned int arraysize = table.size();<br/>
	if (arraysize&lt;=1)<br/>
	{<br/>
		rMeanTraitJuvenile = 0.0;<br/>
		rMeanTraitAdult&nbsp;&nbsp;&nbsp;&nbsp;= 0.0;<br/>
		std::cout &lt;&lt; "Arraysize must be larger then 1!" &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	double sumJuvenile=0.0, sumAdult=0.0;<br/>
	int nJuveniles=0, nAdults=0;<br/>
	for (unsigned int i=0; i&lt;arraysize; ++i)<br/>
	{<br/>
		const double value = table[i];<br/>
		if (value&lt;splitValue)<br/>
		{<br/>
			++nJuveniles;<br/>
			sumJuvenile+=value;<br/>
		}<br/>
		else<br/>
		{<br/>
			++nAdults;<br/>
			sumAdult+=value;<br/>
		}<br/>
	}<br/>
	if (nJuveniles==0) rMeanTraitJuvenile=0.0;<br/>
	else rMeanTraitJuvenile = sumJuvenile/static_cast&lt;double&gt;(nJuveniles);<br/>
	if (nAdults==0) rMeanTraitAdult=splitValue;<br/>
	else rMeanTraitAdult = sumAdult/static_cast&lt;double&gt;(nAdults);<br/>
	assert(rMeanTraitJuvenile&lt;=splitValue);<br/>
	assert(rMeanTraitAdult&gt;=splitValue);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Calculates the mean traitValues for juveniles and adults<br/>
void SafeMeanSplit(const std::vector&lt;bool&gt;&amp; isAdultTable, std::vector&lt;double&gt;&amp; table, double &amp; rMeanTraitJuvenile, double&amp; rMeanTraitAdult)<br/>
{<br/>
	const unsigned int arraysize = table.size();<br/>
	if (arraysize&lt;=1)<br/>
	{<br/>
		rMeanTraitJuvenile = 0.0;<br/>
		rMeanTraitAdult&nbsp;&nbsp;&nbsp;&nbsp;= 0.0;<br/>
		//std::cout &lt;&lt; "Arraysize must be larger then 1!" &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	double sumJuvenile=0.0, sumAdult=0.0;<br/>
	int nJuveniles=0, nAdults=0;<br/>
	for (unsigned int i=0; i&lt;arraysize; ++i)<br/>
	{<br/>
		const double value = table[i];<br/>
		if (isAdultTable[i]==false)<br/>
		{<br/>
			++nJuveniles;<br/>
			sumJuvenile+=value;<br/>
		}<br/>
		else<br/>
		{<br/>
			++nAdults;<br/>
			sumAdult+=value;<br/>
		}<br/>
	}<br/>
	if (nJuveniles==0) rMeanTraitJuvenile=0.0;<br/>
	else rMeanTraitJuvenile = sumJuvenile/static_cast&lt;double&gt;(nJuveniles);<br/>
	if (nAdults==0) rMeanTraitAdult=0.0;<br/>
	else rMeanTraitAdult = sumAdult/static_cast&lt;double&gt;(nAdults);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Counts the occurrence of juveniles with traitValues having values lower then splitValue<br/>
///and adults with traitValues having <br/>
void countSplit(const double&amp; splitValue, std::vector&lt;double&gt;&amp; table, int&amp; rCountJuvenile, int&amp; rCountAdult)<br/>
{<br/>
	const unsigned int size = table.size();<br/>
	rCountJuvenile=0;<br/>
	rCountAdult = 0;<br/>
	for (unsigned int i=0; i&lt;size; ++i)<br/>
	{<br/>
		if (table[i]&lt;splitValue) ++rCountJuvenile;<br/>
		else ++rCountAdult;<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Converts an integer to a string.<br/>
std::string itoa(const int&amp; x)<br/>
{<br/>
	std::ostringstream o;<br/>
	if (!(o &lt;&lt; x)) return "ERROR";<br/>
	return o.str();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Converts a double to a string.<br/>
std::string ftoa(const double&amp; x)<br/>
 {<br/>
	std::ostringstream o;<br/>
	if (!(o &lt;&lt; x)) return "ERROR";<br/>
	return o.str();<br/>
 }<br/>
//----------------------------------------------------------------------------------<br/>
///Checks whether a std::string can be converted to an integer.<br/>
///Returns true if possible, also returning this integer by referencing.<br/>
///Returns false otherwise, setting the referenced integer to zero.<br/>
bool isInt(const std::string&amp; s, int&amp; rInt)<br/>
 {<br/>
	std::istringstream i(s);<br/>
	if (!(i &gt;&gt; rInt))<br/>
		{ rInt = 0; return false; }<br/>
	return true;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Checks whether a std::string can be converted to a double.<br/>
///Returns true if possible, also returning this double by referencing.<br/>
///Returns false otherwise, setting the referenced double to zero.<br/>
bool isDouble(const std::string&amp; s, double&amp; rDouble)<br/>
 {<br/>
	std::istringstream i(s);<br/>
	if (!(i &gt;&gt; rDouble)) <br/>
		{ rDouble = 0.0; return false; }<br/>
	return true;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
std::string stringToUpper(std::string myString)<br/>
{<br/>
	static ToUpper up(std::locale::classic());<br/>
	std::transform(myString.begin(), myString.end(), myString.begin(), up);<br/>
	return myString;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
std::string stringToLower(std::string myString)<br/>
{<br/>
	static ToLower down(std::locale::classic());<br/>
	std::transform(myString.begin(), myString.end(), myString.begin(), down);<br/>
	return myString;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void copyFile(const std::string&amp; fileNameFrom, const std::string&amp; fileNameTo)<br/>
{<br/>
	assert(fileExists(fileNameFrom));<br/>
	std::ifstream in (fileNameFrom.c_str());<br/>
	std::ofstream out(fileNameTo.c_str());<br/>
	out &lt;&lt; in.rdbuf(); <br/>
	out.close();<br/>
	in.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Checks if a file exists. <br/>
bool fileExists(const std::string&amp; fileName)<br/>
{<br/>
	std::fstream fin;<br/>
	fin.open(fileName.c_str(),std::ios::in);<br/>
	if( fin.is_open() )<br/>
	{<br/>
		fin.close();<br/>
		return true;<br/>
	}<br/>
	fin.close();<br/>
	return false;<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Removes the '.txt' or other extensions of a fileName.<br/>
///Actually, it returns the fileName's part before the first dot encountered.<br/>
///When no dot is encountered, it returns the entire fileName.<br/>
std::string stripExtension(const std::string&amp; fileName)<br/>
{<br/>
	const unsigned int length = fileName.length();<br/>
	for (unsigned int i=0; i&lt;length; ++i)<br/>
	{<br/>
		if (fileName[i]=='.') <br/>
		{<br/>
			return fileName.substr(0,i);<br/>
		}<br/>
	}<br/>
	return fileName;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Gets the '.txt' or other extensions of a fileName.<br/>
///Actually, it returns the fileName's part after the first dot encountered.<br/>
///When no dot is encountered, it returns the entire fileName.<br/>
std::string getExtension(const std::string&amp; fileName)<br/>
{<br/>
	const unsigned int length = fileName.length();<br/>
	for (unsigned int i=0; i&lt;length; ++i)<br/>
	{<br/>
		if (fileName[i]=='.') <br/>
		{<br/>
			return fileName.substr(i+1,length);<br/>
		}<br/>
	}<br/>
	return fileName;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Example program to use autoEnum:<br/>
///&nbsp;&nbsp;std::vector&lt;std::string&gt; enumValues;<br/>
///&nbsp;&nbsp;std::string fileName = "/Volumes/RichelDrive/EnumSigma.cpp";<br/>
///&nbsp;&nbsp;std::string enumName = "EnumSigma";<br/>
///&nbsp;&nbsp;std::string variableName = "enumSigma";<br/>
///&nbsp;&nbsp;enumValues.push_back("enumSigmaZero");<br/>
///&nbsp;&nbsp;enumValues.push_back("enumSigmaUniform");<br/>
///&nbsp;&nbsp;autoEnum(fileName, enumName, variableName, enumValues);<br/>
///<br/>
void autoEnum(const std::string&amp; fileName, const std::string&amp; enumName, <br/>
	const std::string&amp; variableName, std::vector&lt;std::string&gt;&amp; enumValues)<br/>
{<br/>
	//Open file<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	//Enumeration<br/>
	file &lt;&lt; "//----------------------------------------------------------------------------------" &lt;&lt; '\n';<br/>
	file &lt;&lt; "enum " &lt;&lt; enumName &lt;&lt; '\n';<br/>
	file &lt;&lt; "{" &lt;&lt; '\n';<br/>
	for (unsigned int i=0; i&lt;enumValues.size(); ++i)<br/>
	{<br/>
		file &lt;&lt; '\t' &lt;&lt; enumValues[i] &lt;&lt; ( (i&lt;enumValues.size()-1) ? ",\n" : "\n" );<br/>
	}<br/>
	file &lt;&lt; "};" &lt;&lt; '\n';<br/>
	//Headers<br/>
	file &lt;&lt; "//----------------------------------------------------------------------------------" &lt;&lt; '\n';<br/>
	file &lt;&lt; "std::string " &lt;&lt; variableName &lt;&lt; "toString(const " &lt;&lt; enumName &lt;&lt; "&amp;);" &lt;&lt; '\n';<br/>
	file &lt;&lt; enumName &lt;&lt; " stringTo" &lt;&lt; enumName &lt;&lt; "(const std::string&amp;);" &lt;&lt; '\n';<br/>
	//Implementation<br/>
	file &lt;&lt; "//----------------------------------------------------------------------------------" &lt;&lt; '\n';<br/>
	file &lt;&lt; "std::string " &lt;&lt; variableName <br/>
		 &lt;&lt; "toString(const " &lt;&lt; enumName &lt;&lt; "&amp; " <br/>
		 &lt;&lt; variableName &lt;&lt; ")" &lt;&lt; '\n';<br/>
	file &lt;&lt; "{" &lt;&lt; '\n';<br/>
	file &lt;&lt; '\t' &lt;&lt; "switch(" &lt;&lt; variableName &lt;&lt; ")" &lt;&lt; '\n';<br/>
	file &lt;&lt; '\t' &lt;&lt; "{" &lt;&lt; '\n';<br/>
	for (unsigned int i=0; i&lt;enumValues.size(); ++i)<br/>
	{<br/>
		file &lt;&lt; '\t' &lt;&lt; '\t' &lt;&lt; "case " &lt;&lt; enumValues[i] &lt;&lt; ": return \"" &lt;&lt; enumValues[i] &lt;&lt; "\";" &lt;&lt; '\n' ;<br/>
	}<br/>
	file &lt;&lt; '\t' &lt;&lt; "}" &lt;&lt; '\n';<br/>
	file &lt;&lt; '\t' &lt;&lt; "return \"ERROR in 'std::string " &lt;&lt; variableName <br/>
		 &lt;&lt; "ToString(const " &lt;&lt; enumName &lt;&lt; "&amp; " <br/>
		 &lt;&lt; variableName &lt;&lt; ")'\";" &lt;&lt; '\n';<br/>
	file &lt;&lt; "}" &lt;&lt; '\n';<br/>
	file &lt;&lt; "//----------------------------------------------------------------------------------" &lt;&lt; '\n';<br/>
	file &lt;&lt; enumName &lt;&lt; " stringTo" &lt;&lt; enumName &lt;&lt; "(const std::string&amp; myString)" &lt;&lt; '\n';<br/>
	file &lt;&lt; "{" &lt;&lt; '\n';<br/>
	for (unsigned int i=0; i&lt;enumValues.size(); ++i)<br/>
	file &lt;&lt; '\t' &lt;&lt; "if (myString==\"" &lt;&lt; enumValues[i] &lt;&lt; "\") return " &lt;&lt; enumValues[i] &lt;&lt; ";" &lt;&lt; '\n';<br/>
	file &lt;&lt; '\t' &lt;&lt; "std::cout &lt;&lt; \"ERROR in '"&lt;&lt; enumName <br/>
		&lt;&lt; " StringTo" &lt;&lt; enumName &lt;&lt; "(const std::string&amp; myString)'\" &lt;&lt; std::endl;" &lt;&lt; '\n';<br/>
	file &lt;&lt; '\t' &lt;&lt; "exit(1);" &lt;&lt; '\n';<br/>
	file &lt;&lt; "}" &lt;&lt; '\n';<br/>
	file &lt;&lt; "//----------------------------------------------------------------------------------" &lt;&lt; '\n';<br/>
	//Close file<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
std::vector&lt;std::string&gt; fileToVector(const std::string&amp; fileName)<br/>
{<br/>
	assert(fileExists(fileName)==true);<br/>
	std::vector&lt;std::string&gt; myVector;<br/>
	<br/>
	std::ifstream in (fileName.c_str());<br/>
	std::string myString;<br/>
	for (int i=0; !in.eof(); ++i)<br/>
	{<br/>
		in &gt;&gt; myString;<br/>
		myVector.push_back(myString);<br/>
		//std::cout &lt;&lt; i &lt;&lt; " : " &lt;&lt; myString &lt;&lt; std::endl;<br/>
	}<br/>
	return myVector;<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//One vector<br/>
void vectorToFile(const std::vector&lt;double&gt;&amp; myVector, <br/>
	const std::string&amp; fileName, const int&amp; startIndex)<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	const unsigned int size = myVector.size();<br/>
	for (unsigned int i=startIndex; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt; myVector[i] &lt;&lt; '\n';<br/>
	}<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//Two vectors<br/>
void vectorToFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name1, const std::vector&lt;double&gt;&amp; myVector1, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name2, const std::vector&lt;double&gt;&amp; myVector2,<br/>
	const std::string&amp; fileName, const int&amp; startIndex)<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	file &lt;&lt;&nbsp;&nbsp;name1 &lt;&lt; " " &lt;&lt; name2 &lt;&lt; '\n';<br/>
	const unsigned int size = ( myVector1.size() &lt; myVector2.size() ? myVector1.size() : myVector2.size());<br/>
	for (unsigned int i=startIndex; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt;&nbsp;&nbsp;myVector1[i] &lt;&lt; " " &lt;&lt; myVector2[i] &lt;&lt; '\n';<br/>
	}<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//Three vectors<br/>
void vectorToFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name1, const std::vector&lt;double&gt;&amp; myVector1, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name2, const std::vector&lt;double&gt;&amp; myVector2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name3, const std::vector&lt;double&gt;&amp; myVector3,<br/>
	const std::string&amp; fileName, const int&amp; startIndex)<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	file &lt;&lt;&nbsp;&nbsp;name1 &lt;&lt; " " &lt;&lt; name2 &lt;&lt; " " &lt;&lt; name3 &lt;&lt; '\n';<br/>
	const unsigned int size = min(myVector1.size(),myVector2.size(),myVector3.size());<br/>
	for (unsigned int i=startIndex; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt;&nbsp;&nbsp;myVector1[i] &lt;&lt; " " &lt;&lt; myVector2[i] &lt;&lt; " " &lt;&lt; myVector3[i] &lt;&lt;'\n';<br/>
	}<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void vectorToFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name1, const std::vector&lt;double&gt;&amp; myVector1, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name2, const std::vector&lt;double&gt;&amp; myVector2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name3, const std::vector&lt;double&gt;&amp; myVector3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name4, const std::vector&lt;double&gt;&amp; myVector4,<br/>
	const std::string&amp; fileName, const int&amp; startIndex)<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	file &lt;&lt;&nbsp;&nbsp;name1 &lt;&lt; " " &lt;&lt; name2 &lt;&lt; " " &lt;&lt; name3 &lt;&lt; " " &lt;&lt; name4 &lt;&lt; '\n';<br/>
	const unsigned int size = min(myVector1.size(),myVector2.size(),myVector3.size(),myVector4.size());<br/>
	for (unsigned int i=startIndex; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt;&nbsp;&nbsp;myVector1[i] &lt;&lt; " " &lt;&lt; myVector2[i] &lt;&lt; " " &lt;&lt; myVector3[i] &lt;&lt; " " &lt;&lt; myVector4[i] &lt;&lt; '\n';<br/>
	}<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void vectorToFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name1, const std::vector&lt;double&gt;&amp; myVector1, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name2, const std::vector&lt;double&gt;&amp; myVector2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name3, const std::vector&lt;double&gt;&amp; myVector3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name4, const std::vector&lt;double&gt;&amp; myVector4,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name5, const std::vector&lt;double&gt;&amp; myVector5,<br/>
	const std::string&amp; fileName, const int&amp; startIndex)<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	file &lt;&lt;&nbsp;&nbsp;name1 &lt;&lt; " " &lt;&lt; name2 &lt;&lt; " " &lt;&lt; name3 &lt;&lt; " " &lt;&lt; name4 &lt;&lt; " " &lt;&lt; name5 &lt;&lt; '\n';<br/>
	const unsigned int size = min(myVector1.size(),myVector2.size(),myVector3.size(),myVector4.size(),myVector5.size());<br/>
	for (unsigned int i=startIndex; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt;&nbsp;&nbsp;myVector1[i] &lt;&lt; " " &lt;&lt; myVector2[i] &lt;&lt; " " &lt;&lt; myVector3[i] &lt;&lt; " " &lt;&lt; myVector4[i] &lt;&lt; " " &lt;&lt; myVector5[i] &lt;&lt; '\n';<br/>
	}<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void vectorToFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name1, const std::vector&lt;double&gt;&amp; myVector1, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name2, const std::vector&lt;double&gt;&amp; myVector2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name3, const std::vector&lt;double&gt;&amp; myVector3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name4, const std::vector&lt;double&gt;&amp; myVector4,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name5, const std::vector&lt;double&gt;&amp; myVector5,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name6, const std::vector&lt;double&gt;&amp; myVector6,<br/>
	const std::string&amp; fileName, const int&amp; startIndex)<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	file &lt;&lt;&nbsp;&nbsp;name1 &lt;&lt; " " &lt;&lt; name2 &lt;&lt; " " &lt;&lt; name3 &lt;&lt; " " &lt;&lt; name4 &lt;&lt; " " &lt;&lt; name5 &lt;&lt; " " &lt;&lt; name6 &lt;&lt; '\n';<br/>
	const unsigned int size = min(myVector1.size(),myVector2.size(),myVector3.size(),myVector4.size(),myVector5.size(),myVector6.size());<br/>
	for (unsigned int i=startIndex; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt;&nbsp;&nbsp;myVector1[i] &lt;&lt; " " &lt;&lt; myVector2[i] &lt;&lt; " " &lt;&lt; myVector3[i] &lt;&lt; " " &lt;&lt; myVector4[i] &lt;&lt; " " &lt;&lt; myVector5[i] &lt;&lt; " " &lt;&lt; myVector6[i] &lt;&lt; '\n';<br/>
	}<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void vectorToFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name1, const std::vector&lt;double&gt;&amp; myVector1, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name2, const std::vector&lt;double&gt;&amp; myVector2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name3, const std::vector&lt;double&gt;&amp; myVector3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name4, const std::vector&lt;double&gt;&amp; myVector4,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name5, const std::vector&lt;double&gt;&amp; myVector5,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name6, const std::vector&lt;double&gt;&amp; myVector6,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name7, const std::vector&lt;double&gt;&amp; myVector7,<br/>
	const std::string&amp; fileName, const int&amp; startIndex)<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	file &lt;&lt;&nbsp;&nbsp;name1 &lt;&lt; " " &lt;&lt; name2 &lt;&lt; " " &lt;&lt; name3 &lt;&lt; " " &lt;&lt; name4 &lt;&lt; " " &lt;&lt; name5 &lt;&lt; " " &lt;&lt; name6 &lt;&lt; " " &lt;&lt; name7 &lt;&lt; '\n';<br/>
	const unsigned int size = min(myVector1.size(),myVector2.size(),myVector3.size(),myVector4.size(),myVector5.size(),myVector6.size(),myVector7.size());<br/>
	for (unsigned int i=startIndex; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt;&nbsp;&nbsp;myVector1[i] &lt;&lt; " " &lt;&lt; myVector2[i] &lt;&lt; " " &lt;&lt; myVector3[i] &lt;&lt; " " &lt;&lt; myVector4[i] &lt;&lt; " " &lt;&lt; myVector5[i] &lt;&lt; " " &lt;&lt; myVector6[i] &lt;&lt; " " &lt;&lt; myVector7[i] &lt;&lt; '\n';<br/>
	}<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void vectorToFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name1, const std::vector&lt;double&gt;&amp; myVector1, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name2, const std::vector&lt;double&gt;&amp; myVector2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name3, const std::vector&lt;double&gt;&amp; myVector3,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name4, const std::vector&lt;double&gt;&amp; myVector4,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name5, const std::vector&lt;double&gt;&amp; myVector5,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name6, const std::vector&lt;double&gt;&amp; myVector6,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name7, const std::vector&lt;double&gt;&amp; myVector7,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name8, const std::vector&lt;double&gt;&amp; myVector8,<br/>
	const std::string&amp; fileName, const int&amp; startIndex)<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	assert(file.is_open()==true);<br/>
	file &lt;&lt;&nbsp;&nbsp;name1 &lt;&lt; " " &lt;&lt; name2 &lt;&lt; " " &lt;&lt; name3 &lt;&lt; " " &lt;&lt; name4 &lt;&lt; " " &lt;&lt; name5 &lt;&lt; " " &lt;&lt; name6 &lt;&lt; " " &lt;&lt; name7 &lt;&lt; " " &lt;&lt; name8 &lt;&lt; '\n';<br/>
	const unsigned int size = min(myVector1.size(),myVector2.size(),myVector3.size(),myVector4.size(),myVector5.size(),myVector6.size(),myVector7.size(),myVector8.size());<br/>
	for (unsigned int i=startIndex; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt;&nbsp;&nbsp;myVector1[i] &lt;&lt; " " &lt;&lt; myVector2[i] &lt;&lt; " " &lt;&lt; myVector3[i] &lt;&lt; " " &lt;&lt; myVector4[i] &lt;&lt; " " &lt;&lt; myVector5[i] &lt;&lt; " " &lt;&lt; myVector6[i] &lt;&lt; " " &lt;&lt; myVector7[i] &lt;&lt; " " &lt;&lt; myVector8[i] &lt;&lt; '\n';<br/>
	}<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void coutVector(const std::vector&lt;std::string&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i) std::cout &lt;&lt; i &lt;&lt; " : " &lt;&lt; myVector[i] &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; void coutVector(const std::vector&lt;T&gt;&amp; myVector)<br/>
{<br/>
&nbsp;&nbsp;const unsigned int size = myVector.size();<br/>
&nbsp;&nbsp;for (unsigned int i=0; i&lt;size; ++i) std::cout &lt;&lt; i &lt;&lt; " : " &lt;&lt; myVector[i] &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
std::string indexToPlasticity(const int&amp; index)<br/>
{<br/>
	if (index&gt;1) return "(P,"+itoa(index)+")";<br/>
	return "(NP,"+itoa(index)+")";<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/HelperFunctions.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/HelperFunctions.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;HelperFunctions.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 24 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
//----------------------------------------------------------------------------------<br/>
#ifndef __HELPER_FUNCTIONS_H<br/>
#define __HELPER_FUNCTIONS_H<br/>
<br/>
//#define NDOT<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;sstream&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "gnuplot.h"<br/>
#include "MeasurementsTable.h"<br/>
#include "Enumerations.h"<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
///Structs for upper and lower case functions<br/>
struct ToUpper<br/>
{<br/>
	ToUpper(std::locale const&amp; l) : loc(l) {;}<br/>
	char operator() (char c) const&nbsp;&nbsp;{ return std::toupper(c,loc); }<br/>
	private:<br/>
	std::locale const&amp; loc;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
struct ToLower<br/>
{<br/>
	ToLower(std::locale const&amp; l) : loc(l) {;}<br/>
	char operator() (char c) const&nbsp;&nbsp;{ return std::tolower(c,loc); }<br/>
	private:<br/>
	std::locale const&amp; loc;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;);<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;, const T&amp;);<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;, const T&amp;, const T&amp;);<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;);<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;);<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;);<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;);<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;);<br/>
template &lt;typename T&gt; T min(const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;, const T&amp;);<br/>
<br/>
<br/>
//Statistics<br/>
template &lt;class T&gt; bool SafeMeanAndStdDev(const T *, const int&amp;, double &amp;, double &amp;);<br/>
bool SafeMeanAndStdDev(const std::vector&lt;double&gt;&amp;, double &amp;, double &amp;);<br/>
bool SafeMean(const std::vector&lt;double&gt;&amp;, double &amp;);<br/>
void SafeMeanSplit(const double&amp;, std::vector&lt;double&gt;&amp;, double&amp; , double&amp;);<br/>
void SafeMeanSplit(const std::vector&lt;bool&gt;&amp;, std::vector&lt;double&gt;&amp;, double&amp; , double&amp;);<br/>
void countSplit(const double&amp;, std::vector&lt;double&gt;&amp;, int&amp;, int&amp;);<br/>
<br/>
//Conversions<br/>
std::string itoa(const int&amp;);<br/>
std::string ftoa(const double&amp;);<br/>
bool isDouble(const std::string&amp;, double&amp;);<br/>
bool isInt(const std::string&amp;, int&amp;);<br/>
std::string stringToLower(std::string myString);<br/>
std::string stringToUpper(std::string myString);<br/>
<br/>
//File I/O<br/>
void copyFile(const std::string&amp;, const std::string&amp;);<br/>
bool fileExists(const std::string&amp;);<br/>
std::string stripExtension(const std::string&amp;);<br/>
std::string getExtension(const std::string&amp;);<br/>
std::vector&lt;std::string&gt; fileToVector(const std::string&amp;);<br/>
<br/>
void vectorToFile(const std::vector&lt;double&gt;&amp;, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const int&amp; startIndex = 0);<br/>
void vectorToFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const int&amp; startIndex = 0);<br/>
void vectorToFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const int&amp; startIndex = 0);<br/>
void vectorToFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const int&amp; startIndex = 0);<br/>
void vectorToFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const int&amp; startIndex = 0);<br/>
void vectorToFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const int&amp; startIndex = 0);<br/>
void vectorToFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const std::vector&lt;double&gt;&amp;,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp;, const int&amp; startIndex = 0);<br/>
<br/>
//Automatic code generation<br/>
void autoEnum(const std::string&amp;, const std::string&amp;, const std::string&amp;, std::vector&lt;std::string&gt;&amp;);<br/>
<br/>
//Misc<br/>
std::string indexToPlasticity(const int&amp;);<br/>
void coutVector(const std::vector&lt;std::string&gt;&amp;);<br/>
template &lt;typename T&gt; void coutVector(const std::vector&lt;T&gt;&amp; myVector);<br/>
<br/>
#endif //#ifndef __HELPER_FUNCTIONS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/main.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/main.cpp" border = "1"><tr><td><code>
#include &lt;iostream&gt;<br/>
#include "Sim4Interpreter.h"<br/>
#include "OptionsFile.h"<br/>
#include "Experiment.h"<br/>
<br/>
///Goal of main is to be the interface between command-line input, OptionsFile and Experiment<br/>
///<br/>
///The meat of the code is in those classes.<br/>
///<br/>
///<br/>
<br/>
//#include "HelperFunctions.h"<br/>
//#include "Test.h"<br/>
//demoGnuplot();<br/>
<br/>
<br/>
int main (int argc, char * const argv[]) <br/>
{<br/>
	std::cout &lt;&lt; "VERSION 17" &lt;&lt; std::endl;<br/>
	//Read the command line options<br/>
	const Sim4Interpreter interpreter(argc,argv);<br/>
	//Get the OptionsFile<br/>
	const OptionsFile optionsFile = interpreter.getOptionsFile();<br/>
	//Create the Experiment with the OptionsFile<br/>
	const Experiment experiment(optionsFile);<br/>
	//Run the Experiment<br/>
	experiment.execute();<br/>
	//Done...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/MeasurementsTable.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/MeasurementsTable.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;MeasurementsTable.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue Jun 07 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "MeasurementsTable.h"<br/>
<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
void MeasurementsTable::showYearLegend() const<br/>
{<br/>
	std::cout &lt;&lt; "time" &lt;&lt; '\t' <br/>
		&lt;&lt; "PopSize" &lt;&lt; '\t' <br/>
		&lt;&lt; "Noffspring" &lt;&lt; '\t' <br/>
		&lt;&lt; "Resources" &lt;&lt; '\t' <br/>
		&lt;&lt; "MeanBodySize" &lt;&lt; '\t' <br/>
		&lt;&lt; "MeanReserves" &lt;&lt; '\n';<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void MeasurementsTable::showYear(const unsigned int&amp; time) const<br/>
{<br/>
	std::cout &lt;&lt; time &lt;&lt; '\t' <br/>
		&lt;&lt; mPopSize[time] &lt;&lt; '\t' <br/>
		&lt;&lt; mNoffspring[time] &lt;&lt; '\t' <br/>
		&lt;&lt; mResources[time] &lt;&lt; '\t' <br/>
		&lt;&lt; mMeanBodySize[time] &lt;&lt; '\t' <br/>
		&lt;&lt; mMeanReserves[time] &lt;&lt; '\n';<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void MeasurementsTable::showYearHorizontal(const unsigned int&amp; time) const<br/>
{<br/>
	if (mPopSize.size()==0) <br/>
	{ <br/>
		std::cout &lt;&lt; "WARNING: Measurement table is shown before any data in it!:" &lt;&lt; std::endl; <br/>
		return;<br/>
	}<br/>
	//assert(time&lt;mPopSize.size());<br/>
	assert(time&lt;=mPopSize.size());<br/>
	std::cout &lt;&lt; "--------------------------------------------" <br/>
		&lt;&lt; "\ntime: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; time &lt;&lt; '\n' <br/>
		&lt;&lt; "PopSize: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; mPopSize[time] &lt;&lt; '\n' <br/>
		&lt;&lt; "Noffspring: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mNoffspring[time] &lt;&lt; '\n' <br/>
		&lt;&lt; "Resources: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; mResources[time] &lt;&lt; '\n' <br/>
		&lt;&lt; "MeanBodySize: "&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mMeanBodySize[time] &lt;&lt; '\n' <br/>
		&lt;&lt; "MeanReserves: "&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mMeanReserves[time] &lt;&lt; '\n'<br/>
		&lt;&lt; "MeanChanceToDie: " &lt;&lt; mMeanChanceToDie[time] &lt;&lt; '\n'<br/>
		&lt;&lt; "MeanFoodIntake: "&nbsp;&nbsp;&lt;&lt; mMeanFoodIntake[time] &lt;&lt; '\n' <br/>
		&lt;&lt; "mMeanAllocation: "&nbsp;&nbsp; &lt;&lt; mMeanAllocation[time] &lt;&lt; '\n'<br/>
		&lt;&lt; "mMeanFractionBiomassPerOffspringInitial: " &lt;&lt; mMeanFractionBiomassPerOffspringInitial[time] &lt;&lt; '\n'<br/>
		&lt;&lt; "mMeanFractionBiomassPerOffspring: " &lt;&lt; mMeanFractionBiomassPerOffspring[time] &lt;&lt; '\n';<br/>
		<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void MeasurementsTable::saveToSingleFile(const std::string&amp; fileName) const<br/>
{<br/>
	std::ofstream file(fileName.c_str());<br/>
	//std::cout &lt;&lt; "Saving measurements as file '" &lt;&lt; fileName &lt;&lt; "'.\n";<br/>
	//std::cout &lt;&lt; "Progress:\n";<br/>
	//std::cout &lt;&lt; "------------------------\n";<br/>
	addVectorToFile("Population size", mPopSize,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Amount of offspring",&nbsp;&nbsp;mNoffspring,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Resources",&nbsp;&nbsp; mResources,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean body size",mMeanBodySize,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("StdDev body size",mStdDevBodySize,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Means reserves",mMeanReserves,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Stddev reserves",mStdDevReserves,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean chance to die",mMeanChanceToDie,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("StdDev chance to die",mStdDevChanceToDie,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean food intake",mMeanFoodIntake,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("StdDev food intake",mStdDevFoodIntake,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Population size Juveniles",mPopSizeJuvenile,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Population size Adults",mPopSizeAdult,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean body size Juveniles",mMeanBodySizeJuvenile,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean body size Adults",mMeanBodySizeAdult,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean reserves Juveniles",mMeanReservesJuvenile,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean reserves Adults",mMeanReservesAdult,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean chance to die Juveniles",mMeanChanceToDieJuvenile,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean chance to die Adults",mMeanChanceToDieAdult,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean food intake Juveniles",mMeanFoodIntakeJuvenile,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean food intake Adults",mMeanFoodIntakeAdult,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean allocation",mMeanAllocation,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean fraction biomass per offspring Initial",mMeanFractionBiomassPerOffspringInitial,file);<br/>
	std::cout &lt;&lt; ".";<br/>
	addVectorToFile("Mean fraction biomass per offspring After rounding off",mMeanFractionBiomassPerOffspring,file);<br/>
	std::cout &lt;&lt; ".\nSaving done.\n";<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void MeasurementsTable::saveToMultipleFiles(const std::string&amp; fileName) const<br/>
{<br/>
	const std::string baseFileName = stripExtension(fileName); <br/>
	vectorToFile(mPopSize&nbsp;&nbsp;&nbsp;&nbsp; ,baseFileName+"PopSize.rda");<br/>
	vectorToFile(mResources&nbsp;&nbsp; ,baseFileName+"Resources.rda");<br/>
	vectorToFile(mMeanBodySize,baseFileName+"BodySize.rda");<br/>
	vectorToFile(mMeanReserves,baseFileName+"Reserves.rda");<br/>
	vectorToFile(mMeanFoodIntake,baseFileName+"FoodIntake.rda");<br/>
	VectorToFile(mMeanAllocation,baseFileName+"Partition.rda");<br/>
	vectorToFile("PopSize", mPopSize, "Resources" , mResources, baseFileName+"PopResScatter.rda");<br/>
	vectorToFile("PopSize"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , mPopSize, <br/>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Resources"&nbsp;&nbsp;&nbsp;&nbsp; , mResources,<br/>
				 "MeanBodySize"&nbsp;&nbsp;, mMeanBodySize,<br/>
				 "MeanReserves"&nbsp;&nbsp;, mMeanReserves,<br/>
				 "MeanFoodIntake", mMeanFoodIntake,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "MeanPartition" , mMeanAllocation,<br/>
				&nbsp;&nbsp;baseFileName+"Scatter.rda");<br/>
	vectorToFile("PopSize"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , mPopSize, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "MeanPartition" , mMeanAllocation,<br/>
				&nbsp;&nbsp;baseFileName+"SubScatter.rda");<br/>
	std::cout &lt;&lt; ".\nSaving done.\n";<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void MeasurementsTable::addVectorToFile(const std::string&amp; name, const std::vector&lt;double&gt;&amp; myVector, std::ofstream&amp; file) const<br/>
{<br/>
	assert(file.is_open()==true);<br/>
	const unsigned int size = myVector.size();<br/>
	file &lt;&lt; name &lt;&lt; '\n';<br/>
	file &lt;&lt; "Size of vector '" &lt;&lt; name &lt;&lt; "':" &lt;&lt; '\n';<br/>
	file &lt;&lt; size &lt;&lt; '\n';<br/>
	file &lt;&lt; "Contents of vector '" &lt;&lt; name &lt;&lt; "':" &lt;&lt; '\n';<br/>
	for (unsigned int i=0; i&lt;size; ++i)<br/>
	{<br/>
		file &lt;&lt;&nbsp;&nbsp;myVector[i] &lt;&lt; '\n';<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
void plotMeasurementsTable(std::vector&lt;MeasurementsTable&gt;&amp; tables)<br/>
{<br/>
	std::cout &lt;&lt; "Plotting started." &lt;&lt; std::endl;<br/>
	const unsigned int nTables = tables.size();<br/>
	std::string temp;<br/>
	Gnuplot myPlot;<br/>
	myPlot.setStyle(styleLines);<br/>
	usleep(150000); myPlot.changeWindow(0);<br/>
	for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mPopSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,"PopSize"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+indexToPlasticity(i));<br/>
	for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mPopSizeJuvenile,"PopSizeJuvenile"+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mPopSizeAdult&nbsp;&nbsp; ,"PopSizeAdult"&nbsp;&nbsp; +indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mNoffspring&nbsp;&nbsp;&nbsp;&nbsp; ,"Noffspring"&nbsp;&nbsp;&nbsp;&nbsp; +indexToPlasticity(i));<br/>
	<br/>
	usleep(150000); myPlot.changeWindow(1);<br/>
	for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mResources,"Resources"+indexToPlasticity(i));<br/>
	/*<br/>
	usleep(150000); myPlot.changeWindow(2);<br/>
	for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanBodySize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,"Mean body size"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanBodySizeJuvenile,"Mean body sizeJuvenile"+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanBodySizeAdult&nbsp;&nbsp; ,"Mean body sizeAdult"&nbsp;&nbsp; +indexToPlasticity(i));<br/>
	usleep(150000); myPlot.changeWindow(3);<br/>
	for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanReserves&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,"Mean reserves"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanReservesJuvenile,"Mean reservesJuvenile"+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanReservesAdult&nbsp;&nbsp; ,"Mean reservesAdult"&nbsp;&nbsp; +indexToPlasticity(i));<br/>
	usleep(150000); myPlot.changeWindow(4);<br/>
	for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanChanceToDie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,"Mean chance to die"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanChanceToDieJuvenile,"Mean chance to dieJuvenile"+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanChanceToDieAdult&nbsp;&nbsp; ,"Mean chance to dieAdult"&nbsp;&nbsp; +indexToPlasticity(i));<br/>
	usleep(150000); myPlot.changeWindow(5);<br/>
	for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanFoodIntake,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Mean food intake"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanFoodIntakeJuvenile,"Mean food intakeJuvenile"+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanFoodIntakeAdult,&nbsp;&nbsp; "Mean food intakeAdult"&nbsp;&nbsp; +indexToPlasticity(i));<br/>
	usleep(150000); myPlot.changeWindow(6);<br/>
	for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanAllocation,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Mean allocation"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanFractionBiomassPerOffspringInitial,"Mean fraction biomass per offspring initial"+indexToPlasticity(i));<br/>
	//for (unsigned int i = 0; i&lt;nTables; ++i) myPlot.plot(tables[i].mMeanFractionBiomassPerOffspring,"Mean fraction biomass per offspring"+indexToPlasticity(i));<br/>
	*/<br/>
	usleep(150000); <br/>
	std::cout &lt;&lt; "Done plotting." &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void drawConclusions(const MeasurementsTable&amp; table,std::vector&lt;EnumConclusion&gt;&amp; conclusions)<br/>
{<br/>
<br/>
	double meanPopSize&nbsp;&nbsp;&nbsp;&nbsp; = -1.0;<br/>
	double meanNoffspring&nbsp;&nbsp;= -1.0;<br/>
	double meanBodySize&nbsp;&nbsp;&nbsp;&nbsp;= -1.0;<br/>
	double meanReserves&nbsp;&nbsp;&nbsp;&nbsp;= -1.0;<br/>
	double meanChanceToDie = -1.0;<br/>
	double meanFoodIntake&nbsp;&nbsp;= -1.0;<br/>
	double meanAllocation&nbsp;&nbsp;= -1.0;<br/>
	double meanFractionBiomassPerOffspringInitial = -1.0;<br/>
	double meanFractionBiomassPerOffspring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= -1.0;<br/>
	SafeMean(table.mPopSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meanPopSize);<br/>
	SafeMean(table.mNoffspring,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meanNoffspring);<br/>
	SafeMean(table.mMeanBodySize,&nbsp;&nbsp;&nbsp;&nbsp;meanBodySize);<br/>
	SafeMean(table.mMeanReserves,&nbsp;&nbsp;&nbsp;&nbsp;meanReserves);<br/>
	SafeMean(table.mMeanChanceToDie, meanChanceToDie);<br/>
	SafeMean(table.mMeanFoodIntake,&nbsp;&nbsp;meanFoodIntake);<br/>
	SafeMean(table.mMeanAllocation,&nbsp;&nbsp;meanAllocation);<br/>
	SafeMean(table.mMeanFractionBiomassPerOffspringInitial, meanFractionBiomassPerOffspringInitial);<br/>
	SafeMean(table.mMeanFractionBiomassPerOffspring, meanFractionBiomassPerOffspring);<br/>
<br/>
	std::cout &lt;&lt; "Mean population size: " &lt;&lt; meanPopSize &lt;&lt; std::endl;<br/>
	if (meanPopSize&lt;500.0) conclusions.push_back(CcMeanPopSizeSmall);<br/>
	if (meanPopSize&gt;1500.0) conclusions.push_back(CcMeanPopSizeLarge);<br/>
	std::cout &lt;&lt; "Mean offspring produced: " &lt;&lt; meanNoffspring &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "Mean body size: " &lt;&lt; meanBodySize &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "Mean reserves: " &lt;&lt; meanReserves &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "Mean chance to die: " &lt;&lt; meanChanceToDie &lt;&lt; std::endl;<br/>
	if (meanChanceToDie &lt; 0.001) conclusions.push_back(CcChanceToDieSmall);<br/>
	if (meanChanceToDie &gt; 0.1) conclusions.push_back(CcChanceToDieLarge);<br/>
	std::cout &lt;&lt; "Mean food intake: " &lt;&lt; meanFoodIntake &lt;&lt; std::endl;<br/>
<br/>
	std::cout &lt;&lt; "meanAllocation: " &lt;&lt; meanAllocation &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "meanFractionBiomassPerOffspringInitial: " &lt;&lt; meanFractionBiomassPerOffspringInitial &lt;&lt; std::endl;<br/>
	if (meanFractionBiomassPerOffspringInitial&gt;0.99) conclusions.push_back(CcFractionBiomassPerOffspringInitialLarge);<br/>
	std::cout &lt;&lt; "meanFractionBiomassPerOffspring: " &lt;&lt; meanFractionBiomassPerOffspring &lt;&lt; std::endl;<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void interpretMeasurementsTables(const std::vector&lt;MeasurementsTable&gt;&amp; table)<br/>
{<br/>
	const unsigned int size = table.size();<br/>
	std::vector&lt;double&gt; meanPopSize(size);<br/>
	std::vector&lt;double&gt; meanNoffspring(size);<br/>
	std::vector&lt;double&gt; meanBodySize(size);<br/>
	std::vector&lt;double&gt; meanReserves(size);<br/>
	std::vector&lt;double&gt; meanChanceToDie(size);<br/>
	std::vector&lt;double&gt; meanFoodIntake(size);<br/>
	std::vector&lt;double&gt; meanAllocation(size);<br/>
	std::vector&lt;double&gt; meanFractionBiomassPerOffspringInitial(size);<br/>
	std::vector&lt;double&gt; meanFractionBiomassPerOffspring(size);<br/>
	for(unsigned int i=0; i&lt;size; ++i)<br/>
	{<br/>
		SafeMean(table[i].mPopSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meanPopSize[i]);<br/>
		SafeMean(table[i].mNoffspring,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meanNoffspring[i]);<br/>
		SafeMean(table[i].mMeanBodySize,&nbsp;&nbsp;&nbsp;&nbsp;meanBodySize[i]);<br/>
		SafeMean(table[i].mMeanReserves,&nbsp;&nbsp;&nbsp;&nbsp;meanReserves[i]);<br/>
		SafeMean(table[i].mMeanChanceToDie, meanChanceToDie[i]);<br/>
		SafeMean(table[i].mMeanFoodIntake,&nbsp;&nbsp;meanFoodIntake[i]);<br/>
		SafeMean(table[i].mMeanAllocation,&nbsp;&nbsp;meanAllocation[i]);<br/>
		SafeMean(table[i].mMeanFractionBiomassPerOffspringInitial, meanFractionBiomassPerOffspringInitial[i]);<br/>
		SafeMean(table[i].mMeanFractionBiomassPerOffspring, meanFractionBiomassPerOffspring[i]);<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/MeasurementsTable.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/MeasurementsTable.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;MeasurementsTable.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue Jun 07 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
///Structure for storing measurements. <br/>
///<br/>
///Is plotted by functions in HelperFunctions.h<br/>
<br/>
#ifndef __MEASUREMENTS_TABLE_H<br/>
#define __MEASUREMENTS_TABLE_H<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "Enumerations.h"<br/>
#include "HelperFunctions.h"<br/>
<br/>
class MeasurementsTable<br/>
{<br/>
	public:<br/>
	std::vector&lt;double&gt; mPopSize;<br/>
	std::vector&lt;double&gt; mNoffspring;<br/>
	std::vector&lt;double&gt; mResources;<br/>
	std::vector&lt;double&gt; mMeanBodySize;<br/>
	std::vector&lt;double&gt; mStdDevBodySize;<br/>
	std::vector&lt;double&gt; mMeanReserves;	<br/>
	std::vector&lt;double&gt; mStdDevReserves;<br/>
	std::vector&lt;double&gt; mMeanChanceToDie;<br/>
	std::vector&lt;double&gt; mStdDevChanceToDie;<br/>
	std::vector&lt;double&gt; mMeanFoodIntake;<br/>
	std::vector&lt;double&gt; mStdDevFoodIntake;<br/>
	//Plus<br/>
	std::vector&lt;double&gt; mPopSizeJuvenile;<br/>
	std::vector&lt;double&gt; mPopSizeAdult;<br/>
	std::vector&lt;double&gt; mMeanBodySizeJuvenile;<br/>
	std::vector&lt;double&gt; mMeanBodySizeAdult;<br/>
	std::vector&lt;double&gt; mMeanReservesJuvenile;<br/>
	std::vector&lt;double&gt; mMeanReservesAdult;<br/>
	std::vector&lt;double&gt; mMeanChanceToDieJuvenile;<br/>
	std::vector&lt;double&gt; mMeanChanceToDieAdult;<br/>
	std::vector&lt;double&gt; mMeanFoodIntakeJuvenile;<br/>
	std::vector&lt;double&gt; mMeanFoodIntakeAdult;<br/>
	//Plus plus<br/>
	std::vector&lt;double&gt; mMeanAllocation;<br/>
	std::vector&lt;double&gt; mMeanFractionBiomassPerOffspringInitial;<br/>
	std::vector&lt;double&gt; mMeanFractionBiomassPerOffspring;<br/>
	//public:<br/>
	void showYearLegend() const;<br/>
	void showYear(const unsigned int&amp;) const;<br/>
	void showYearHorizontal(const unsigned int&amp;) const;<br/>
	void saveToSingleFile(const std::string&amp;) const;<br/>
	void saveToMultipleFiles(const std::string&amp;) const;<br/>
	//void vectorToFile(const std::vector&lt;double&gt;&amp;, const std::string&amp;) const;<br/>
	//void vectorToFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, const std::string&amp;, const std::vector&lt;double&gt;&amp;,const std::string&amp;) const;<br/>
<br/>
	void addVectorToFile(const std::string&amp;, const std::vector&lt;double&gt;&amp;, std::ofstream&amp;) const;<br/>
<br/>
};<br/>
<br/>
void plotMeasurementsTable(std::vector&lt;MeasurementsTable&gt;&amp;);<br/>
void drawConclusions(const MeasurementsTable&amp;,std::vector&lt;EnumConclusion&gt;&amp;) ;<br/>
void interpretMeasurementsTables(const std::vector&lt;MeasurementsTable&gt;&amp; table);<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/OptionsFile.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/OptionsFile.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;OptionsFile.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 16 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "OptionsFile.h"<br/>
//----------------------------------------------------------------------------------<br/>
OptionsFile::OptionsFile(const std::string&amp; fileName) :<br/>
	mFileName(fileName),<br/>
	mUsesSimFile(0)<br/>
	<br/>
{<br/>
	if (fileExists(mFileName)==true)<br/>
	{<br/>
		readFromFile();<br/>
		return;<br/>
	}<br/>
	//File does not exist, fill with default values and write<br/>
	//<br/>
	mOptionsFileParameters.doPlot = false;<br/>
	mOptionsFileParameters.doWriteOutputFile = true;<br/>
	mOptionsFileParameters.showYearSummary = false;<br/>
	<br/>
	SimulationFile defaultSimFile;<br/>
	mSimulationFile.push_back(defaultSimFile);<br/>
	//mSimulationFile.push_back(SimulationFile());<br/>
<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
OptionsFile::~OptionsFile()<br/>
{<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::readFromFile()<br/>
{<br/>
	std::ifstream fileInput(mFileName.c_str());<br/>
	assert(fileInput.is_open()==true);<br/>
	unsigned int nSimulationFiles;	<br/>
	std::vector&lt;std::string&gt; simulationFileName;<br/>
	<br/>
	fileInput <br/>
		&gt;&gt; mUsesSimFile<br/>
		&gt;&gt; mOptionsFileParameters.doPlot<br/>
		&gt;&gt; mOptionsFileParameters.doWriteOutputFile<br/>
		&gt;&gt; mOptionsFileParameters.showYearSummary<br/>
		&gt;&gt; nSimulationFiles<br/>
		;<br/>
	<br/>
	simulationFileName.resize(nSimulationFiles);<br/>
	for (unsigned int i=0; i&lt;nSimulationFiles; ++i)<br/>
	{<br/>
		fileInput &gt;&gt; simulationFileName[i];<br/>
	}<br/>
	<br/>
	mSimulationFile.clear();<br/>
	for (unsigned int i=0; i&lt;nSimulationFiles; ++i)<br/>
	{<br/>
		SimulationFile temp(simulationFileName[i]);<br/>
		mSimulationFile.push_back(temp);<br/>
	}<br/>
	assert(mSimulationFile.size()==nSimulationFiles);<br/>
	fileInput.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Writes all members to disk. Does NOT do so for SimFile's.<br/>
void OptionsFile::writeToFile() const<br/>
{<br/>
	std::ofstream fileOutput(mFileName.c_str());<br/>
	assert(fileOutput.is_open()==true);<br/>
	const unsigned int nSimulationFiles = mSimulationFile.size();	<br/>
	std::vector&lt;std::string&gt; simulationFileName;<br/>
	<br/>
	fileOutput<br/>
		&lt;&lt; mUsesSimFile &lt;&lt; '\n'<br/>
		&lt;&lt; mOptionsFileParameters.doPlot &lt;&lt; '\n'<br/>
		&lt;&lt; mOptionsFileParameters.doWriteOutputFile &lt;&lt; '\n'<br/>
		&lt;&lt; mOptionsFileParameters.showYearSummary &lt;&lt; '\n'<br/>
		&lt;&lt; nSimulationFiles &lt;&lt; '\n'<br/>
		;<br/>
		<br/>
	simulationFileName.resize(nSimulationFiles);<br/>
	for (unsigned int i=0; i&lt;nSimulationFiles; ++i)<br/>
	{<br/>
		fileOutput &lt;&lt; mSimulationFile[i].getFileName() &lt;&lt; '\n';<br/>
	}<br/>
<br/>
	fileOutput.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
std::vector&lt;std::string&gt; OptionsFile::getSimulationFileNames() const<br/>
{<br/>
	const unsigned int nFileNames = mSimulationFile.size();<br/>
	std::vector&lt;std::string&gt; simulationFileName(nFileNames);<br/>
	for (unsigned int i=0; i&lt;nFileNames; ++i)<br/>
	{<br/>
		simulationFileName[i] = mSimulationFile[i].getFileName();<br/>
	}<br/>
	if (nFileNames==0) simulationFileName.push_back("&lt; None &gt;");<br/>
	return simulationFileName;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::showUser() const<br/>
{<br/>
	std::cout <br/>
		&lt;&lt; "\n\tShowing Option File '" &lt;&lt; mFileName &lt;&lt; "':"<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; "\n\tUsing Simulation File: " &lt;&lt; (mUsesSimFile==-1 ? "all." : "#"+itoa(mUsesSimFile)+".")<br/>
		&lt;&lt; "\n\tPlot results at end of simulation: " &lt;&lt; (mOptionsFileParameters.doPlot ? "yes." : "no.")<br/>
		&lt;&lt; "\n\tShow year summary: " &lt;&lt; (mOptionsFileParameters.showYearSummary ? "yes." : "no." )<br/>
		&lt;&lt; "\n\tWrite results to file at end of simulation: " &lt;&lt; (mOptionsFileParameters.doWriteOutputFile ? "yes." : "no.")<br/>
		&lt;&lt; std::endl;<br/>
<br/>
	std::vector&lt;std::string&gt; simFileName = getSimulationFileNames();<br/>
	const unsigned int nSimFileNames = simFileName.size();<br/>
	for (unsigned int i=0; i&lt;nSimFileNames; ++i)<br/>
	{<br/>
		std::cout &lt;&lt; "\tSimulation file #" &lt;&lt; i &lt;&lt; ": " &lt;&lt; simFileName[i] &lt;&lt; std::endl;<br/>
	}<br/>
	std::cout &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Shows the SimFile with index 'index' (brilliant naming).<br/>
///Index -1 denotes to show all SimFiles.<br/>
void OptionsFile::showSimFile(const int&amp; index) const<br/>
{<br/>
	assert(index&gt;=-1 &amp;&amp; index&lt;static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	if (index!=-1) <br/>
	{<br/>
		mSimulationFile[index].showUser();<br/>
	}<br/>
	else<br/>
	{<br/>
		const unsigned int nSimFiles = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFiles; ++i) mSimulationFile[i].showUser();<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::addSimFile(const std::string&amp; fileName)<br/>
{<br/>
	mSimulationFile.push_back(SimulationFile(fileName));<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Removess the SimFile with index 'index' (brilliant naming).<br/>
///Index -1 denotes to show all SimFiles.<br/>
void OptionsFile::removeSimFile(const int&amp; index)<br/>
{<br/>
	assert(index&gt;=-1 &amp;&amp; index&lt;static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	if (index!=-1) <br/>
	{<br/>
		std::cout &lt;&lt; "\n\tRemoving Simulation File '" &lt;&lt; mSimulationFile.at(index).getFileName()<br/>
			&lt;&lt; "' from Options File.\n\n";<br/>
		mSimulationFile.erase(mSimulationFile.begin()+index);<br/>
	}<br/>
	else<br/>
	{<br/>
		std::cout &lt;&lt; "\n\tRemoving all Simulation Files from Options File.\n\n";<br/>
		mSimulationFile.resize(0);<br/>
	}<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setPlotting(const bool&amp; doPlot)<br/>
{<br/>
	mOptionsFileParameters.doPlot = doPlot;<br/>
	std::cout <br/>
		&lt;&lt; "\n\tTurned plotting " <br/>
		&lt;&lt; (mOptionsFileParameters.doPlot == true ? "on" : "off")<br/>
		&lt;&lt; ".\n\n";<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setWriteOutputFile(const bool&amp; doWriteOutputFile)<br/>
{<br/>
	mOptionsFileParameters.doWriteOutputFile = doWriteOutputFile;<br/>
	std::cout <br/>
		&lt;&lt; "\n\tTurned writing to output file " <br/>
		&lt;&lt; (mOptionsFileParameters.doWriteOutputFile == true ? "on" : "off")<br/>
		&lt;&lt; ".\n\n";<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setShowYearSummary(const bool&amp; showYearSummary)<br/>
{<br/>
	mOptionsFileParameters.showYearSummary = showYearSummary;<br/>
	std::cout <br/>
		&lt;&lt; "\n\tTurned showing a year summary " <br/>
		&lt;&lt; (mOptionsFileParameters.showYearSummary == true ? "on" : "off")<br/>
		&lt;&lt; ".\n\n";<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setUsesSimFile(const int&amp; index)<br/>
{<br/>
	if (index==-1)<br/>
	{&nbsp;&nbsp; //'all'<br/>
		mUsesSimFile = index;<br/>
		std::cout &lt;&lt; "\n\tSet files in focus to 'all'.\n\n";<br/>
	}<br/>
	else if (index &gt; -1 &amp;&amp; index &lt; static_cast&lt;int&gt;(mSimulationFile.size()))<br/>
	{&nbsp;&nbsp; //Valid index<br/>
		mUsesSimFile = index;<br/>
		std::cout &lt;&lt; "\n\tSet files in focus to '" &lt;&lt; mUsesSimFile &lt;&lt; "'.\n\n";<br/>
	}<br/>
	else<br/>
	{&nbsp;&nbsp; //Invalid index<br/>
		std::cout <br/>
			&lt;&lt; "\n\tIndex '" &lt;&lt; index &lt;&lt; "' is out of range."<br/>
			&lt;&lt; "\n\tPlease give an index from 0 to (not including)" &lt;&lt; mSimulationFile.size()<br/>
			&lt;&lt; "\n"<br/>
			&lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setOutputFileName(const std::string&amp; fileName)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		const std::string fileNameNoExt = stripExtension(fileName);<br/>
		const std::string fileNameExt = getExtension(fileName);<br/>
		assert(stripExtension("test.txt")=="test");<br/>
		assert(getExtension("test.txt")=="txt");<br/>
		<br/>
		std::cout &lt;&lt; "\n\tSetting 'simulation output file' of all Simulation Files." ;<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) <br/>
		{<br/>
			const std::string newFileName = fileNameNoExt + itoa(i) + "." + fileNameExt;<br/>
			std::cout &lt;&lt; "\n\t&nbsp;&nbsp;&nbsp;&nbsp;Setting 'simulation output file' of simulation file #"<br/>
				&lt;&lt; i &lt;&lt; " to " &lt;&lt; newFileName;<br/>
			mSimulationFile[i].setOutputFileName(newFileName);<br/>
		}<br/>
		std::cout &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setOutputFileName(fileName);<br/>
		std::cout &lt;&lt; "\n\tSet 'simulation output file' of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; fileName &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setSeed(const int&amp; seed)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's seed to 'seed'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setSeed(seed);<br/>
		std::cout &lt;&lt; "\n\tSet 'seed' of all Simulation Files to " &lt;&lt; seed &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setSeed(seed);<br/>
		std::cout &lt;&lt; "\n\tSet 'seed' of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; seed &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setSimTime(const int&amp; simTime)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setMaxTime(simTime);<br/>
		std::cout &lt;&lt; "\n\tSet 'simulation running time' of all Simulation Files to " &lt;&lt; simTime &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setMaxTime(simTime);<br/>
		std::cout &lt;&lt; "\n\tSet 'simulation running time' of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; simTime &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setStartPopSize(const unsigned int&amp; popSize)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setStartPopSize(popSize);<br/>
		std::cout &lt;&lt; "\n\tSet 'starting population size' of all Simulation Files to " &lt;&lt; popSize &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setStartPopSize(popSize);<br/>
		std::cout &lt;&lt; "\n\tSet 'starting population size' of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; popSize &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setStartResources(const double&amp; resources)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setStartResources(resources);<br/>
		std::cout &lt;&lt; "\n\tSet 'starting resources' of all Simulation Files to " &lt;&lt; resources &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setStartResources(resources);<br/>
		std::cout &lt;&lt; "\n\tSet 'starting resources' of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; resources &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setBodySizeAdult(const double&amp; bodySize)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setBodySizeAdult(bodySize);<br/>
		std::cout &lt;&lt; "\n\tSet 'body size of adult' of all Simulation Files to " &lt;&lt; bodySize &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setBodySizeAdult(bodySize);<br/>
		std::cout &lt;&lt; "\n\tSet 'body size of adult' of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; bodySize &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setConstA(const double&amp; constA)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setConstA(constA);<br/>
		std::cout &lt;&lt; "\n\tSet 'constant A' of all Simulation Files to " &lt;&lt; constA &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setConstA(constA);<br/>
		std::cout &lt;&lt; "\n\tSet SimFile time of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; constA &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setConstB(const double&amp; constB)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setConstB(constB);<br/>
		std::cout &lt;&lt; "\n\tSet 'constant B' of all Simulation Files to " &lt;&lt; constB &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setConstB(constB);<br/>
		std::cout &lt;&lt; "\n\tSet 'constant B' of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; constB &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setConstC(const double&amp; constC)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setConstC(constC);<br/>
		std::cout &lt;&lt; "\n\tSet 'constant A' of all Simulation Files to " &lt;&lt; constC &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setConstC(constC);<br/>
		std::cout &lt;&lt; "\n\tSet SimFile time of Simulation File #" &lt;&lt; mUsesSimFile &lt;&lt; " to " &lt;&lt; constC &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void OptionsFile::setReproductionMode(const EnumReproductionMode&amp; enumReproductionMode)<br/>
{<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1)<br/>
	{&nbsp;&nbsp; //Set all SimFile's time to 'simTime'<br/>
		//std::for_each(mSimulationFile.begin(),mSimulationFile.end(), std::mem_fun(&amp;SimulationFile::setReproductionMode(enumReproductionMode));<br/>
		const unsigned int nSimFile = mSimulationFile.size();<br/>
		for (unsigned int i=0; i&lt;nSimFile; ++i) mSimulationFile[i].setReproductionMode(enumReproductionMode);<br/>
		std::cout &lt;&lt; "\n\tSet 'reproduction mode' of all Simulation Files to " <br/>
			&lt;&lt; enumReproductionModeToString(enumReproductionMode) &lt;&lt; "\n\n";<br/>
	}<br/>
	else<br/>
	{<br/>
		mSimulationFile[mUsesSimFile].setReproductionMode(enumReproductionMode);<br/>
		std::cout &lt;&lt; "\n\tSet SimFile time of Simulation File #" &lt;&lt; mUsesSimFile <br/>
			&lt;&lt; " to " &lt;&lt; enumReproductionModeToString(enumReproductionMode) &lt;&lt; "\n\n";<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
ParameterSetSimulation OptionsFile::getParameterSetSimulation() const<br/>
{<br/>
	assert(mSimulationFile.size()&gt;0);<br/>
	assert(mUsesSimFile&gt;=-1 &amp;&amp; mUsesSimFile &lt; static_cast&lt;int&gt;(mSimulationFile.size()));<br/>
	<br/>
	if (mUsesSimFile==-1) return mSimulationFile[0].getParameterSetSimulation();<br/>
	else return mSimulationFile[mUsesSimFile].getParameterSetSimulation();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/OptionsFile.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/OptionsFile.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;OptionsFile.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 16 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
///OptionFile embodies the user options and one or more SimulationFiles.<br/>
///<br/>
///OptionsFile is used by Experiment, which runs a Simulation for every SimulationFile.<br/>
///OptionsFile is used by Simulation, which it e.g. tells to give intermediate output.<br/>
///The SimulationFiles are the biological parameters used by a Simulation.<br/>
<br/>
 <br/>
#ifndef __OPTIONS_FILE<br/>
#define __OPTIONS_FILE<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
<br/>
#include "SimulationFile.h"<br/>
#include "HelperFunctions.h"<br/>
<br/>
struct OptionsFileParameters<br/>
{<br/>
	bool doPlot;<br/>
	bool doWriteOutputFile;<br/>
	bool showYearSummary;<br/>
};<br/>
<br/>
class OptionsFile<br/>
{<br/>
	public:<br/>
	OptionsFile(const std::string&amp; fileName = "defaultOptionsFile.txt");<br/>
	~OptionsFile();<br/>
	void showUser() const;<br/>
	void showSimFile(const int&amp;) const;<br/>
	<br/>
	void addSimFile(const std::string&amp;);<br/>
	void removeSimFile(const int&amp;);<br/>
<br/>
	<br/>
	//Getters<br/>
	std::string getFileName() const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return mFileName; }<br/>
	int getUsesSimFile() const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return mUsesSimFile; }<br/>
	ParameterSetSimulation getParameterSetSimulation() const;<br/>
	bool getDoPlot() const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return mOptionsFileParameters.doPlot; }<br/>
	bool getDoWriteOutputFile() const&nbsp;&nbsp;&nbsp;&nbsp;{ return mOptionsFileParameters.doWriteOutputFile; }<br/>
	bool getShowYearSummary() const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return mOptionsFileParameters.showYearSummary; }<br/>
	OptionsFileParameters getOptionsFileParameters() const { return mOptionsFileParameters; }<br/>
<br/>
	unsigned int getNsimFiles() const&nbsp;&nbsp;&nbsp;&nbsp;{ return mSimulationFile.size(); }<br/>
	std::string getOutputFileName(const unsigned int&amp; index) const { return mSimulationFile[index].getOutputFileName(); }<br/>
<br/>
	std::vector&lt;std::string&gt; getSimulationFileNames() const;<br/>
	const SimulationFile&amp; getSimFile(const unsigned int&amp; index) const { assert(index&gt;=0 &amp;&amp; index&lt;mSimulationFile.size()); return mSimulationFile[index]; }<br/>
	std::string getSimFileName(const unsigned int&amp; index) const { assert(index&gt;=0 &amp;&amp; index&lt;mSimulationFile.size()); return mSimulationFile[index].getFileName(); }<br/>
	std::vector&lt;SimulationFile&gt; getSimulationFiles() const { return mSimulationFile; }<br/>
<br/>
	//Setters of OptionsFile data<br/>
	void setPlotting(const bool&amp;);<br/>
	void setWriteOutputFile(const bool&amp;);<br/>
	void setShowYearSummary(const bool&amp;);<br/>
	void setUsesSimFile(const int&amp;);<br/>
<br/>
	//Setters of SimFile data <br/>
	void setOutputFileName(const std::string&amp;);<br/>
	void setSeed(const int&amp;);<br/>
	void setSimTime(const int&amp;);<br/>
	void setStartPopSize(const unsigned int&amp;);<br/>
	void setStartResources(const double&amp;);<br/>
	void setBodySizeAdult(const double&amp;);<br/>
	void setConstA(const double&amp;);<br/>
	void setConstB(const double&amp;);<br/>
	void setConstC(const double&amp;);<br/>
	void setReproductionMode(const EnumReproductionMode&amp;);<br/>
<br/>
	//----------------------------------------------------------------------------------<br/>
	//<br/>
	// COMPUTER GENERATED CODE<br/>
	// OptionsFile<br/>
	//<br/>
	//----------------------------------------------------------------------------------<br/>
	void setDconstA(const double&amp;);<br/>
	void setFconstA(const double&amp;);<br/>
	void setGconstA(const double&amp;);<br/>
	void setMconstA(const double&amp;);<br/>
	void setNconstA(const double&amp;);<br/>
	void setPconstA(const double&amp;);<br/>
	void setQconstA(const double&amp;);<br/>
	void setRconstA(const double&amp;);<br/>
	void setWconstA(const double&amp;);<br/>
	void setDconstB(const double&amp;);<br/>
	void setFconstB(const double&amp;);<br/>
	void setGconstB(const double&amp;);<br/>
	void setMconstB(const double&amp;);<br/>
	void setNconstB(const double&amp;);<br/>
	void setPconstB(const double&amp;);<br/>
	void setQconstB(const double&amp;);<br/>
	void setRconstB(const double&amp;);<br/>
	void setWconstB(const double&amp;);<br/>
	void setDconstC(const double&amp;);<br/>
	void setFconstC(const double&amp;);<br/>
	void setGconstC(const double&amp;);<br/>
	void setMconstC(const double&amp;);<br/>
	void setNconstC(const double&amp;);<br/>
	void setPconstC(const double&amp;);<br/>
	void setQconstC(const double&amp;);<br/>
	void setRconstC(const double&amp;);<br/>
	void setWconstC(const double&amp;);<br/>
	void setDconstD(const double&amp;);<br/>
	void setFconstD(const double&amp;);<br/>
	void setGconstD(const double&amp;);<br/>
	void setMconstD(const double&amp;);<br/>
	void setNconstD(const double&amp;);<br/>
	void setPconstD(const double&amp;);<br/>
	void setQconstD(const double&amp;);<br/>
	void setRconstD(const double&amp;);<br/>
	void setWconstD(const double&amp;);<br/>
	void setDconstE(const double&amp;);<br/>
	void setFconstE(const double&amp;);<br/>
	void setGconstE(const double&amp;);<br/>
	void setMconstE(const double&amp;);<br/>
	void setNconstE(const double&amp;);<br/>
	void setPconstE(const double&amp;);<br/>
	void setQconstE(const double&amp;);<br/>
	void setRconstE(const double&amp;);<br/>
	void setWconstE(const double&amp;);<br/>
	void setD(const EnumD&amp;);<br/>
	void setF(const EnumF&amp;);<br/>
	void setG(const EnumG&amp;);<br/>
	void setM(const EnumM&amp;);<br/>
	void setN(const EnumN&amp;);<br/>
	void setP(const EnumP&amp;);<br/>
	void setQ(const EnumQ&amp;);<br/>
	void setR(const EnumR&amp;);<br/>
	void setW(const EnumW&amp;);<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
	<br/>
	private:<br/>
<br/>
	const std::string mFileName;<br/>
	std::vector&lt;SimulationFile&gt; mSimulationFile;<br/>
	<br/>
	//Options<br/>
	int&nbsp;&nbsp;mUsesSimFile; //-1 if 'all'<br/>
	OptionsFileParameters mOptionsFileParameters;<br/>
	<br/>
	//File I/O<br/>
	void readFromFile();<br/>
	void writeToFile() const;<br/>
<br/>
};<br/>
<br/>
#endif //#ifndef __OPTIONS_FILE<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/ParameterSets.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/ParameterSets.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;ParameterSets.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 31 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __PARAMETERSETS_H<br/>
#define __PARAMETERSETS_H<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;memory&gt;<br/>
#include "Enumerations.h"<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
//<br/>
//&nbsp;&nbsp;COMPUTER GENERATED CODE, except for:<br/>
//&nbsp;&nbsp;&nbsp;&nbsp;- ParameterSetSimulation (at the bottom)<br/>
//<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetD<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetD() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetD&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;D.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;D.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;D.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;D.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;D.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetD* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetD&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetF<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetF() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetF&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;F.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;F.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;F.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;F.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;F.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetF* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetF&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetG<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetG() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetG&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;G.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;G.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;G.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;G.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;G.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetG* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetG&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetM<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetM() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetM&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;M.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;M.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;M.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;M.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;M.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetM* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetM&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetN<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetN() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetN&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;N.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;N.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;N.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;N.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;N.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetN* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetN&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetP<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetP() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetP&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;P.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;P.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;P.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;P.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;P.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetP* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetP&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetQ<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetQ() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetQ&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Q.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Q.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Q.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Q.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Q.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetQ* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetQ&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetR<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetR() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetR&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;R.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;R.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;R.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;R.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;R.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetR* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetR&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetW<br/>
{<br/>
	public:<br/>
	double A;<br/>
	double B;<br/>
	double C;<br/>
	double D;<br/>
	double E;<br/>
	ParameterSetW() : A(0.0), B(0.0), C(0.0), D(0.0), E(0.0) { ; }<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetW&amp; params)<br/>
	{<br/>
		os &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;W.A: " &lt;&lt; params.A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;W.B: " &lt;&lt; params.B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;W.C: " &lt;&lt; params.C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;W.D: " &lt;&lt; params.D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp; &lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;W.E: " &lt;&lt; params.E;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetW* pParams)<br/>
	{<br/>
		os &lt;&lt; *pParams; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetW&gt;&amp; pParams)<br/>
	{<br/>
		os &lt;&lt; pParams.get(); return os;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
class ParameterSetSimulation<br/>
{<br/>
	public:<br/>
	ParameterSetSimulation() :<br/>
	outputFileName("defaultOutputFile.txt"),<br/>
	seed(0),<br/>
	reproductionMode(enumReproductionModeAmount),<br/>
	startingPopSize(1000),<br/>
	startingResources(0.0),<br/>
	maxTime(100),<br/>
	A(1.0),<br/>
	B(1.0),<br/>
	C(1.0),<br/>
	bodySizeAdult(10.0),<br/>
	enumD(enumDdefault),<br/>
	enumF(enumFdefault),<br/>
	enumG(enumGconstant),<br/>
	enumM(enumMconstant),<br/>
	enumN(enumNconstant),<br/>
	enumP(enumPconstant),<br/>
	enumQ(enumQconstant),<br/>
	enumR(enumRconstant),<br/>
	enumW(enumWzero)<br/>
	{<br/>
		//Nothing<br/>
	}<br/>
	std::string outputFileName;<br/>
	int seed;<br/>
	EnumReproductionMode reproductionMode;<br/>
	unsigned int startingPopSize;<br/>
	double startingResources;<br/>
	unsigned int maxTime;<br/>
	double A, B, C;<br/>
	double bodySizeAdult;<br/>
	ParameterSetD paramsD; EnumD enumD;<br/>
	ParameterSetF paramsF; EnumF enumF;<br/>
	ParameterSetG paramsG; EnumG enumG;<br/>
	ParameterSetM paramsM; EnumM enumM;<br/>
	ParameterSetN paramsN; EnumN enumN;<br/>
	ParameterSetP paramsP; EnumP enumP;<br/>
	ParameterSetQ paramsQ; EnumQ enumQ;<br/>
	ParameterSetR paramsR; EnumR enumR;<br/>
	ParameterSetW paramsW; EnumW enumW;<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetSimulation&amp; params)<br/>
	{<br/>
		os<br/>
		&lt;&lt; "\n\tOutput file name: " &lt;&lt; params.outputFileName<br/>
		&lt;&lt; "\n\tRandom number generator seed: " &lt;&lt; params.seed<br/>
		&lt;&lt; "\n\tStarting PopSize: " &lt;&lt; params.startingPopSize<br/>
		&lt;&lt; "\n\tStarting resources: " &lt;&lt; params.startingResources<br/>
		&lt;&lt; "\n\tMax time: " &lt;&lt; params.maxTime<br/>
		&lt;&lt; "\n\talpha: " &lt;&lt; params.A<br/>
		&lt;&lt; "\n\tbeta: " &lt;&lt; params.B<br/>
		&lt;&lt; "\n\tgamma: " &lt;&lt; params.C<br/>
		&lt;&lt; "\n\tbody size adult: " &lt;&lt; params.bodySizeAdult<br/>
		&lt;&lt; "\n\tReproductionMode: " &lt;&lt; enumReproductionModeToString(params.reproductionMode) &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumDtoString(params.enumD) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsD &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumFtoString(params.enumF) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsF &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumGtoString(params.enumG) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsG &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumMtoString(params.enumM) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsM &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumNtoString(params.enumN) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsN &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumPtoString(params.enumP) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsP &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumQtoString(params.enumQ) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsQ &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumRtoString(params.enumR) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsR &lt;&lt; std::endl<br/>
		&lt;&lt; '\t' &lt;&lt; enumWtoString(params.enumW) &lt;&lt; std::endl<br/>
		&lt;&lt; params.paramsW &lt;&lt; std::endl;<br/>
		return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ParameterSetSimulation *params)<br/>
	{<br/>
		os &lt;&lt; *params; return os;<br/>
	}<br/>
	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::auto_ptr&lt;ParameterSetSimulation&gt; params)<br/>
	{<br/>
		os &lt;&lt; params.get(); return os;<br/>
	}<br/>
};<br/>
<br/>
#endif //#ifndef __PARAMETERSETS_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Random.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Random.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Random.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 24 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 *&nbsp;&nbsp;Obtained from Sander van Doorn<br/>
 *<br/>
 *<br/>
 */<br/>
//----------------------------------------------------------------------------------<br/>
#include "Random.h"<br/>
long int idum;<br/>
#define MBIG 1000000000<br/>
#define MSEED 161803398<br/>
#define MZ 0<br/>
#define FAC (1.0/MBIG)<br/>
//----------------------------------------------------------------------------------<br/>
double uniform()<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;static int inext,inextp;<br/>
&nbsp;&nbsp;static long ma[56];<br/>
&nbsp;&nbsp;static int iff=0;<br/>
&nbsp;&nbsp;long mj,mk;<br/>
&nbsp;&nbsp;int i,ii,k;<br/>
&nbsp;&nbsp;if (idum &lt; 0 || iff == 0) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;iff=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mj=MSEED-(idum &lt; 0 ? -idum : idum);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mj %= MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ma[55]=mj;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;mk=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (i=1;i&lt;=54;i++) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii=(21*i) % 55;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma[ii]=mk;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mk=mj-mk;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mk &lt; MZ) mk += MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mj=ma[ii];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (k=1;k&lt;=4;k++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=1;i&lt;=55;i++) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma[i] -= ma[1+(i+30) % 55];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ma[i] &lt; MZ) ma[i] += MBIG;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inext=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;inextp=31;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;idum=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (++inext == 56) inext=1;<br/>
&nbsp;&nbsp;if (++inextp == 56) inextp=1;<br/>
&nbsp;&nbsp;mj=ma[inext]-ma[inextp];<br/>
&nbsp;&nbsp;if (mj &lt; MZ) mj += MBIG;<br/>
&nbsp;&nbsp;ma[inext]=mj;<br/>
&nbsp;&nbsp;return mj*FAC;<br/>
&nbsp;&nbsp;} //End of: double Uniform(void)<br/>
<br/>
#undef MBIG<br/>
#undef MSEED<br/>
#undef MZ<br/>
#undef FAC<br/>
//----------------------------------------------------------------------------------<br/>
double gasdev()<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;static int iset=0;<br/>
&nbsp;&nbsp;static double gset;<br/>
&nbsp;&nbsp;double fac,r,v1,v2;<br/>
&nbsp;&nbsp;double uniform();<br/>
&nbsp;&nbsp;if&nbsp;&nbsp;(iset == 0) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;do <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1=2.0*uniform()-1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2=2.0*uniform()-1.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=v1*v1+v2*v2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (r &gt;= 1.0);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fac=sqrt(-2.0*log(r)/r);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;gset=v1*fac;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;iset=1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return v2*fac;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} //End of: if (iset == 0) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;else <br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;iset=0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return gset;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} //End of: if (iset == 0) ELSE-part<br/>
&nbsp;&nbsp;} //End of: double gasdev(void)<br/>
//----------------------------------------------------------------------------------<br/>
void setSeed(const int&amp; seed) <br/>
&nbsp;&nbsp;{ <br/>
&nbsp;&nbsp;idum = long(-abs(seed));<br/>
&nbsp;&nbsp;for (int i=0; i&lt;100; i++) uniform();<br/>
&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;} <br/>
//----------------------------------------------------------------------------------<br/>
double normal(const double&amp; mean,const double&amp; stdev)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;return gasdev()*stdev + mean;<br/>
&nbsp;&nbsp;} <br/>
//----------------------------------------------------------------------------------<br/>
int randomNumber(const int&amp; N)<br/>
&nbsp;&nbsp;{	<br/>
&nbsp;&nbsp;double x;<br/>
&nbsp;&nbsp;int out;<br/>
&nbsp;&nbsp;x=floor(uniform()*N);<br/>
&nbsp;&nbsp;out=int (x);<br/>
&nbsp;&nbsp;return out;<br/>
&nbsp;&nbsp;} <br/>
//----------------------------------------------------------------------------------<br/>
int rando(const int&amp; N)<br/>
&nbsp;&nbsp;{	<br/>
&nbsp;&nbsp;double x;<br/>
&nbsp;&nbsp;int out;<br/>
&nbsp;&nbsp;x=floor(uniform()*N);<br/>
&nbsp;&nbsp;out=int (x);<br/>
&nbsp;&nbsp;return out;<br/>
&nbsp;&nbsp;} <br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Random.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Random.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Random.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 24 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 *&nbsp;&nbsp;Obtained from Sander van Doorn<br/>
 *<br/>
 *<br/>
 */<br/>
#ifndef __SANDER_RANDOM_H<br/>
#define __SANDER_RANDOM_H<br/>
<br/>
#include &lt;stdlib.h&gt;<br/>
#include &lt;math.h&gt;<br/>
<br/>
double uniform();<br/>
double gasdev();<br/>
void setSeed(const int&amp;);<br/>
double normal(const double&amp;,const double&amp;);<br/>
int randomNumber(const int&amp;);<br/>
int rando(const int&amp;);<br/>
<br/>
#endif //#ifndef __SANDER_RANDOM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Sim4.1</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Sim4.1" border = "1"><tr><td><code>
.\"Modified from man(1) of FreeBSD, the NetBSD mdoc.template, and mdoc.samples.<br/>
.\"See Also:<br/>
.\"man mdoc.samples for a complete listing of options<br/>
.\"man mdoc for the short list of editing options<br/>
.\"/usr/share/misc/mdoc.template<br/>
.Dd Tue May 24 2005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" DATE <br/>
.Dt Sim4 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" Program name and manual section number <br/>
.Os Darwin<br/>
.Sh NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" Section Header - required - don't modify <br/>
.Nm Sim4,<br/>
.\" The following lines are read in generating the apropos(man -k) database. Use only key<br/>
.\" words here as the database is built based on the words here and in the .ND line. <br/>
.Nm Other_name_for_same_program(),<br/>
.Nm Yet another name for the same program.<br/>
.\" Use .Nm macro to designate other names for the documented program.<br/>
.Nd This line parsed for whatis database.<br/>
.Sh SYNOPSIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" Section Header - required - don't modify<br/>
.Nm<br/>
.Op Fl abcd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" [-abcd]<br/>
.Op Fl a Ar path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" [-a path] <br/>
.Op Ar file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" [file]<br/>
.Op Ar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" [file ...]<br/>
.Ar arg0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" Underlined argument - use .Ar anywhere to underline<br/>
arg2 ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" Arguments<br/>
.Sh DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" Section Header - required - don't modify<br/>
Use the .Nm macro to refer to your program throughout the man page like such:<br/>
.Nm<br/>
Underlining is accomplished with the .Ar macro like this:<br/>
.Ar underlined text .<br/>
.Pp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" Inserts a space<br/>
A list of items with descriptions:<br/>
.Bl -tag -width -indent&nbsp;&nbsp;\" Begins a tagged list <br/>
.It item a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" Each item preceded by .It macro<br/>
Description of item a<br/>
.It item b<br/>
Description of item b<br/>
.El&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" Ends the list<br/>
.Pp<br/>
A list of flags and their descriptions:<br/>
.Bl -tag -width -indent&nbsp;&nbsp;\" Differs from above in tag removed <br/>
.It Fl a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"-a flag as a list item<br/>
Description of -a flag<br/>
.It Fl b<br/>
Description of -b flag<br/>
.El&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" Ends the list<br/>
.Pp<br/>
.\" .Sh ENVIRONMENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" May not be needed<br/>
.\" .Bl -tag -width "ENV_VAR_1" -indent \" ENV_VAR_1 is width of the string ENV_VAR_1<br/>
.\" .It Ev ENV_VAR_1<br/>
.\" Description of ENV_VAR_1<br/>
.\" .It Ev ENV_VAR_2<br/>
.\" Description of ENV_VAR_2<br/>
.\" .El&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
.Sh FILES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" File used or created by the topic of the man page<br/>
.Bl -tag -width "/Users/joeuser/Library/really_long_file_name" -compact<br/>
.It Pa /usr/share/file_name<br/>
FILE_1description<br/>
.It Pa /Users/joeuser/Library/really_long_file_name<br/>
FILE_2 description<br/>
.\" .Sh DIAGNOSTICS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" May not be needed<br/>
.\" .Bl -diag<br/>
.\" .It Diagnostic Tag<br/>
.\" Diagnostic informtion here.<br/>
.\" .It Diagnostic Tag<br/>
.\" Diagnostic informtion here.<br/>
.\" .El<br/>
.Sh SEE ALSO <br/>
.\" List links in ascending order by section, alphabetically within a section.<br/>
.\" Please do not reference files that do not exist without filing a bug report<br/>
.Xr a 1 , <br/>
.Xr b 1 ,<br/>
.Xr c 1 ,<br/>
.Xr a 2 ,<br/>
.Xr b 2 ,<br/>
.Xr a 3 ,<br/>
.Xr b 3 <br/>
.\" .Sh BUGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" Document known, unremedied bugs <br/>
.\" .Sh HISTORY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \" Document history if command behaves in a unique manner <br/>
<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Sim4Interpreter.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Sim4Interpreter.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Sim4Interpreter.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 16 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "Sim4Interpreter.h"<br/>
//----------------------------------------------------------------------------------<br/>
Sim4Interpreter::Sim4Interpreter(const int&amp; argc, char* const argv[]) :<br/>
	mIniFileName("Sim4.ini"),<br/>
	mOptionsFile(getOptionsFileName()),<br/>
	mDoExit(false)<br/>
{<br/>
	//Convert char* to std::string in uppercase as commands<br/>
	//Keep a backup (for e.g. filenames) in mArgv.<br/>
	mCommand.resize(argc);<br/>
	mArgv.resize(argc);<br/>
	for (int i=0; i&lt;argc; ++i) <br/>
	{<br/>
		mArgv[i]&nbsp;&nbsp;&nbsp;&nbsp;= argv[i];<br/>
		mCommand[i] = stringToUpper(argv[i]);<br/>
	}<br/>
	//Interpret it<br/>
	interpretCommandLine();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
std::string Sim4Interpreter::getOptionsFileName() const<br/>
{<br/>
	if (fileExists(mIniFileName)==false)<br/>
	{<br/>
		std::ofstream fileOutput(mIniFileName.c_str());<br/>
		const std::string optionsFileName = "defaultOptionsFile.txt";<br/>
		fileOutput &lt;&lt; optionsFileName &lt;&lt; '\n';<br/>
		fileOutput.close();<br/>
		return optionsFileName;<br/>
	}<br/>
	else<br/>
	{<br/>
		std::ifstream fileInput(mIniFileName.c_str());<br/>
		assert(fileInput.is_open()==true);<br/>
		std::string optionsFileName;<br/>
		fileInput &gt;&gt; optionsFileName;<br/>
		fileInput.close();<br/>
		return optionsFileName;<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretCommandLine()<br/>
{<br/>
	const unsigned int nCommands = mCommand.size();<br/>
	if (nCommands==1) <br/>
	{<br/>
		//Just run the simulation...<br/>
		return;<br/>
	}<br/>
	<br/>
	<br/>
	for (unsigned int i = 0; i&lt;nCommands; ++i)<br/>
	{<br/>
		std::cout &lt;&lt; "Now interpreting: " &lt;&lt; mCommand[i] &lt;&lt; std::endl;<br/>
		if (mCommand[i]=="RUN" or mDoExit==true) <br/>
		{<br/>
			std::cout &lt;&lt; "STARTING SIMULATION(S) NOW." &lt;&lt; std::endl;<br/>
			return;<br/>
		}<br/>
		//if (mCommand[i]=="NOEXIT") doExit=false;<br/>
		//Help<br/>
		if (mCommand[i]=="HELP")&nbsp;&nbsp;interpretHelp(i);<br/>
		if (mCommand[i]=="-HELP") interpretHelp(i);<br/>
		if (mCommand[i]=="-?")&nbsp;&nbsp;&nbsp;&nbsp;interpretHelp(i); <br/>
		if (mCommand[i]=="?")&nbsp;&nbsp;&nbsp;&nbsp; interpretHelp(i);<br/>
		//General interface<br/>
		if (mCommand[i]=="ABOUT") showAbout();<br/>
		if (mCommand[i]=="ADDSIMFILE") interpretAddSimFile(i);<br/>
		if (mCommand[i]=="ASF") interpretAddSimFile(i);<br/>
		if (mCommand[i]=="COPYOPTIONFILE") interpretCopyOptionsFile(i);<br/>
		if (mCommand[i]=="COF") interpretCopyOptionsFile(i);<br/>
		if (mCommand[i]=="COPYOPTIONSFILE") interpretCopyOptionsFile(i);<br/>
		if (mCommand[i]=="COPYSIMFILE") interpretCopySimFile(i);<br/>
		if (mCommand[i]=="CSF") interpretCopySimFile(i);<br/>
		if (mCommand[i]=="REMOVESIMFILE") interpretRemoveSimFile(i);<br/>
		if (mCommand[i]=="RSF") interpretRemoveSimFile(i);<br/>
		if (mCommand[i]=="SHOWOPTIONSFILE") showOptionsFile(); <br/>
		if (mCommand[i]=="SHOWOPTIONFILE") showOptionsFile(); <br/>
		if (mCommand[i]=="SOF") showOptionsFile(); <br/>
		if (mCommand[i]=="SHOWSIMFILE") interpretShowSimFile(i);<br/>
		if (mCommand[i]=="SSF") interpretShowSimFile(i);<br/>
		if (mCommand[i]=="SHOWUSES") showUses(); <br/>
		if (mCommand[i]=="SU") showUses(); <br/>
		if (mCommand[i]=="USEOPTIONFILE") interpretUseOptionsFile(i);<br/>
		if (mCommand[i]=="USEOPTIONSFILE") interpretUseOptionsFile(i);<br/>
		if (mCommand[i]=="UOF") interpretUseOptionsFile(i);<br/>
		if (mCommand[i]=="EXECUTE") { interpretExecute(i); i=0; }<br/>
		if (mCommand[i]=="EXEC")&nbsp;&nbsp;&nbsp;&nbsp;{ interpretExecute(i); i=0; }<br/>
		if (mCommand[i]=="TEST") testFunctions();<br/>
		if (mCommand[i]=="TESTFUNCTION") testFunctions();<br/>
		if (mCommand[i]=="TESTFUNCTIONS") testFunctions();<br/>
		//Options File specific<br/>
		if (mCommand[i]=="SETPLOTTING") interpretSetPlotting(i);<br/>
		if (mCommand[i]=="SETTEXT") interpretSetText(i);<br/>
		if (mCommand[i]=="USESIM") interpretUsesSimFile(i);<br/>
		if (mCommand[i]=="USESIMFILE") interpretUsesSimFile(i);<br/>
		if (mCommand[i]=="USESSIMFILE") interpretUsesSimFile(i);<br/>
		if (mCommand[i]=="USF") interpretUsesSimFile(i);<br/>
		//Simulation File specific<br/>
		if (mCommand[i]=="SETSEED") interpretSetSeed(i);<br/>
		if (mCommand[i]=="SEED") interpretSetSeed(i);<br/>
		if (mCommand[i]=="OUTPUTFILENAME") interpretSetOutputFileName(i);<br/>
		if (mCommand[i]=="SETWRITEOUTPUTFILENAME") interpretSetOutputFileName(i);<br/>
		if (mCommand[i]=="SETOUTPUTFILENAME") interpretSetOutputFileName(i);<br/>
		if (mCommand[i]=="SETWRITEOUTPUTFILE") interpretSetWriteOutput(i);<br/>
		if (mCommand[i]=="SETWRITEOUTPUT") interpretSetWriteOutput(i);<br/>
		if (mCommand[i]=="DOWRITEOUTPUTFILE") interpretSetWriteOutput(i);<br/>
		if (mCommand[i]=="DOWRITEOUTPUT") interpretSetWriteOutput(i);<br/>
		if (mCommand[i]=="SETBODYSIZEADULT") interpretSetBodySizeAdult(i);<br/>
		if (mCommand[i]=="SETCONSTA") interpretSetConstA(i);<br/>
		if (mCommand[i]=="SETCONSTB") interpretSetConstB(i);<br/>
		if (mCommand[i]=="SETCONSTC") interpretSetConstC(i);<br/>
		if (mCommand[i]=="SETREPRODUCTIONMODE") interpretSetReproductionMode(i);<br/>
		if (mCommand[i]=="SETSIMTIME") interpretSetSimTime(i);<br/>
		if (mCommand[i]=="EXTRACTCOV") extractCov();<br/>
		//PopSize<br/>
		if (mCommand[i]=="SETSTARTPOPSIZE") interpretSetStartPopSize(i);<br/>
		if (mCommand[i]=="SETSTARTINGPOPSIZE") interpretSetStartPopSize(i);<br/>
		if (mCommand[i]=="STARTPOPSIZE") interpretSetStartPopSize(i);<br/>
		if (mCommand[i]=="STARTINGPOPSIZE") interpretSetStartPopSize(i);<br/>
		//Start resources<br/>
		if (mCommand[i]=="SETSTARTRESOURCES") interpretSetStartResources(i);<br/>
		if (mCommand[i]=="SETSTARTRESOURCE") interpretSetStartResources(i);<br/>
		if (mCommand[i]=="SETSTARTINGRESOURCES") interpretSetStartResources(i);<br/>
		if (mCommand[i]=="SETSTARTINGRESOURCE") interpretSetStartResources(i);<br/>
		if (mCommand[i]=="STARTRESOURCES") interpretSetStartResources(i);<br/>
		if (mCommand[i]=="STARTRESOURCE") interpretSetStartResources(i);<br/>
		if (mCommand[i]=="STARTINGRESOURCES") interpretSetStartResources(i);<br/>
		if (mCommand[i]=="STARTINGRESOURCE") interpretSetStartResources(i);<br/>
		//COMPUTER GENERATED<br/>
		if (mCommand[i]=="SETD") interpretSetD(i);<br/>
		if (mCommand[i]=="SETF") interpretSetF(i);<br/>
		if (mCommand[i]=="SETG") interpretSetG(i);<br/>
		if (mCommand[i]=="SETM") interpretSetM(i);<br/>
		if (mCommand[i]=="SETN") interpretSetN(i);<br/>
		if (mCommand[i]=="SETP") interpretSetP(i);<br/>
		if (mCommand[i]=="SETQ") interpretSetQ(i);<br/>
		if (mCommand[i]=="SETR") interpretSetR(i);<br/>
		if (mCommand[i]=="SETW") interpretSetW(i);<br/>
		//&nbsp;&nbsp;COMPUTER GENERATED CODE<br/>
		if (mCommand[i]=="SETDCONSTA") interpretSetDconstA(i);<br/>
		if (mCommand[i]=="SETFCONSTA") interpretSetFconstA(i);													<br/>
		if (mCommand[i]=="SETGCONSTA") interpretSetGconstA(i);													<br/>
		if (mCommand[i]=="SETMCONSTA") interpretSetMconstA(i);													<br/>
		if (mCommand[i]=="SETNCONSTA") interpretSetNconstA(i);													<br/>
		if (mCommand[i]=="SETPCONSTA") interpretSetPconstA(i);													<br/>
		if (mCommand[i]=="SETQCONSTA") interpretSetQconstA(i);													<br/>
		if (mCommand[i]=="SETRCONSTA") interpretSetRconstA(i);													<br/>
		if (mCommand[i]=="SETWCONSTA") interpretSetWconstA(i);													<br/>
		if (mCommand[i]=="SETDCONSTB") interpretSetDconstB(i);													<br/>
		if (mCommand[i]=="SETFCONSTB") interpretSetFconstB(i);													<br/>
		if (mCommand[i]=="SETGCONSTB") interpretSetGconstB(i);													<br/>
		if (mCommand[i]=="SETMCONSTB") interpretSetMconstB(i);													<br/>
		if (mCommand[i]=="SETNCONSTB") interpretSetNconstB(i);													<br/>
		if (mCommand[i]=="SETPCONSTB") interpretSetPconstB(i);													<br/>
		if (mCommand[i]=="SETQCONSTB") interpretSetQconstB(i);													<br/>
		if (mCommand[i]=="SETRCONSTB") interpretSetRconstB(i);													<br/>
		if (mCommand[i]=="SETWCONSTB") interpretSetWconstB(i);													<br/>
		if (mCommand[i]=="SETDCONSTC") interpretSetDconstC(i);													<br/>
		if (mCommand[i]=="SETFCONSTC") interpretSetFconstC(i);													<br/>
		if (mCommand[i]=="SETGCONSTC") interpretSetGconstC(i);													<br/>
		if (mCommand[i]=="SETMCONSTC") interpretSetMconstC(i);													<br/>
		if (mCommand[i]=="SETNCONSTC") interpretSetNconstC(i);													<br/>
		if (mCommand[i]=="SETPCONSTC") interpretSetPconstC(i);													<br/>
		if (mCommand[i]=="SETQCONSTC") interpretSetQconstC(i);													<br/>
		if (mCommand[i]=="SETRCONSTC") interpretSetRconstC(i);													<br/>
		if (mCommand[i]=="SETWCONSTC") interpretSetWconstC(i);													<br/>
		if (mCommand[i]=="SETDCONSTD") interpretSetDconstD(i);													<br/>
		if (mCommand[i]=="SETFCONSTD") interpretSetFconstD(i);													<br/>
		if (mCommand[i]=="SETGCONSTD") interpretSetGconstD(i);													<br/>
		if (mCommand[i]=="SETMCONSTD") interpretSetMconstD(i);													<br/>
		if (mCommand[i]=="SETNCONSTD") interpretSetNconstD(i);													<br/>
		if (mCommand[i]=="SETPCONSTD") interpretSetPconstD(i);													<br/>
		if (mCommand[i]=="SETQCONSTD") interpretSetQconstD(i);													<br/>
		if (mCommand[i]=="SETRCONSTD") interpretSetRconstD(i);													<br/>
		if (mCommand[i]=="SETWCONSTD") interpretSetWconstD(i);													<br/>
		if (mCommand[i]=="SETDCONSTE") interpretSetDconstE(i);													<br/>
		if (mCommand[i]=="SETFCONSTE") interpretSetFconstE(i);													<br/>
		if (mCommand[i]=="SETGCONSTE") interpretSetGconstE(i);													<br/>
		if (mCommand[i]=="SETMCONSTE") interpretSetMconstE(i);													<br/>
		if (mCommand[i]=="SETNCONSTE") interpretSetNconstE(i);													<br/>
		if (mCommand[i]=="SETPCONSTE") interpretSetPconstE(i);													<br/>
		if (mCommand[i]=="SETQCONSTE") interpretSetQconstE(i);													<br/>
		if (mCommand[i]=="SETRCONSTE") interpretSetRconstE(i);													<br/>
		if (mCommand[i]=="SETWCONSTE") interpretSetWconstE(i);													<br/>
<br/>
	}<br/>
<br/>
	//No simulation to be done, except when execute is calling this function.<br/>
	//if (doExit==true) <br/>
	exit(0);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::setOptionsFileName(const std::string&amp; fileName) const<br/>
{<br/>
	assert(fileExists(mIniFileName)==true);<br/>
	std::ofstream fileOutput(mIniFileName.c_str());<br/>
	fileOutput &lt;&lt; fileName &lt;&lt; '\n';<br/>
	fileOutput.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretExecute(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{<br/>
		std::cout &lt;&lt; "\n\tPlease specify the file name of the file you want to execute.\n\n";<br/>
		return;<br/>
	}<br/>
<br/>
	assert(index+1&lt;mCommand.size());<br/>
	std::string fileName = mArgv[index+1];<br/>
	if (fileExists(fileName)==false)<br/>
	{<br/>
		std::cout &lt;&lt; "\n\tFile '" &lt;&lt; fileName &lt;&lt; "' does not exist. Therefore, it cannot be used as an execution file.\n\n";<br/>
		return;<br/>
	}<br/>
	<br/>
	mArgv.resize(0); mCommand.resize(0);<br/>
	mArgv = fileToVector(fileName);<br/>
	coutVector(mArgv);<br/>
	mArgv.push_back("run");<br/>
	const unsigned int size = mArgv.size();<br/>
	mCommand.resize(size);<br/>
	for (unsigned int i=0; i&lt;size; ++i) mCommand[i] = stringToUpper(mArgv[i]);<br/>
	interpretCommandLine();<br/>
	mDoExit = true;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::extractCov() const<br/>
{<br/>
	std::cout &lt;&lt; "NOT PROGRAMMED YET" &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::testFunctions() const<br/>
{<br/>
	ParameterSetSimulation params; //Default params<br/>
	if (mOptionsFile.getNsimFiles() &gt; 0) params =&nbsp;&nbsp;mOptionsFile.getParameterSetSimulation();<br/>
	std::auto_ptr&lt;StrategyDdefault&gt; pDdefault(new StrategyDdefault(&amp;params.paramsD));<br/>
	std::auto_ptr&lt;StrategyFdefault&gt; pFdefault(new StrategyFdefault(&amp;params.paramsF));<br/>
	std::auto_ptr&lt;StrategyGconstant&gt; pGconstant(new StrategyGconstant(&amp;params.paramsG));<br/>
	std::auto_ptr&lt;StrategyGplastic&gt;&nbsp;&nbsp;pGplastic( new StrategyGplastic( &amp;params.paramsG));<br/>
	std::auto_ptr&lt;StrategyMdefault&gt;&nbsp;&nbsp;pMdefault( new StrategyMdefault( &amp;params.paramsM));<br/>
	std::auto_ptr&lt;StrategyMconstant&gt; pMconstant(new StrategyMconstant(&amp;params.paramsM));<br/>
	std::auto_ptr&lt;StrategyNplastic&gt;&nbsp;&nbsp;pNplastic(new StrategyNplastic(&amp;params.paramsN));<br/>
	std::auto_ptr&lt;StrategyNconstant&gt; pNconstant(new StrategyNconstant(&amp;params.paramsN));<br/>
	std::auto_ptr&lt;StrategyPplastic&gt;&nbsp;&nbsp;pPplastic( new StrategyPplastic( &amp;params.paramsP));<br/>
	std::auto_ptr&lt;StrategyPconstant&gt; pPconstant(new StrategyPconstant(&amp;params.paramsP));<br/>
	std::auto_ptr&lt;StrategyQdefault&gt;&nbsp;&nbsp;pQdefault(new StrategyQdefault(&amp;params.paramsQ));<br/>
	std::auto_ptr&lt;StrategyQconstant&gt; pQconstant(new StrategyQconstant(&amp;params.paramsQ));<br/>
	std::auto_ptr&lt;StrategyRconstant&gt; pRconstant(new StrategyRconstant(&amp;params.paramsR));<br/>
	std::auto_ptr&lt;StrategyRlogistic&gt; pRlogistic(new StrategyRlogistic(&amp;params.paramsR));<br/>
	std::auto_ptr&lt;StrategyRcosine&gt;&nbsp;&nbsp; pRcosine(&nbsp;&nbsp;new StrategyRcosine(&nbsp;&nbsp;&amp;params.paramsR));<br/>
	std::auto_ptr&lt;StrategyWzero&gt;&nbsp;&nbsp;&nbsp;&nbsp;pWzero(new StrategyWzero(&amp;params.paramsW));<br/>
	std::auto_ptr&lt;StrategyWuniform&gt; pWuniform(new StrategyWuniform(&amp;params.paramsW));<br/>
<br/>
	std::cout &lt;&lt; "Now testing D." &lt;&lt; std::endl;<br/>
	pDdefault-&gt;testMe();<br/>
	std::cout &lt;&lt; "Now testing F." &lt;&lt; std::endl;<br/>
	pFdefault-&gt;testMe();<br/>
	std::cout &lt;&lt; "Now testing G." &lt;&lt; std::endl;<br/>
	pGconstant-&gt;testMe();<br/>
	pGplastic-&gt;testMe();<br/>
	std::cout &lt;&lt; "Now testing M." &lt;&lt; std::endl;<br/>
	pMdefault-&gt;testMe();<br/>
	pMconstant-&gt;testMe();<br/>
	std::cout &lt;&lt; "Now testing N." &lt;&lt; std::endl;<br/>
	pNplastic-&gt;testMe();<br/>
	pNconstant-&gt;testMe();<br/>
	std::cout &lt;&lt; "Now testing P." &lt;&lt; std::endl;<br/>
	pPplastic-&gt;testMe();<br/>
	pPconstant-&gt;testMe();<br/>
	std::cout &lt;&lt; "Now testing Q." &lt;&lt; std::endl;<br/>
	pQdefault-&gt;testMe();<br/>
	pQconstant-&gt;testMe();<br/>
	std::cout &lt;&lt; "Now testing R." &lt;&lt; std::endl;<br/>
	pRconstant-&gt;testMe();<br/>
	pRlogistic-&gt;testMe();<br/>
	pRcosine-&gt;testMe();<br/>
	std::cout &lt;&lt; "Now testing W." &lt;&lt; std::endl;<br/>
	pWzero-&gt;testMe();<br/>
	pWuniform-&gt;testMe();<br/>
	std::cout &lt;&lt; "Done testing." &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretUseOptionsFile(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{<br/>
		std::cout &lt;&lt; "\n\tPlease specify the file name of the Options File you want to use.\n\n";<br/>
		return;<br/>
	}<br/>
<br/>
	assert(index+1&lt;mCommand.size());<br/>
	std::string fileName = mArgv[index+1];<br/>
	if (fileExists(fileName)==false)<br/>
	{<br/>
		std::cout &lt;&lt; "\n\tFile '" &lt;&lt; fileName &lt;&lt; "' does not exist. Therefore, it cannot be used as an Options File.\n\n";<br/>
		return;<br/>
	}<br/>
	<br/>
	setOptionsFileName(fileName);<br/>
	std::cout &lt;&lt; "\n\tFile '" &lt;&lt; fileName &lt;&lt; "' set to the Options File now used.\n\n";<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretShowSimFile(const unsigned int&amp; index) const<br/>
{<br/>
	int simFileNumber;<br/>
	if (index+1==mCommand.size())<br/>
	{<br/>
		const int usesSimFile = mOptionsFile.getUsesSimFile();<br/>
		std::cout &lt;&lt; "\n\tShowing Simulation File: " &lt;&lt; (usesSimFile==-1 ? "all." : "#"+itoa(usesSimFile)+".") &lt;&lt; std::endl;<br/>
		simFileNumber = usesSimFile;<br/>
	}<br/>
	else <br/>
	{<br/>
		assert(index+1&lt;mCommand.size());<br/>
		std::string nextInput = mCommand[index+1];<br/>
		if (isInt(nextInput,simFileNumber)==true)<br/>
		{&nbsp;&nbsp; //User gives SimFile index<br/>
			if (simFileNumber&lt;0)<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, as they cannot be negative.\n\n";<br/>
				return;<br/>
			}<br/>
			if (simFileNumber&gt;=static_cast&lt;int&gt;(mOptionsFile.getNsimFiles()))<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, as this index does not exist.\n\n";<br/>
				return;<br/>
			}<br/>
			std::cout &lt;&lt; "\n\tShowing Simulation File: #" &lt;&lt; simFileNumber &lt;&lt; std::endl;<br/>
		}<br/>
		else<br/>
		{&nbsp;&nbsp; //User typed 'all' or bullshit<br/>
			if (nextInput=="ALL")<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tShowing Simulation File: all." &lt;&lt; std::endl;<br/>
				simFileNumber=-1;<br/>
			}<br/>
			else<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, can only be either an index or 'all'.\n\n";<br/>
				return;<br/>
			}<br/>
		}<br/>
	<br/>
	}<br/>
<br/>
	mOptionsFile.showSimFile(simFileNumber);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Copies an Options File<br/>
void Sim4Interpreter::interpretCopyOptionsFile(const unsigned int&amp; index) const<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed only 'copyOptionsFile'<br/>
		std::cout &lt;&lt; "\n\tPlease add the target's file name.\n\n";<br/>
		return;<br/>
	}<br/>
	if (index+2&gt;=mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'copyOptionsFile [something]'<br/>
		const std::string optionsFileNameFrom = mOptionsFile.getFileName();<br/>
		const std::string optionsFileNameTo&nbsp;&nbsp; = mArgv[index+1];<br/>
		std::cout &lt;&lt; "\n\tCopying Options File: '" &lt;&lt; optionsFileNameFrom <br/>
			&lt;&lt; "' to '"&lt;&lt; optionsFileNameTo &lt;&lt; "'.\n\n";<br/>
		copyFile(optionsFileNameFrom,optionsFileNameTo);<br/>
	}<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Copies a SimFile<br/>
void Sim4Interpreter::interpretCopySimFile(const unsigned int&amp; index) const<br/>
{<br/>
	if (mOptionsFile.getNsimFiles()==0)<br/>
	{<br/>
		std::cout &lt;&lt; "\n\tNo Simulation Files to copy. Please use 'addSimFile' command first.\n\n";<br/>
		return;<br/>
	}<br/>
<br/>
	std::string simFileNameFrom;<br/>
	std::string simFileNameTo;<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed only 'copySimfile'<br/>
		std::cout &lt;&lt; "\n\tPlease add the target's file name.\n\n";<br/>
		return;<br/>
	}<br/>
	if (index+2==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'copySimfile [something]', use the SimFile in focus<br/>
		const int usesSimFile = mOptionsFile.getUsesSimFile();<br/>
		if (usesSimFile==-1)<br/>
		{<br/>
			std::cout &lt;&lt; "\n\tIncorrect Simulation file index 'all': cannot copy all files\n\n";<br/>
			return;<br/>
		}<br/>
		assert((usesSimFile&gt;-1 &amp;&amp; usesSimFile&lt;static_cast&lt;int&gt;(mOptionsFile.getNsimFiles())));<br/>
		simFileNameFrom = mOptionsFile.getSimFileName(usesSimFile);<br/>
		simFileNameTo&nbsp;&nbsp; = mArgv[index+1];<br/>
	}<br/>
	else <br/>
	{&nbsp;&nbsp; //User typed 'copySimfile [something] [something]' (and perhaps more [something]'s)<br/>
		assert(index+3&lt;=mCommand.size());<br/>
		const std::string nextInput = mCommand[index+1];<br/>
		int simFileNumber;<br/>
		if (isInt(nextInput,simFileNumber)==true)<br/>
		{&nbsp;&nbsp; //User gives SimFile index<br/>
			if (simFileNumber&lt;0)<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, as they cannot be negative.\n\n";<br/>
				return;<br/>
			}<br/>
			if (simFileNumber&gt;=static_cast&lt;int&gt;(mOptionsFile.getNsimFiles()))<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, as this index does not exist.\n\n";<br/>
				return;<br/>
			}<br/>
			simFileNameFrom = mOptionsFile.getSimFileName(simFileNumber);<br/>
			simFileNameTo&nbsp;&nbsp; = mArgv[index+2];<br/>
		}<br/>
		else<br/>
		{&nbsp;&nbsp; //User typed 'all' or bullshit<br/>
			if (nextInput=="ALL")<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tCannot copy 'all' files. Please use an index.\n\n";<br/>
			}<br/>
			else<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, can only be an index.\n\n";<br/>
				return;<br/>
			}<br/>
		}<br/>
	}<br/>
<br/>
	std::cout &lt;&lt; "\n\tCopying Simulation File: '" &lt;&lt; simFileNameFrom &lt;&lt; "' to '"&lt;&lt; simFileNameTo &lt;&lt; "'.\n\n";<br/>
	copyFile(simFileNameFrom,simFileNameTo);<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretRemoveSimFile(const unsigned int&amp; index)<br/>
{<br/>
	int simFileNumber;<br/>
	if (index+1==mCommand.size())<br/>
	{<br/>
		const int usesSimFile = mOptionsFile.getUsesSimFile();<br/>
		std::cout &lt;&lt; "\n\tRemoving Simulation File: " &lt;&lt; (usesSimFile==-1 ? "all." : "#"+itoa(usesSimFile)+".") &lt;&lt; std::endl;<br/>
		simFileNumber = -1;<br/>
	}<br/>
	else <br/>
	{<br/>
		assert(index+1&lt;mCommand.size());<br/>
		std::string nextInput = mCommand[index+1];<br/>
		if (isInt(nextInput,simFileNumber)==true)<br/>
		{&nbsp;&nbsp; //User gives SimFile index<br/>
			if (simFileNumber&lt;0)<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, as they cannot be negative.\n\n";<br/>
				return;<br/>
			}<br/>
			if (simFileNumber&gt;=static_cast&lt;int&gt;(mOptionsFile.getNsimFiles()))<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, as this index does not exist.\n\n";<br/>
				return;<br/>
			}<br/>
			std::cout &lt;&lt; "\n\tRemoving Simulation File: #" &lt;&lt; simFileNumber &lt;&lt; std::endl;<br/>
		}<br/>
		else<br/>
		{&nbsp;&nbsp; //User typed 'all' or bullshit<br/>
			if (nextInput=="ALL")<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tRemoving Simulation File: all." &lt;&lt; std::endl;<br/>
				simFileNumber=-1;<br/>
			}<br/>
			else<br/>
			{<br/>
				std::cout &lt;&lt; "\n\tIncorrect Simulation file index, can only be either an index or 'all'.\n\n";<br/>
				return;<br/>
			}<br/>
		}<br/>
	<br/>
	}<br/>
<br/>
	mOptionsFile.removeSimFile(simFileNumber);<br/>
<br/>
	//If all files are removed, 'usesSimFile' is set to 'all'<br/>
	//if (mOptionsFile.getNsimFiles()==0)	mOptionsFile.setUsesSimFile(-1);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretAddSimFile(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{<br/>
		std::cout &lt;&lt; "\n\tPlease specify the file name of the Simulation file you want to add.\n\n";<br/>
		return;<br/>
	}<br/>
<br/>
	assert(index+1&lt;mCommand.size());<br/>
	std::string fileName = mArgv[index+1];<br/>
	if (fileExists(fileName)==false)<br/>
	{<br/>
		std::cout &lt;&lt; "\n\tFile '" &lt;&lt; fileName &lt;&lt; "' does not exist. Therefore, it cannot be added to the Options File.\n\n";<br/>
		return;<br/>
	}<br/>
	<br/>
	mOptionsFile.addSimFile(fileName);<br/>
	std::cout &lt;&lt; "\n\tFile '" &lt;&lt; fileName &lt;&lt; "' added to the Options File.\n\n";<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretUsesSimFile(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setUses' only<br/>
		std::cout<br/>
			&lt;&lt; "\n\tPlease specify to INDEX or 'all' for the Simulation File in focus.\n"<br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
<br/>
	if (nextCommand=="ALL") <br/>
	{<br/>
		mOptionsFile.setUsesSimFile(-1); //-1 = 'all'<br/>
		return;<br/>
	}<br/>
<br/>
	int newUsesNumber=-1;<br/>
	if (isInt(nextCommand,newUsesNumber)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setSimTime [non-integer]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the index of the Simulation File you want to use as a NUMBER,"<br/>
			&lt;&lt; "\n\te.g. './Sim4 setUses 0', or use './Sim4 setUses all'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
	}<br/>
<br/>
	//This sets the Uses to 'index'. OptionsFile handles if 'index' is out of range<br/>
	mOptionsFile.setUsesSimFile(newUsesNumber);<br/>
	//std::cout &lt;&lt; "\n\tSet the files in focus to '" &lt;&lt; index &lt;&lt; "'.\n" &lt;&lt; std::endl;<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetText(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setPlotting' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify if you want to turn showing the year's summary 'on' or 'off',"<br/>
			&lt;&lt; "\n\te.g. './Sim4 setText on' or './Sim4 setText off'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
	if (nextCommand=="ON")<br/>
	{<br/>
		mOptionsFile.setShowYearSummary(true);<br/>
	}<br/>
	else<br/>
	if (nextCommand=="OFF")<br/>
	{<br/>
		mOptionsFile.setShowYearSummary(false);<br/>
	}<br/>
	else<br/>
	{<br/>
		std::cout <br/>
			&lt;&lt; "\n\tShowing the year's summary can only be turned 'on' or 'off',"<br/>
			&lt;&lt; "\n\te.g. './Sim4 setText on' or './Sim4 setText off'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
	}<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetPlotting(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setPlotting' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify if you want to turn plotting 'on' or 'off',"<br/>
			&lt;&lt; "\n\te.g. './Sim4 setPlotting on' or './Sim4 setPlotting off'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
	if (nextCommand=="ON")<br/>
	{<br/>
		mOptionsFile.setPlotting(true);<br/>
	}<br/>
	else<br/>
	if (nextCommand=="OFF")<br/>
	{<br/>
		mOptionsFile.setPlotting(false);<br/>
	}<br/>
	else<br/>
	{<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlotting can only be turned 'on' or 'off',"<br/>
			&lt;&lt; "\n\te.g. './Sim4 setPlotting on' or './Sim4 setPlotting off'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
	}<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetSimTime(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setSimTime' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the amount of timesteps you want to"<br/>
			&lt;&lt; "\n\tset the simulation time to, e.g. './Sim4 setSimTime 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
	int newTimeStepsNumber=-1;<br/>
	if (isInt(nextCommand,newTimeStepsNumber)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setSimTime [non-integer]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the amount of timesteps you want to set the"<br/>
			&lt;&lt; "\n\t simulation time to as a NUMBER, e.g. './Sim4 setSimTime 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	if (newTimeStepsNumber&lt;=0) <br/>
	{&nbsp;&nbsp; //User typed 'setSimTime [zero or smaller]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the amount of timesteps you want to set the"<br/>
			&lt;&lt; "\n\t simulation time to as a POSITIVE NON_ZERO NUMBER, e.g. './Sim4 setSimTime 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	mOptionsFile.setSimTime(newTimeStepsNumber);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetOutputFileName(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setOutputFile' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the NAME of the output file."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setOutputFile myOutput1.rda'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	mOptionsFile.setOutputFileName(mArgv[index+1]);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetSeed(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setSeed' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the number of the seed you want to"<br/>
			&lt;&lt; "\n\tset the random number generator to, e.g. './Sim4 setSeed 0'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
	int newSeed=-1;<br/>
	if (isInt(nextCommand,newSeed)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setSeede [non-integer]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease specify the number of the seed you want to"<br/>
			&lt;&lt; "\n\tset the random number generator to as a NUMBER, e.g. './Sim4 setSeed 0'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	mOptionsFile.setSeed(newSeed);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetWriteOutput(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setWriteOutput' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify if you want to turn writing to a file 'on' or 'off',"<br/>
			&lt;&lt; "\n\te.g. './Sim4 setWriteOutput on' or './Sim4 setWriteOutput off'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
	if (nextCommand=="ON")<br/>
	{<br/>
		mOptionsFile.setWriteOutputFile(true);<br/>
	}<br/>
	else<br/>
	if (nextCommand=="OFF")<br/>
	{<br/>
		mOptionsFile.setWriteOutputFile(false);<br/>
	}<br/>
	else<br/>
	{<br/>
		std::cout <br/>
			&lt;&lt; "\n\tWriting to an output file can only be turned 'on' or 'off',"<br/>
			&lt;&lt; "\n\te.g. './Sim4 setWriteOutput on' or './Sim4 setWriteOutput off'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
	}<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetStartPopSize(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setStartPopSize' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the VALUE of the starting population size."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartPopSize 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
<br/>
	int newStartPopSize=-1;<br/>
	if (isInt(nextCommand,newStartPopSize)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setStartPopSize [non-integer]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the value of the starting population size as a NUMBER."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartPopSize 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	if (newStartPopSize&lt;=0)<br/>
	{<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input for the value of the starting population size a POSITIVE NON_ZERO number."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartPopSize 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	//Success. OptionsFile produces this output<br/>
	mOptionsFile.setStartPopSize(newStartPopSize);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetStartResources(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setStartPopSize' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the VALUE of the starting population size."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartPopSize 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
<br/>
	double newStartResources=-1;<br/>
	if (isDouble(nextCommand,newStartResources)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setStartResources [non-integer]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the amount of starting resources as a NUMBER."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartResources 0.1'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	if (newStartResources&lt;0.0)<br/>
	{<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the amount of starting resources as a POSITIVE number."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartResources 0.1'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	//Success. OptionsFile produces this output<br/>
	mOptionsFile.setStartResources(newStartResources);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetBodySizeAdult(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setStartPopSize' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the VALUE of the starting population size."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartPopSize 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
<br/>
	double newBodySize=-1.0;<br/>
	if (isDouble(nextCommand,newBodySize)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setBodySizeAdult [non-double]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the body size to become an adult as a NUMBER."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setBodySizeAdult 1.5'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	if (newBodySize&lt;0.0)<br/>
	{&nbsp;&nbsp; //User typed 'setBodySizeAdult [non-double]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input for the body size to become an adult a POSITIVE number."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setBodySizeAdult 1.5'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	//Success. OptionsFile handles the feedback to the user.<br/>
	mOptionsFile.setBodySizeAdult(newBodySize);<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetConstA(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setStartPopSize' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the VALUE of the starting population size."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartPopSize 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
	double newConstA=-1.0;<br/>
	if (isDouble(nextCommand,newConstA)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setConstA [non-double]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the value of constant 'A' as a NUMBER."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setConstA 0.9'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	if (newConstA&lt;0.0) // || newConstA&gt;1.0)<br/>
	{&nbsp;&nbsp; //User typed 'setConstA [non-fraction]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the value of constant 'A' as a POSITIVE VALUE."<br/>
			&lt;&lt; "\n\ti.e. a value from 0.0 to and including 1.0."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setConstA 0.9'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	//Success. OptionsFile handles the feedback to the user<br/>
	mOptionsFile.setConstA(newConstA);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetConstB(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setStartPopSize' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the VALUE of the starting population size."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartPopSize 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
	double newConstB=-1.0;<br/>
	if (isDouble(nextCommand,newConstB)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setConstB [non-double]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the value of constant 'B' as a NUMBER."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setConstB 0.9'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	if (newConstB&lt;0.0) // || newConstB&gt;1.0)<br/>
	{&nbsp;&nbsp; //User typed 'setConstB [non-fraction]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the value of constant 'B' as a POSITIVE VALUE."<br/>
			&lt;&lt; "\n\ti.e. a value from 0.0 to and including 1.0."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setConstB 0.9'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	//Success. OptionsFile handles the feedback to the user<br/>
	mOptionsFile.setConstB(newConstB);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetConstC(const unsigned int&amp; index)<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'setStartPopSize' only<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease also specify the VALUE of the starting population size."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setStartPopSize 1000'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	const std::string nextCommand = mCommand[index+1];<br/>
	double newConstC=-1.0;<br/>
	if (isDouble(nextCommand,newConstC)==false)<br/>
	{&nbsp;&nbsp; //User typed 'setConstC [non-double]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the value of constant 'C' as a NUMBER."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setConstC 0.9'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
<br/>
	if (newConstC&lt;0.0) // || newConstC&gt;1.0)<br/>
	{&nbsp;&nbsp; //User typed 'setConstC [non-fraction]'<br/>
		std::cout <br/>
			&lt;&lt; "\n\tPlease input the value of constant 'C' as a POSITIVE VALUE."<br/>
			&lt;&lt; "\n\ti.e. a value from 0.0 to and including 1.0."<br/>
			&lt;&lt; "\n\te.g. './Sim4 setConstC 0.9'" <br/>
			&lt;&lt; std::endl &lt;&lt; std::endl;<br/>
		return;<br/>
	}<br/>
	<br/>
	//Success. OptionsFile handles the feedback to the user<br/>
	mOptionsFile.setConstC(newConstC);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretHelp(const unsigned int&amp; index) const<br/>
{<br/>
	if (index+1==mCommand.size())<br/>
	{&nbsp;&nbsp; //User typed 'help' only<br/>
		showHelp();<br/>
		return;<br/>
	}<br/>
<br/>
	if (&nbsp;&nbsp; mCommand[index+1]=="OPTIONFILE"&nbsp;&nbsp;|| mCommand[index+1]=="OPTIONSFILE")<br/>
	{&nbsp;&nbsp; //User typed 'help OptionsFile'<br/>
		showHelpOptionFile();<br/>
	}<br/>
<br/>
	if (&nbsp;&nbsp; mCommand[index+1]=="SIMFILE")<br/>
	{&nbsp;&nbsp; //User typed 'help SimFile'<br/>
		showHelpSimFile();<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::showHelp() const<br/>
{<br/>
	std::cout <br/>
		&lt;&lt; "\n\tHelp for Sim4, by Richel Bilderbeek." <br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; "\n\tA simulation uses at least two files: "<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;1) A single Options file: options for simulation, e.g. write results to disk."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;2) One or more Simulation files: parameters for the simulation, e.g. the starting population size."<br/>
		&lt;&lt; "\n\tThe Options file is connected to one or more Simulation files."<br/>
		&lt;&lt; "\n\tWhen changing a Simulation file, you change only one (or all) of those the Options file is connected to."<br/>
		&lt;&lt; "\n\tThis enables you to do multiple simulations with your favorite options."<br/>
		&lt;&lt; "\n\tWhen modifying SimFiles, you either specify the index of this SimFile, or write 'all' for all SimFiles."<br/>
		&lt;&lt; "\n\tWhen giving neither, the focused Simulation file(s) is used."<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; "\n\tProgram usage options: "<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;./Sim4 [option1] [option2] [etc]"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;&nbsp;&nbsp; without options, the simulation is started with current Options file ('defaultOptionsFile.txt' at start) and its connected Simulation file(s)."<br/>
		&lt;&lt; "\n\tOptions:" <br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;showUses : shows Options file and the Simulation file(s) the simulation will use."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;showOptionsFile : shows current Options file and contents."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;showSimFile : shows the Simulation file(s) set by useSimFile."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;showSimFile {[n],all} : shows 'n'-th or all Simulation file(s) that current Options file is connected to."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;useOptionsFile \"optionsfilename\" : use Options file with 'optionsfilename'."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;addSimFile \"simulationfilename\" : adds Simulation file to current Options file."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;removeSimFile : removes Simulation file(s) set by useSimFile."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;removeSimFile {[n],all} : removes 'n'-th or all Simulation file(s) from current Options file. "<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;useSimFile {[n],all} : sets focus on Simulation file 'n' or all"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;copyOptionsFile \"filename\" : copies current Options file to 'filename'."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;copySimFile [n] \"filename\" : copies 'n'-th Simulation file to 'filename'."<br/>
		&lt;&lt; "\n\tOptions for modifying Options file:"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;help OptionFile : displays more options for Options file."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setPlotting {on,off} : turns final plotting on or off."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setWriteOutput {on,off} : turns writing to outputfile on or off."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setWriteOutputFile \"filename\" : sets simulation output file to 'filename'."<br/>
		&lt;&lt; "\n\tOptions for modifying Simulation file:"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;help SimFile : displays more options for Options file."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setSimTime [number] {[n],all} : sets 'n'-th or all simulation(s) time(s) to 'number' timesteps."<br/>
		&lt;&lt; "\n" <br/>
		&lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::showHelpOptionFile() const<br/>
{<br/>
	std::cout <br/>
		&lt;&lt; "\n\tHelp on Option Files."<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; "\n\tAn Option File contains options for one or more Simulation Files. When an experiment is started,"<br/>
		&lt;&lt; "\n\tfor every Simulation File one simulation is run, with the options from the Options File."<br/>
		&lt;&lt; "\n"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setText {on,off} : turns showing year summary on screen on or off."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setPlotting {on,off} : turns final plotting on or off."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setWriteOutput {on,off} : turns writing to outputfile on or off."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setWriteOutputFile \"filename\" : sets simulation output file to 'filename'."<br/>
		&lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::showHelpSimFile() const<br/>
{<br/>
	std::cout <br/>
		&lt;&lt; "\n\tHelp on Simulation File."<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; "\n\tA Simulation File comprises all simulation parameters and setup."<br/>
		&lt;&lt; "\n\tEvery parameter can be changed by the following commands, and is"<br/>
		&lt;&lt; "\n\tapplied on the simulation(s) in focus."<br/>
		&lt;&lt; "\n"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setSimTime [n] : Sets running time to 'n' timesteps."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setStartPopSize [n] : Sets starting population size to 'n' individuals."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setStartResources [n] : Sets starting resources to 'n' units."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setBodySizeAdult [n] : Sets body size to become adult to 'n' units of weight."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setConstA [n] : Sets efficiency to convert resources to body size to fraction 'n'."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setConstB [n] : Sets efficiency to convert resources to reserves to fraction 'n'."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setConstC [n] : Sets efficiency to convert reserves to egg mass to fraction 'n'."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setReproductionMode [n] : Sets 'n'-th reproduction mode. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setD [n]: Sets 'n'-th formula for D, the death rate. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setF [n]: Sets 'n'-th formula for F, the feeding rate. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setG [n]: Sets 'n'-th formula for G, the fraction egg biomass per offspring. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setM [n]: Sets 'n'-th formula for M, metabolic cost. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setN [n]: Sets 'n'-th formula for N, amount of offspring. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setP [n]: Sets 'n'-th formula for P, allocation of resources to body size. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setQ [n]: Sets 'n'-th formula for Q, biomass investment in eggs. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setR [n]: Sets 'n'-th formula for R, the resource inflow. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;setW [n]: Sets 'n'-th formula for W, the way resources are (un)equally disributed over individuals. Without giving 'n' a menu appears."<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; "\n\tTo change a constant in each of the equations, use:"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;set{D,F,G,M,N,P,Q,R,W}const{a,b,c,d} [n] : Sets constant in equation to 'n', e.g. 'setDconstA 0.5'"<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::showAbout() const<br/>
{<br/>
	std::cout <br/>
		&lt;&lt; "\n\tThis program was written by:"<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;&nbsp;&nbsp;Richel Bilderbeek"<br/>
		&lt;&lt; "\n\t&nbsp;&nbsp;&nbsp;&nbsp;richelbilderbeek@fastmail.fm"<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; "\n\twhile in Bristol from the 9th of May 2005 to 14th of August 2005"<br/>
		&lt;&lt; "\n\tunder supervision of Robert Payne."<br/>
		&lt;&lt; "\n\t"<br/>
		&lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::showUses() const<br/>
{<br/>
	const int usesSimFile = mOptionsFile.getUsesSimFile();<br/>
	std::cout<br/>
		&lt;&lt; "\n\tOptions file: " &lt;&lt; mOptionsFile.getFileName()<br/>
		&lt;&lt; "\n\tUsing Simulation File: " &lt;&lt; (usesSimFile==-1 ? "all." : "#"+itoa(usesSimFile)+".")<br/>
		&lt;&lt; std::endl;<br/>
	<br/>
	std::vector&lt;std::string&gt; simFileName = mOptionsFile.getSimulationFileNames();<br/>
	const unsigned int nSimFileNames = simFileName.size();<br/>
	for (unsigned int i=0; i&lt;nSimFileNames; ++i)<br/>
	{<br/>
		std::cout &lt;&lt; "\tSimulation file #" &lt;&lt; i &lt;&lt; ": " &lt;&lt; simFileName[i] &lt;&lt; std::endl;<br/>
	}<br/>
	std::cout &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::showOptionsFile() const<br/>
{<br/>
	mOptionsFile.showUser();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetReproductionMode(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setReproductionMode' only<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of D" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl									<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumReproductionModeFraction : Calculate fraction of egg biomass per offspring, eq. G." &lt;&lt; std::endl							<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumReproductionModeAmount : Calculate amunt of offspring, eq. N." &lt;&lt; std::endl							<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	assert(userInputToEnumReproductionMode(0)==enumReproductionModeFraction);<br/>
	assert(userInputToEnumReproductionMode(1)==enumReproductionModeAmount);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setReproductionMode [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the ReproductionMode index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setReproductionMode 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;1)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select a ReproductionMode index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setReproductionMode 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setReproductionMode(userInputToEnumReproductionMode(userInput));											<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void Sim4Interpreter::interpretSetD(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setD' only<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;//const std::auto_ptr&lt;StrategyDconstant&gt; pDconstant(new StrategyDconstant);<br/>
		//const std::auto_ptr&lt;StrategyDsizeOnly&gt; pDsizeOnly(new StrategyDsizeOnly);<br/>
		const std::auto_ptr&lt;ParameterSetD&gt; pDparams(new ParameterSetD);<br/>
		const std::auto_ptr&lt;StrategyDdefault&gt;&nbsp;&nbsp;pDdefault( new StrategyDdefault(pDparams.get()));<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of D" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl									<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumDdefault&nbsp;&nbsp;: " &lt;&lt; pDdefault-&gt;getString() &lt;&lt; std::endl<br/>
			//&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumDconstant : " &lt;&lt; pDconstant-&gt;getString() &lt;&lt; std::endl<br/>
			//&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2] enumDsizeOnly : " &lt;&lt; pDsizeOnly-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
<br/>
	assert(userInputToEnumD(0)==enumDdefault);<br/>
	//assert(userInputToEnumD(1)==enumDconstant);<br/>
	//assert(userInputToEnumD(2)==enumDsizeOnly);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setD [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the D's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setD 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;2)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an D's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setD 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setD(userInputToEnumD(userInput));											<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void Sim4Interpreter::interpretSetF(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setF' only															<br/>
		const std::auto_ptr&lt;ParameterSetF&gt; pFparams(new ParameterSetF);<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;//const std::auto_ptr&lt;StrategyFconstant&gt; pFconstant(new StrategyFconstant(pFparams.get()));<br/>
		const std::auto_ptr&lt;StrategyFdefault&gt;&nbsp;&nbsp;pFdefault( new StrategyFdefault(pFparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;//const std::auto_ptr&lt;StrategyFgauss&gt;&nbsp;&nbsp;pFgauss( new StrategyFgauss(pFparams.get()));<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of F" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumFdefault&nbsp;&nbsp;: " &lt;&lt; pFdefault-&gt;getString()&nbsp;&nbsp;&lt;&lt; std::endl<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
<br/>
	assert(userInputToEnumF(0)==enumFdefault);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setF [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the F's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setF 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;2)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an F's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setF 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setF(userInputToEnumF(userInput));											<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void Sim4Interpreter::interpretSetG(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setG' only															<br/>
		const std::auto_ptr&lt;ParameterSetG&gt; pGparams(new ParameterSetG);<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyGconstant&gt; pGconstant(new StrategyGconstant(pGparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyGplastic&gt;&nbsp;&nbsp;pGplastic( new StrategyGplastic(pGparams.get()));<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of G" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumGconstant: " &lt;&lt; pGconstant-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumGplastic : " &lt;&lt; pGplastic-&gt;getString()&nbsp;&nbsp;&lt;&lt; std::endl<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	assert(userInputToEnumG(0)==enumGconstant);<br/>
	assert(userInputToEnumG(1)==enumGplastic);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setG [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the G's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setG 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;1)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an G's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setG 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setG(userInputToEnumG(userInput));											<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void Sim4Interpreter::interpretSetM(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setM' only															<br/>
		const std::auto_ptr&lt;ParameterSetM&gt; pMparams(new ParameterSetM);<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyMconstant&gt; pMconstant(new StrategyMconstant(pMparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyMdefault&gt;&nbsp;&nbsp;pMdefault( new StrategyMdefault(pMparams.get()));<br/>
<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of M" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumMconstant : " &lt;&lt; pMconstant-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumMdefault&nbsp;&nbsp;: " &lt;&lt; pMdefault-&gt;getString()&nbsp;&nbsp;&lt;&lt; std::endl<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	assert(userInputToEnumM(0)==enumMconstant);<br/>
	assert(userInputToEnumM(1)==enumMdefault);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setM [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the M's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setM 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;1)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an M's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setM 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setM(userInputToEnumM(userInput));											<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void Sim4Interpreter::interpretSetN(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setN' only															<br/>
		const std::auto_ptr&lt;ParameterSetN&gt; pNparams(new ParameterSetN);<br/>
		pNparams-&gt;C = 1.0;<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyNconstant&gt; pNconstant(new StrategyNconstant(pNparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyNplastic&gt;&nbsp;&nbsp;pNplastic( new StrategyNplastic(pNparams.get()));<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of N" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl									<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumNplastic&nbsp;&nbsp;: " &lt;&lt; pNplastic-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumNconstant : " &lt;&lt; pNconstant-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	assert(userInputToEnumN(0)==enumNplastic);<br/>
	assert(userInputToEnumN(1)==enumNconstant);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setN [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the N's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setN 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;1)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an N's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setN 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setN(userInputToEnumN(userInput));<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void Sim4Interpreter::interpretSetP(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setP' only<br/>
		const std::auto_ptr&lt;ParameterSetP&gt; pPparams(new ParameterSetP);<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyPconstant&gt; pPconstant(new StrategyPconstant(pPparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyPplastic&gt; pPplasticA(new StrategyPplastic(pPparams.get()));<br/>
															<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of P" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl									<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumPconstant : " &lt;&lt; pPconstant-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumPplastic : " &lt;&lt; pPplasticA-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	assert(userInputToEnumP(0)==enumPconstant);<br/>
	assert(userInputToEnumP(1)==enumPplastic);<br/>
	<br/>
	<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setP [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the P's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setP 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;2)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an P's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setP 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setP(userInputToEnumP(userInput));											<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Sim4Interpreter::interpretSetQ(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setQ' only															<br/>
		const std::auto_ptr&lt;ParameterSetQ&gt; pQparams(new ParameterSetQ);<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyQconstant&gt; pQconstant(new StrategyQconstant(pQparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyQdefault &gt; pQdefault( new StrategyQdefault( pQparams.get()));<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of Q" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumQconstant : " &lt;&lt; pQconstant-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumQdefault&nbsp;&nbsp;: " &lt;&lt; pQdefault-&gt;getString()&nbsp;&nbsp;&lt;&lt; std::endl<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	assert(userInputToEnumQ(0)==enumQconstant);<br/>
	assert(userInputToEnumQ(1)==enumQdefault);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setQ [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the Q's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQ 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;1)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an Q's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setQ 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setQ(userInputToEnumQ(userInput));											<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void Sim4Interpreter::interpretSetR(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setR' only															<br/>
		const std::auto_ptr&lt;ParameterSetR&gt; pRparams(new ParameterSetR);<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyRconstant&gt; pRconstant(new StrategyRconstant(pRparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyRlogistic&gt; pRlogistic(new StrategyRlogistic(pRparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyRcosine&nbsp;&nbsp;&gt; pRcosine(&nbsp;&nbsp;new StrategyRcosine(&nbsp;&nbsp;pRparams.get()));<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of R" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl									<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumRconstant : " &lt;&lt; pRconstant-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumRlogistic : " &lt;&lt; pRlogistic-&gt;getString() &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2] enumRcosine&nbsp;&nbsp; : " &lt;&lt; pRcosine-&gt;getString()&nbsp;&nbsp; &lt;&lt; std::endl<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	assert(userInputToEnumR(0)==enumRconstant);<br/>
	assert(userInputToEnumR(1)==enumRlogistic);<br/>
	assert(userInputToEnumR(2)==enumRcosine);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setR [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the R's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setR 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;2)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an R's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setR 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setR(userInputToEnumR(userInput));											<br/>
}																							<br/>
//----------------------------------------------------------------------------------		<br/>
void Sim4Interpreter::interpretSetW(const unsigned int&amp; index)							<br/>
{																							<br/>
	if (index+1==mCommand.size())															<br/>
	{&nbsp;&nbsp; //User typed 'setW' only															<br/>
		const std::auto_ptr&lt;ParameterSetW&gt; pWparams(new ParameterSetW);<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyWzero&gt;&nbsp;&nbsp;&nbsp;&nbsp;pWzero(&nbsp;&nbsp; new StrategyWzero(pWparams.get()));<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;const std::auto_ptr&lt;StrategyWuniform&gt; pWuniform(new StrategyWuniform(pWparams.get()));<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please also specify the index of the formula of W" &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Optional indices are:" &lt;&lt; std::endl									<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0] enumWzero&nbsp;&nbsp;&nbsp;&nbsp;: " &lt;&lt; pWzero-&gt;getString()&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; std::endl<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] enumWuniform : " &lt;&lt; pWuniform-&gt;getString() 	<br/>
			&lt;&lt; std::endl;<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	assert(userInputToEnumW(0)==enumWzero);<br/>
	assert(userInputToEnumW(1)==enumWuniform);<br/>
																							<br/>
	const std::string nextCommand = mCommand[index+1];										<br/>
																							<br/>
	int userInput=-1;																		<br/>
	if (isInt(nextCommand,userInput)==false)												<br/>
	{&nbsp;&nbsp; //User typed 'setW [non-integer]'													<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please input the W's equation index as a NUMBER." &lt;&lt; std::endl		<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setW 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	if (userInput&lt;0 || userInput&gt;1)															<br/>
	{																						<br/>
		std::cout &lt;&lt; std::endl																<br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;Please select an W's equation index that is IN RANGE." &lt;&lt; std::endl&nbsp;&nbsp; <br/>
			&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;e.g. './Sim4 setW 0'" &lt;&lt; std::endl									<br/>
			&lt;&lt; std::endl;																	<br/>
		return;																				<br/>
	}																						<br/>
																							<br/>
	//Success. OptionsFile produces this output.											<br/>
	mOptionsFile.setW(userInputToEnumW(userInput));											<br/>
}																							<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Sim4Interpreter.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Sim4Interpreter.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Sim4Interpreter.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 16 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
///Sim4Interpreter interprets the user's command line input.<br/>
///<br/>
///The only members it has are mCommands and mOptionsFile.<br/>
///mCommands contains the words the user typed.<br/>
///mOptionsFile embodies the user's Options file, which can be <br/>
///modified by the user via Sim4Interpreter.<br/>
<br/>
#ifndef __SIM4_INTERPRETER<br/>
#define __SIM4_INTERPRETER<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;memory&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;assert.h&gt;<br/>
#include "OptionsFile.h"<br/>
#include "HelperFunctions.h"<br/>
#include "StrategyD.h"<br/>
#include "StrategyF.h"<br/>
#include "StrategyG.h"<br/>
#include "StrategyM.h"<br/>
#include "StrategyN.h"<br/>
#include "StrategyP.h"<br/>
#include "StrategyQ.h"<br/>
#include "StrategyR.h"<br/>
#include "StrategyW.h"<br/>
<br/>
class Sim4Interpreter<br/>
{<br/>
	public:<br/>
	Sim4Interpreter(const int&amp;, char* const []);<br/>
	OptionsFile getOptionsFile() const { return mOptionsFile; }<br/>
<br/>
	private:<br/>
	<br/>
	const std::string mIniFileName;<br/>
	OptionsFile mOptionsFile;<br/>
	std::string getOptionsFileName() const;<br/>
	std::vector&lt;std::string&gt; mCommand;<br/>
	std::vector&lt;std::string&gt; mArgv;<br/>
	bool mDoExit;<br/>
<br/>
	void setOptionsFileName(const std::string&amp;) const;<br/>
<br/>
	//'show' means that no next words must be interpreted<br/>
	void showHelp() const;<br/>
	void showHelpOptionFile() const;<br/>
	void showHelpSimFile() const;<br/>
	void showUses() const; <br/>
	void showOptionsFile() const;<br/>
	void showAbout() const; <br/>
<br/>
	//'interpret' mean that also next words must be interpreted<br/>
	void interpretCommandLine();<br/>
<br/>
	//General interface<br/>
	void interpretHelp(const unsigned int&amp;) const;<br/>
	void interpretUseOptionsFile(const unsigned int&amp;);<br/>
	void interpretShowSimFile(const unsigned int&amp;) const;<br/>
	void interpretCopyOptionsFile(const unsigned int&amp;) const;<br/>
	void interpretCopySimFile(const unsigned int&amp;) const;<br/>
	void interpretAddSimFile(const unsigned int&amp;);<br/>
	void interpretRemoveSimFile(const unsigned int&amp;);<br/>
	void interpretExecute(const unsigned int&amp;);<br/>
	void testFunctions() const;<br/>
	void extractCov() const;<br/>
	//Options File interface<br/>
	void interpretSetOutputFileName(const unsigned int&amp;);<br/>
	void interpretSetSeed(const unsigned int&amp;);<br/>
<br/>
	void interpretSetWriteOutputFile(const unsigned int&amp;);<br/>
	void interpretSetWriteOutput(const unsigned int&amp;);<br/>
<br/>
	void interpretSetText(const unsigned int&amp;);<br/>
	void interpretSetPlotting(const unsigned int&amp;);<br/>
	void interpretUsesSimFile(const unsigned int&amp;);<br/>
	void interpretSetSimTime(const unsigned int&amp;);<br/>
	void interpretSetStartPopSize(const unsigned int&amp;);<br/>
	void interpretSetStartResources(const unsigned int&amp;);<br/>
	void interpretSetBodySizeAdult(const unsigned int&amp;);<br/>
	void interpretSetConstA(const unsigned int&amp;);<br/>
	void interpretSetConstB(const unsigned int&amp;);<br/>
	void interpretSetConstC(const unsigned int&amp;);<br/>
	void interpretSetReproductionMode(const unsigned int&amp;);<br/>
<br/>
	//----------------------------------------------------------------------------------<br/>
	//<br/>
	// COMPUTER GENERATED CODE<br/>
	// Sim4Interpreter<br/>
	//<br/>
	//----------------------------------------------------------------------------------<br/>
	void interpretSetDconstA(const unsigned int&amp;);<br/>
	void interpretSetFconstA(const unsigned int&amp;);<br/>
	void interpretSetGconstA(const unsigned int&amp;);<br/>
	void interpretSetMconstA(const unsigned int&amp;);<br/>
	void interpretSetNconstA(const unsigned int&amp;);<br/>
	void interpretSetPconstA(const unsigned int&amp;);<br/>
	void interpretSetQconstA(const unsigned int&amp;);<br/>
	void interpretSetRconstA(const unsigned int&amp;);<br/>
	void interpretSetWconstA(const unsigned int&amp;);<br/>
	void interpretSetDconstB(const unsigned int&amp;);<br/>
	void interpretSetFconstB(const unsigned int&amp;);<br/>
	void interpretSetGconstB(const unsigned int&amp;);<br/>
	void interpretSetMconstB(const unsigned int&amp;);<br/>
	void interpretSetNconstB(const unsigned int&amp;);<br/>
	void interpretSetPconstB(const unsigned int&amp;);<br/>
	void interpretSetQconstB(const unsigned int&amp;);<br/>
	void interpretSetRconstB(const unsigned int&amp;);<br/>
	void interpretSetWconstB(const unsigned int&amp;);<br/>
	void interpretSetDconstC(const unsigned int&amp;);<br/>
	void interpretSetFconstC(const unsigned int&amp;);<br/>
	void interpretSetGconstC(const unsigned int&amp;);<br/>
	void interpretSetMconstC(const unsigned int&amp;);<br/>
	void interpretSetNconstC(const unsigned int&amp;);<br/>
	void interpretSetPconstC(const unsigned int&amp;);<br/>
	void interpretSetQconstC(const unsigned int&amp;);<br/>
	void interpretSetRconstC(const unsigned int&amp;);<br/>
	void interpretSetWconstC(const unsigned int&amp;);<br/>
	void interpretSetDconstD(const unsigned int&amp;);<br/>
	void interpretSetFconstD(const unsigned int&amp;);<br/>
	void interpretSetGconstD(const unsigned int&amp;);<br/>
	void interpretSetMconstD(const unsigned int&amp;);<br/>
	void interpretSetNconstD(const unsigned int&amp;);<br/>
	void interpretSetPconstD(const unsigned int&amp;);<br/>
	void interpretSetQconstD(const unsigned int&amp;);<br/>
	void interpretSetRconstD(const unsigned int&amp;);<br/>
	void interpretSetWconstD(const unsigned int&amp;);<br/>
	void interpretSetDconstE(const unsigned int&amp;);<br/>
	void interpretSetFconstE(const unsigned int&amp;);<br/>
	void interpretSetGconstE(const unsigned int&amp;);<br/>
	void interpretSetMconstE(const unsigned int&amp;);<br/>
	void interpretSetNconstE(const unsigned int&amp;);<br/>
	void interpretSetPconstE(const unsigned int&amp;);<br/>
	void interpretSetQconstE(const unsigned int&amp;);<br/>
	void interpretSetRconstE(const unsigned int&amp;);<br/>
	void interpretSetWconstE(const unsigned int&amp;);<br/>
	void interpretSetD(const unsigned int&amp;);<br/>
	void interpretSetF(const unsigned int&amp;);<br/>
	void interpretSetG(const unsigned int&amp;);<br/>
	void interpretSetM(const unsigned int&amp;);<br/>
	void interpretSetN(const unsigned int&amp;);<br/>
	void interpretSetP(const unsigned int&amp;);<br/>
	void interpretSetQ(const unsigned int&amp;);<br/>
	void interpretSetR(const unsigned int&amp;);<br/>
	void interpretSetW(const unsigned int&amp;);<br/>
};<br/>
<br/>
<br/>
<br/>
<br/>
#endif //#ifndef __SIM4_FLAGS_INTERPRETER<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Simulation.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Simulation.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Simulation.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 24 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
//----------------------------------------------------------------------------------<br/>
#include "Simulation.h"<br/>
<br/>
//#define EXTREME_LOGGING<br/>
//#define EXTREME_LOGGING_PLUS<br/>
//----------------------------------------------------------------------------------<br/>
Simulation::Simulation(const OptionsFile&amp; optionsFile, const SimulationFile&amp; simulationFile) :<br/>
	mpFunctions(FunctionsSingleton::instance()),<br/>
	mOptionsFileParameters(optionsFile.getOptionsFileParameters())<br/>
{<br/>
	simulationFile.coutAll();<br/>
	readParameters(simulationFile.getParameters());<br/>
	const unsigned int popSize = mPop.size();<br/>
<br/>
	switch (simulationFile.getReproductionMode())<br/>
	{<br/>
		case enumReproductionModeFraction:<br/>
			for (unsigned int i=0; i&lt;popSize; ++i) <br/>
			{<br/>
				mPop[i] = new SoilMiteFraction("INIT");<br/>
				assert(mPop[i]!=NULL);<br/>
			}<br/>
			break;<br/>
		case enumReproductionModeAmount:<br/>
			for (unsigned int i=0; i&lt;popSize; ++i) <br/>
			{<br/>
				mPop[i] = new SoilMiteAmount("INIT");<br/>
				assert(mPop[i]!=NULL);<br/>
			}<br/>
			break;<br/>
		default: assert(!"Unknown value of: simulationFile.getReproductionMode()");<br/>
	}<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::readParameters(const ParameterSetSimulation&amp; params)<br/>
{<br/>
	srand(params.seed);<br/>
	mResources = params.startingResources;<br/>
	mMaxTime = params.maxTime;<br/>
	SoilMiteBase::setBodySizeAdult(params.bodySizeAdult);<br/>
	mOffspringProduced = false;<br/>
	//Make function class ready<br/>
	mpFunctions = FunctionsSingleton::instance();<br/>
	mpFunctions-&gt;setAlpha(params.A);<br/>
	mpFunctions-&gt;setBeta(params.B);<br/>
	mpFunctions-&gt;setGamma(params.C);<br/>
	mpFunctions-&gt;setD(params.enumD, &amp;params.paramsD);<br/>
	mpFunctions-&gt;setF(params.enumF, &amp;params.paramsF);<br/>
	mpFunctions-&gt;setG(params.enumG, &amp;params.paramsG);<br/>
	mpFunctions-&gt;setM(params.enumM, &amp;params.paramsM);<br/>
	mpFunctions-&gt;setN(params.enumN, &amp;params.paramsN);<br/>
	mpFunctions-&gt;setP(params.enumP, &amp;params.paramsP);<br/>
	mpFunctions-&gt;setQ(params.enumQ, &amp;params.paramsQ);<br/>
	mpFunctions-&gt;setR(params.enumR, &amp;params.paramsR);<br/>
	mpFunctions-&gt;setW(params.enumW, &amp;params.paramsW);<br/>
	mPop.resize(params.startingPopSize);<br/>
	#ifndef NDEBUG<br/>
	for (unsigned int i = 0; i&lt; params.startingPopSize; ++i)<br/>
	{<br/>
		assert(mPop[i]==NULL);<br/>
	}<br/>
	#endif<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
Simulation::~Simulation()<br/>
{<br/>
	checkPopSize("Simulation::~Simulation() - #1");<br/>
<br/>
	const int popSize = mPop.size();<br/>
	for(int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		assert(mPop[i]!=NULL);<br/>
		delete mPop[i];	mPop[i]=NULL;<br/>
	}<br/>
	//The check below will give a false result...<br/>
	//This is because it checks whether the std::vector size matches<br/>
	//the Soilmites' instances...<br/>
	//checkPopSize("Simulation::~Simulation() - If you see me, than everything is good");<br/>
	mPop.resize(0);<br/>
	checkPopSize("Simulation::~Simulation() - #2");<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//std::vector&lt;EnumConclusion&gt; Simulation::execute()<br/>
void Simulation::execute(MeasurementsTable&amp; table, std::vector&lt;EnumConclusion&gt;&amp; conclusions)<br/>
{<br/>
<br/>
	checkPopSize("void Simulation::execute() - #1");<br/>
	std::cout &lt;&lt; "Start of simulation, running time (timesteps): " &lt;&lt; mMaxTime &lt;&lt; std::endl;<br/>
	std::cout &lt;&lt; "Starting population size: " &lt;&lt; SoilMiteBase::getPopSize() &lt;&lt; std::endl;<br/>
<br/>
	mErrorCode = EcNoError;<br/>
	for(unsigned int time=0; time&lt;mMaxTime &amp;&amp; mErrorCode==EcNoError; ++time)<br/>
	{<br/>
		changeEnvironment(time,table);<br/>
		intake(table);<br/>
		reproduction(table);<br/>
		mortality();<br/>
		measurePopulation(table);<br/>
		if (mOptionsFileParameters.showYearSummary==true) table.showYearHorizontal(time);<br/>
	}<br/>
<br/>
	<br/>
	checkPopSize("void Simulation::execute() - #2");<br/>
	mpFunctions-&gt;coutAll();<br/>
	std::cout &lt;&lt; "Body size adult: " &lt;&lt; SoilMiteBase::getBodySizeAdult() &lt;&lt; std::endl; <br/>
<br/>
	//Some conclusions<br/>
	if (mOffspringProduced==false) conclusions.push_back(CcNoOffspringProduced);<br/>
	switch(mErrorCode)<br/>
	{<br/>
		case EcNoError: conclusions.push_back(CcNoError); break;<br/>
		case EcPopExtinct: conclusions.push_back(CcPopExtinct); break;<br/>
		case EcPopSizeTooBig: conclusions.push_back(CcPopSizeTooBig); break;<br/>
		case EcNoffspringTooBigSingleParent: conclusions.push_back(CcNoffspringTooBigSingleParent); break;<br/>
		case EcNoffspringTooBigAllParents: conclusions.push_back(CcNoffspringTooBigAllParents); break;<br/>
	}<br/>
<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::changeEnvironment(const int&amp; time,MeasurementsTable&amp; table)<br/>
{<br/>
	if (mErrorCode!=EcNoError) return;<br/>
<br/>
	dot("Current resources: "+ftoa(mResources));<br/>
	const double inflow = mpFunctions-&gt;R(mResources,time);<br/>
	dot("Inflow: "+ftoa(inflow));<br/>
	//Note: Inflow can also be negative<br/>
	mResources+=inflow;<br/>
	dot("New resources: "+ftoa(mResources));<br/>
	checkPopSize("void Simulation::changeEnvironment(const int&amp; time)");<br/>
	const unsigned int popSize = SoilMiteBase::getPopSize();<br/>
	if (popSize==0) { mErrorCode = EcPopExtinct; return; }<br/>
	//Create a vector of bodySizes...<br/>
	std::vector&lt;double&gt; popBodySize(popSize);<br/>
	for (unsigned int i=0; i&lt;popSize; ++i) popBodySize[i] = mPop[i]-&gt;getBodySize();<br/>
	mVectorResources = mpFunctions-&gt;distributeResources(popBodySize, mResources);<br/>
	assert(mVectorResources.size()==popBodySize.size());<br/>
	checkResources(mResources);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::intake(MeasurementsTable&amp; table)<br/>
{<br/>
	if (mErrorCode!=EcNoError) return;<br/>
<br/>
	checkPopSize("void Simulation::intake() - #1");<br/>
	const unsigned int popSize = SoilMiteBase::getPopSize();<br/>
	<br/>
	if (popSize==0) <br/>
	{<br/>
		std::cout &lt;&lt; "Population went extinct" &lt;&lt; std::endl;<br/>
		mErrorCode = EcPopExtinct;<br/>
		return;<br/>
	}<br/>
	if (popSize&gt;100000) <br/>
	{<br/>
		std::cout &lt;&lt; "Population went bigger then 100,000" &lt;&lt; std::endl;<br/>
		mErrorCode = EcPopSizeTooBig;<br/>
		return;<br/>
	}<br/>
<br/>
	for (unsigned int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		mPop[i]-&gt;intake(mVectorResources[i]);<br/>
	}<br/>
<br/>
	const double foodIntake = getSumFeedRate();<br/>
	assert(foodIntake&gt;=-0.001 &amp;&amp; foodIntake&lt;=mResources*1.0001);<br/>
	dot("Intake: "+ftoa(foodIntake));<br/>
	mResources-=foodIntake;<br/>
	dot("New resources: "+ftoa(mResources));<br/>
	table.mResources.push_back(mResources); //Measure<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::reproduction(MeasurementsTable&amp; table)<br/>
{<br/>
	if (mErrorCode!=EcNoError) return;<br/>
<br/>
	checkPopSize("void Simulation::intake() - #1");<br/>
<br/>
	const unsigned int popSize = SoilMiteBase::getPopSize();<br/>
	table.mPopSize.push_back(popSize); //Measure mPopSize<br/>
<br/>
	std::vector&lt;SoilMiteBase*&gt; offspring;<br/>
<br/>
	for (unsigned int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		EnumErrorCode error = mPop[i]-&gt;reproduce(offspring);<br/>
		if (error!=EcNoError) <br/>
		{<br/>
			//Delete the offspring produced this far<br/>
			unsigned int nOffspring = offspring.size();<br/>
			for (unsigned int i = 0; i&lt;nOffspring; ++i) { delete offspring[i]; offspring[i]=NULL; }<br/>
			offspring.resize(0);<br/>
			mErrorCode = error; <br/>
			return; <br/>
		}<br/>
	}<br/>
<br/>
	//Put offspring in population<br/>
	const unsigned int nOffspring = offspring.size();<br/>
	if (nOffspring&gt;0) mOffspringProduced =&nbsp;&nbsp;true;<br/>
	if (nOffspring&gt;100000) <br/>
	{&nbsp;&nbsp; <br/>
		mErrorCode = EcNoffspringTooBigAllParents;	<br/>
		for (unsigned int i = 0; i&lt;nOffspring; ++i) { delete offspring[i]; offspring[i]=NULL; }<br/>
		return;	<br/>
	}<br/>
<br/>
	table.mNoffspring.push_back(nOffspring); //Measuring nOffspring<br/>
	for (unsigned int i=0; i&lt;nOffspring; ++i)<br/>
	{<br/>
		assert(offspring[i]!=NULL);<br/>
		mPop.push_back(offspring[i]);<br/>
	}<br/>
<br/>
	checkPopSize("void Simulation::intake() - #2");<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::mortality()<br/>
{<br/>
	if (mErrorCode!=EcNoError) return;<br/>
<br/>
	checkPopSize("void Simulation::mortality() - #1");<br/>
<br/>
	const unsigned int popSize = SoilMiteBase::getPopSize();<br/>
	for (unsigned int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		if (mPop[i]-&gt;doIdie()==true)<br/>
		{<br/>
			delete mPop[i]; mPop[i]=NULL;<br/>
		}<br/>
	}<br/>
<br/>
	//DO NOT: checkPopSize("void Simulation::mortality() - #1.5");<br/>
	//This will not be correct, because the std::vector mPop then<br/>
	//has individuals deleted, but is not yet shrunk<br/>
<br/>
	//Remove NULLs<br/>
	for (unsigned int i=0; i &lt; mPop.size() ; ++i)<br/>
	{<br/>
		while (mPop[i]==NULL &amp;&amp; i&lt;mPop.size())<br/>
		{<br/>
			mPop[i]=mPop.back();<br/>
			mPop.pop_back();<br/>
		}<br/>
	}<br/>
<br/>
	checkPopSize("void Simulation::mortality() - #2");<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
double Simulation::getSumFeedRate() const<br/>
{<br/>
	checkPopSize("double Simulation::getSumFeedRate() const - #1");<br/>
	const unsigned int popSize = SoilMiteBase::getPopSize();<br/>
	double sumFeedRate = 0.0;<br/>
	for (unsigned int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		const double feedRate = mPop[i]-&gt;getFeedRate();<br/>
		assert(feedRate&gt;=0.0);<br/>
		sumFeedRate+=feedRate;<br/>
		#ifdef EXTREME_LOGGING_PLUS<br/>
		dot("FeedRate ["+itoa(i)+"]: "+ftoa(feedRate));<br/>
		#endif<br/>
	}<br/>
	return sumFeedRate;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
/// Compares if the population sizes of the vector mPop and the static <br/>
/// SoilMiteBase::mPopSize do match.<br/>
void Simulation::checkPopSize(const std::string&amp; location) const<br/>
{<br/>
	#ifndef NDEBUG<br/>
	const int popSizeVector = mPop.size();<br/>
	const int popSizeClass = SoilMiteBase::getPopSize();<br/>
	if (popSizeVector!=popSizeClass) <br/>
	{<br/>
		std::cout &lt;&lt; "MEMORY LEAK at location: " &lt;&lt; location &lt;&lt; std::endl;<br/>
		std::cout &lt;&lt; "mPop size: " &lt;&lt; popSizeVector &lt;&lt; std::endl;<br/>
		std::cout &lt;&lt; "SoilMiteBase::sPopSize: " &lt;&lt; popSizeClass &lt;&lt; std::endl;<br/>
	}<br/>
	#endif<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::checkResources(const double&amp; totalResources) const<br/>
{<br/>
	#ifndef NDEBUG<br/>
	double sumResources = 0.0;<br/>
	const unsigned int popSize = mVectorResources.size();<br/>
	for (unsigned int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		sumResources+=mVectorResources[i];<br/>
	}<br/>
<br/>
	if (sumResources &lt; 0.999 * totalResources &amp;&amp; sumResources&gt;1.001*totalResources)<br/>
	{<br/>
		std::cout &lt;&lt; "sumResources: " &lt;&lt; sumResources<br/>
			&lt;&lt; "totalResources: " &lt;&lt; totalResources &lt;&lt; std::endl;<br/>
		assert(!"Resources not correct in vector");<br/>
	}<br/>
	#endif<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::measurePopulation(MeasurementsTable&amp; table)<br/>
{<br/>
	if (mErrorCode!=EcNoError) return;<br/>
<br/>
	checkPopSize("void Simulation::measurePopulation()");<br/>
	const unsigned int popSize = SoilMiteBase::getPopSize();<br/>
<br/>
	std::vector&lt;double&gt; bodySizeTable(popSize);<br/>
	std::vector&lt;double&gt; reservesTable(popSize);<br/>
	std::vector&lt;double&gt; chanceToDieTable(popSize);<br/>
	std::vector&lt;double&gt; foodIntakeTable(popSize);<br/>
	std::vector&lt;double&gt; allocationTable(popSize);<br/>
	std::vector&lt;double&gt; fractionBiomassPerOffspringInitialTable(popSize);<br/>
	std::vector&lt;double&gt; fractionBiomassPerOffspringTable(popSize);<br/>
<br/>
	std::vector&lt;bool&gt; isAdultTable(popSize);<br/>
	const double splitValue = SoilMiteBase::getBodySizeAdult();<br/>
<br/>
	for (unsigned int i=0; i&lt;popSize; ++i)<br/>
	{<br/>
		bodySizeTable[i]&nbsp;&nbsp;&nbsp;&nbsp;= mPop[i]-&gt;getBodySize();<br/>
		reservesTable[i]&nbsp;&nbsp;&nbsp;&nbsp;= mPop[i]-&gt;getReserves();<br/>
		foodIntakeTable[i]&nbsp;&nbsp;= mPop[i]-&gt;getFeedRate();<br/>
		chanceToDieTable[i] = mPop[i]-&gt;getChanceToDie();<br/>
		allocationTable[i]&nbsp;&nbsp;= mPop[i]-&gt;getAllocation();<br/>
		fractionBiomassPerOffspringInitialTable[i] = mPop[i]-&gt;getFractionBiomassPerOffspringInitial();<br/>
		fractionBiomassPerOffspringTable[i] = mPop[i]-&gt;getFractionBiomassPerOffspring();<br/>
		isAdultTable[i]&nbsp;&nbsp;&nbsp;&nbsp; = ( bodySizeTable[i]&gt;splitValue ? true : false);<br/>
<br/>
		assert(allocationTable[i]&gt;=0.0 &amp;&amp; allocationTable[i]&lt;=1.0);<br/>
		assert(fractionBiomassPerOffspringInitialTable[i]&gt;=0.0 &amp;&amp; fractionBiomassPerOffspringInitialTable[i]&lt;=1.0);<br/>
		assert(fractionBiomassPerOffspringTable[i]&gt;=0.0 &amp;&amp; fractionBiomassPerOffspringTable[i]&lt;=1.0);<br/>
		assert(mPop[i]-&gt;getChanceToDie()&gt;=0.0 &amp;&amp; mPop[i]-&gt;getChanceToDie()&lt;=1.0);<br/>
	}<br/>
<br/>
	double meanBodySize, stdDevBodySize;<br/>
	SafeMeanAndStdDev(bodySizeTable, meanBodySize, stdDevBodySize);<br/>
	table.mMeanBodySize.push_back(meanBodySize);<br/>
	table.mStdDevBodySize.push_back(stdDevBodySize);<br/>
<br/>
	double meanReserves, stdDevReserves;<br/>
	SafeMeanAndStdDev(reservesTable, meanReserves, stdDevReserves);<br/>
	table.mMeanReserves.push_back(meanReserves);<br/>
	table.mStdDevReserves.push_back(stdDevReserves);<br/>
<br/>
	double meanFoodIntake, stdDevFoodIntake;<br/>
	SafeMeanAndStdDev(foodIntakeTable, meanFoodIntake, stdDevFoodIntake);<br/>
	table.mMeanFoodIntake.push_back(meanFoodIntake);<br/>
	table.mStdDevFoodIntake.push_back(stdDevFoodIntake);<br/>
	<br/>
	double meanChanceToDie, stdDevChanceToDie;<br/>
	SafeMeanAndStdDev(chanceToDieTable, meanChanceToDie, stdDevChanceToDie);<br/>
	table.mMeanChanceToDie.push_back(meanChanceToDie);<br/>
	table.mStdDevChanceToDie.push_back(stdDevChanceToDie);<br/>
<br/>
	//Plus<br/>
	int popSizeJuvenileInt, popSizeAdultInt;<br/>
	countSplit(splitValue, bodySizeTable, popSizeJuvenileInt, popSizeAdultInt);<br/>
	double popSizeJuvenile = static_cast&lt;double&gt;(popSizeJuvenileInt);<br/>
	double popSizeAdult&nbsp;&nbsp;&nbsp;&nbsp;= static_cast&lt;double&gt;(popSizeAdultInt);<br/>
	table.mPopSizeJuvenile.push_back(popSizeJuvenile);<br/>
	table.mPopSizeAdult.push_back(popSizeAdult);<br/>
	<br/>
	double meanBodySizeJuvenile, meanBodySizeAdult;<br/>
	SafeMeanSplit(splitValue,bodySizeTable, meanBodySizeJuvenile, meanBodySizeAdult);<br/>
	assert(meanBodySizeJuvenile&lt;=splitValue);<br/>
	assert(meanBodySizeAdult&gt;=splitValue || meanBodySizeAdult==0.0);<br/>
	table.mMeanBodySizeJuvenile.push_back(meanBodySizeJuvenile);<br/>
	table.mMeanBodySizeAdult.push_back(meanBodySizeAdult);<br/>
	<br/>
	double meanReservesJuvenile, meanReservesAdult;<br/>
	SafeMeanSplit(isAdultTable,reservesTable, meanReservesJuvenile, meanReservesAdult);<br/>
	table.mMeanReservesJuvenile.push_back(meanReservesJuvenile);<br/>
	table.mMeanReservesAdult.push_back(meanReservesAdult);<br/>
	<br/>
	double meanChanceToDieJuvenile, meanChanceToDieAdult;<br/>
	SafeMeanSplit(isAdultTable,chanceToDieTable, meanChanceToDieJuvenile, meanChanceToDieAdult);<br/>
	table.mMeanChanceToDieJuvenile.push_back(meanChanceToDieJuvenile);<br/>
	table.mMeanChanceToDieAdult.push_back(meanChanceToDieAdult);<br/>
	<br/>
	double meanFoodIntakeJuvenile, meanFoodIntakeAdult;<br/>
	SafeMeanSplit(isAdultTable,foodIntakeTable, meanFoodIntakeJuvenile, meanFoodIntakeAdult);<br/>
	table.mMeanFoodIntakeJuvenile.push_back(meanFoodIntakeJuvenile);<br/>
	table.mMeanFoodIntakeAdult.push_back(meanFoodIntakeAdult);<br/>
<br/>
	//Plus plus<br/>
	double meanAllocationJuvenile, meanAllocationAdult;<br/>
	SafeMeanSplit(isAdultTable,allocationTable, meanAllocationJuvenile, meanAllocationAdult);<br/>
	table.mMeanAllocation.push_back(meanAllocationAdult);<br/>
<br/>
	double meanFractionBiomassPerOffspringInitialJuvenile, meanFractionBiomassPerOffspringInitialAdult;<br/>
	SafeMeanSplit(isAdultTable,fractionBiomassPerOffspringInitialTable, meanFractionBiomassPerOffspringInitialJuvenile, meanFractionBiomassPerOffspringInitialAdult);<br/>
	table.mMeanFractionBiomassPerOffspringInitial.push_back(meanFractionBiomassPerOffspringInitialAdult);<br/>
<br/>
	double meanFractionBiomassPerOffspringJuvenile, meanFractionBiomassPerOffspringAdult;<br/>
	SafeMeanSplit(isAdultTable,fractionBiomassPerOffspringTable, meanFractionBiomassPerOffspringJuvenile, meanFractionBiomassPerOffspringAdult);<br/>
	table.mMeanFractionBiomassPerOffspring.push_back(meanFractionBiomassPerOffspringAdult);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::cout(const std::string&amp; logMessage) const<br/>
{<br/>
	std::cout &lt;&lt; "LOG: " &lt;&lt; logMessage &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void Simulation::dot(const std::string&amp; errorMessage) const<br/>
{<br/>
	#ifdef EXTREME_LOGGING<br/>
	std::cout &lt;&lt; "DOT: " &lt;&lt; errorMessage &lt;&lt; std::endl;<br/>
	#endif<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Simulation.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Simulation.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Simulation.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 24 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
///The function of class Simulation is to run a simulation<br/>
///<br/>
///It is initialized with an OptionsFile and a SimulationFile<br/>
///The OptionFiles is used for e.g. display options during the simulation<br/>
///The SimulationFile embodies the parameters and functions Simulation uses<br/>
///<br/>
///Technical notes:<br/>
///-Do NOT put std::auto_ptr's in a std::vector, as a std::auto_ptr's copy is not the same as the original (ref. 1)<br/>
///-Do NOT use std::auto_ptr for pointing to FunctionsSingleton, as Simulation will NOT have the responsability to delete it.<br/>
///<br/>
///Reference:<br/>
///1) Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions. By Herb Sutter. ISBN: 0-201-61562-2<br/>
<br/>
#ifndef __SIMULATION_H<br/>
#define __SIMULATION_H<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;sstream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;string&gt;<br/>
#include "FunctionsSingleton.h"<br/>
#include "SoilMite.h"<br/>
#include "Gnuplot.h"<br/>
#include "Enumerations.h"<br/>
#include "ParameterSets.h"<br/>
#include "OptionsFile.h"<br/>
#include "SimulationFile.h"<br/>
#include "MeasurementsTable.h"<br/>
<br/>
class Simulation<br/>
{<br/>
	std::vector&lt;SoilMiteBase*&gt; mPop;<br/>
	FunctionsSingleton * mpFunctions;<br/>
	double mResources; <br/>
	std::vector&lt;double&gt; mVectorResources;<br/>
	unsigned int mMaxTime;<br/>
	//Measuring<br/>
	bool mOffspringProduced;<br/>
<br/>
	//Life stages<br/>
	void changeEnvironment(const int&amp;,MeasurementsTable&amp;);<br/>
	void intake(MeasurementsTable&amp;);<br/>
	void reproduction(MeasurementsTable&amp;);<br/>
	void mortality();<br/>
<br/>
	//Helpers<br/>
	void initialize(); <br/>
	void measurePopulation(MeasurementsTable&amp;);<br/>
	double getSumFeedRate() const;<br/>
<br/>
	void checkPopSize(const std::string&amp;) const;<br/>
	void checkResources(const double&amp;) const;<br/>
	void cout(const std::string&amp; logMessage) const;<br/>
	void dot(const std::string&amp; errorMessage) const;<br/>
	EnumErrorCode mErrorCode;<br/>
	<br/>
	public:<br/>
	//Simulation(const std::string&amp;);<br/>
	<br/>
	Simulation(const OptionsFile&amp;, const SimulationFile&amp;);<br/>
	void readParameters(const ParameterSetSimulation&amp;);<br/>
	void readOptions(const OptionsFileParameters&amp;);<br/>
<br/>
	const OptionsFileParameters mOptionsFileParameters;<br/>
	<br/>
	~Simulation();<br/>
	void execute(MeasurementsTable&amp;, std::vector&lt;EnumConclusion&gt;&amp;);<br/>
};<br/>
<br/>
#endif //#ifndef __SIMULATION_H<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/SimulationFile.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/SimulationFile.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;SimulationFile.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 16 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "SimulationFile.h"<br/>
//----------------------------------------------------------------------------------<br/>
//#define EXTREME_LOGGING<br/>
//----------------------------------------------------------------------------------<br/>
SimulationFile::SimulationFile(const std::string&amp; fileName, const bool&amp; overWrite) :<br/>
	mFileName(fileName),<br/>
	mVersionName1("V1"), //Do not change<br/>
	mVersionName2("V2"), //Do not change<br/>
	mCurrentVersionName(mVersionName2) //Change every new version<br/>
{		<br/>
	//mpVersionNames.reset(new VersionNames);<br/>
	//A proper initialization<br/>
	/*mParameters.reproductionMode = enumReproductionModeAmount;<br/>
	mParameters.seed = 0;<br/>
	mParameters.outputFileName = "defaultOutputFile.txt";<br/>
	mParameters.startingPopSize = 1000;<br/>
	mParameters.startingResources = 0.0;<br/>
	mParameters.maxTime = 100;<br/>
	mParameters.A = 1.0;<br/>
	mParameters.B = 1.0;<br/>
	mParameters.C = 1.0;<br/>
	mParameters.bodySizeAdult = 10.0;<br/>
	mParameters.enumD = enumDconstant;<br/>
	mParameters.paramsD.A = 0.05;<br/>
	mParameters.paramsD.B = 0.0; <br/>
	mParameters.paramsD.C = 0.0;<br/>
	mParameters.paramsD.D = 0.0;<br/>
	mParameters.enumF = enumFconstant;<br/>
	mParameters.paramsF.A = 0.99;<br/>
	mParameters.paramsF.B = 0.0; <br/>
	mParameters.paramsF.C = 0.0; <br/>
	mParameters.paramsF.D = 0.0; <br/>
	mParameters.enumG = enumGfixed;<br/>
	mParameters.paramsG.A = 0.5;<br/>
	mParameters.paramsG.B = 0.0;<br/>
	mParameters.paramsG.C = 0.0;<br/>
	mParameters.paramsG.D = 0.0;<br/>
	mParameters.enumM = enumMconstant;<br/>
	mParameters.paramsM.A = 0.05;<br/>
	mParameters.paramsM.B = 0.0;<br/>
	mParameters.paramsM.C = 0.0;<br/>
	mParameters.paramsM.D = 0.0;<br/>
	mParameters.enumN = enumNdefault;<br/>
	mParameters.paramsN.A = 1.0;<br/>
	mParameters.paramsN.B = 1.0;<br/>
	mParameters.paramsN.C = 0.0;<br/>
	mParameters.paramsN.D = 0.0;<br/>
	mParameters.enumP = enumPconstant;<br/>
	mParameters.paramsP.A = 0.5;<br/>
	mParameters.paramsP.B = 0.0;<br/>
	mParameters.paramsP.C = 0.0;<br/>
	mParameters.paramsP.D = 0.0;<br/>
	mParameters.enumQ = enumQconstant;<br/>
	mParameters.paramsQ.A = 0.5;<br/>
	mParameters.paramsQ.B = 0.0;<br/>
	mParameters.paramsQ.C = 0.0;<br/>
	mParameters.paramsQ.D = 0.0;<br/>
	mParameters.enumR = enumRconstant;<br/>
	mParameters.paramsR.A = 200.0;<br/>
	mParameters.paramsR.B = 0.1;<br/>
	mParameters.paramsR.C = 0.0;<br/>
	mParameters.paramsR.D = 0.0;<br/>
	mParameters.enumW = enumWZero;<br/>
	mParameters.paramsW.A = 0.0;<br/>
	mParameters.paramsW.B = 0.0;<br/>
	mParameters.paramsW.C = 0.0;<br/>
	mParameters.paramsW.D = 0.0;*/<br/>
	enumsToStrings();<br/>
<br/>
<br/>
	if (fileExists(mFileName)==true) <br/>
	{<br/>
		dot("Config file '"+mFileName+"' found.");<br/>
		if (overWrite==false) <br/>
		{ <br/>
			readFromFile(); <br/>
			dot("Loaded '"+mFileName+"' successfully.");<br/>
			return; <br/>
		}<br/>
	}<br/>
	writeToFile();<br/>
	if (overWrite==true) <br/>
	{<br/>
		dot("Overwritten '"+mFileName+"' successfully.");<br/>
	}<br/>
	else<br/>
	{<br/>
		dot("Config file '"+mFileName+"' not found, now created.");<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::writeToFile()<br/>
{<br/>
	dot(mParameters.outputFileName);<br/>
	enumsToStrings();<br/>
	assert(mCurrentVersionName == mVersionName2);<br/>
	std::ofstream file;<br/>
	file.open(mFileName.c_str());<br/>
	file <br/>
		&lt;&lt;&nbsp;&nbsp;mCurrentVersionName &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.outputFileName &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.seed &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.startingPopSize &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.startingResources &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.maxTime &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.bodySizeAdult &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumDstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsD.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsD.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsD.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsD.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsD.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumFstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsF.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsF.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsF.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsF.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsF.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumGstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsG.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsG.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsG.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsG.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsG.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumMstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsM.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsM.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsM.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsM.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsM.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumNstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsN.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsN.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsN.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsN.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsN.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumPstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsP.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsP.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsP.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsP.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsP.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumQstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsQ.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsQ.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsQ.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsQ.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsQ.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumRstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsR.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsR.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsR.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsR.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsR.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumWstring &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsW.A &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsW.B &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsW.C &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsW.D &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mParameters.paramsW.E &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;enumReproductionModeString &lt;&lt; '\n'<br/>
		&lt;&lt;&nbsp;&nbsp;mFlag<br/>
		&lt;&lt; std::endl;<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::readFromFile()<br/>
{ <br/>
	if (fileExists(mFileName)==false)<br/>
	{<br/>
		std::cout &lt;&lt; "File '" &lt;&lt; mFileName &lt;&lt; "' does not exist. " &lt;&lt; std::endl;<br/>
		exit(0);<br/>
	}<br/>
<br/>
	//Read version<br/>
	std::string versionName = "NOTHING";<br/>
	{<br/>
		std::ifstream file;<br/>
		file.open(mFileName.c_str());<br/>
		file &gt;&gt;&nbsp;&nbsp;versionName;<br/>
		file.close();<br/>
	}<br/>
	assert(versionName!="NOTHING");<br/>
	<br/>
	//Do the real reading of a file, dependent on the version<br/>
	if (versionName==mVersionName2) readFromFile2();<br/>
	else if (versionName==mVersionName1) readFromFile1();<br/>
	else readFromFile0();<br/>
	<br/>
<br/>
	stringsToEnums();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Reads a SimFile V2.0<br/>
void SimulationFile::readFromFile2()<br/>
{<br/>
	std::string versionNameDummy; //Do not want to write to mpVersionNames, therefore use dummy<br/>
	std::ifstream file;<br/>
	file.open(mFileName.c_str());<br/>
	file <br/>
		&gt;&gt;&nbsp;&nbsp;versionNameDummy //Write to dummy mpVersionNames-&gt;versionName1<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.outputFileName<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.seed<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.startingPopSize<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.startingResources<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.maxTime<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.B<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.bodySizeAdult<br/>
		&gt;&gt;&nbsp;&nbsp;enumDstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumFstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumGstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumMstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumNstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumPstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumQstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumRstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumWstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.B<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.D<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.E<br/>
		&gt;&gt;&nbsp;&nbsp;enumReproductionModeString<br/>
		&gt;&gt;&nbsp;&nbsp;mFlag<br/>
		; //End of reading<br/>
	assert(versionNameDummy == mVersionName2); //Check dummy<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Reads a SimFile V1.0<br/>
void SimulationFile::readFromFile1()<br/>
{<br/>
	std::string versionNameDummy; //Do not want to write to mpVersionNames, therefore use dummy<br/>
	std::ifstream file;<br/>
	file.open(mFileName.c_str());<br/>
	file <br/>
		&gt;&gt;&nbsp;&nbsp;versionNameDummy //Write to dummy mpVersionNames-&gt;versionName1<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.outputFileName<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.seed<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.startingPopSize<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.startingResources<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.maxTime<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.B<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.bodySizeAdult<br/>
		&gt;&gt;&nbsp;&nbsp;enumDstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumFstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumGstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumMstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumNstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumPstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumQstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumRstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumWstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.B<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumReproductionModeString<br/>
		&gt;&gt;&nbsp;&nbsp;mFlag<br/>
		; //End of reading<br/>
	assert(versionNameDummy == mVersionName1); //Check dummy<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
///Reads a SimFile before V1.0<br/>
void SimulationFile::readFromFile0()<br/>
{<br/>
	std::ifstream file;<br/>
	file.open(mFileName.c_str());<br/>
	file <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.outputFileName<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.startingPopSize<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.startingResources<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.maxTime<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.B<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.bodySizeAdult<br/>
		&gt;&gt;&nbsp;&nbsp;enumDstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsD.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumFstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsF.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumGstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsG.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumMstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsM.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumNstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsN.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumPstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsP.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumQstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsQ.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumRstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.B <br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsR.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumWstring<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.A<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.B<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.C<br/>
		&gt;&gt;&nbsp;&nbsp;mParameters.paramsW.D<br/>
		&gt;&gt;&nbsp;&nbsp;enumReproductionModeString<br/>
		&gt;&gt;&nbsp;&nbsp;mFlag<br/>
		; //End of reading<br/>
	file.close();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::coutAll() const<br/>
{<br/>
	std::cout &lt;&lt; mParameters &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::stringsToEnums()<br/>
{<br/>
	mParameters.enumD = stringToEnumD(enumDstring);<br/>
	mParameters.enumF = stringToEnumF(enumFstring);<br/>
	mParameters.enumG = stringToEnumG(enumGstring);<br/>
	mParameters.enumM = stringToEnumM(enumMstring);<br/>
	mParameters.enumN = stringToEnumN(enumNstring);<br/>
	mParameters.enumP = stringToEnumP(enumPstring);<br/>
	mParameters.enumQ = stringToEnumQ(enumQstring);<br/>
	mParameters.enumR = stringToEnumR(enumRstring);<br/>
	mParameters.enumW = stringToEnumW(enumWstring);<br/>
	mParameters.reproductionMode = stringToEnumReproductionMode(enumReproductionModeString);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::enumsToStrings()<br/>
{<br/>
	enumDstring = enumDtoString(mParameters.enumD);<br/>
	enumFstring = enumFtoString(mParameters.enumF);<br/>
	enumGstring = enumGtoString(mParameters.enumG);<br/>
	enumMstring = enumMtoString(mParameters.enumM);<br/>
	enumNstring = enumNtoString(mParameters.enumN);<br/>
	enumPstring = enumPtoString(mParameters.enumP);<br/>
	enumQstring = enumQtoString(mParameters.enumQ);<br/>
	enumRstring = enumRtoString(mParameters.enumR);<br/>
	enumWstring = enumWtoString(mParameters.enumW);<br/>
	enumReproductionModeString = enumReproductionModeToString(mParameters.reproductionMode);<br/>
}<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setD(const EnumD&amp; enumD)<br/>
{<br/>
	mParameters.enumD = enumD;<br/>
	enumDstring = enumDtoString(mParameters.enumD);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setF(const EnumF&amp; enumF)<br/>
{<br/>
	mParameters.enumF = enumF;<br/>
	enumFstring = enumFtoString(mParameters.enumF);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setG(const EnumG&amp; enumG)<br/>
{<br/>
	mParameters.enumG = enumG;<br/>
	enumGstring = enumGtoString(mParameters.enumG);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setM(const EnumM&amp; enumM)<br/>
{<br/>
	mParameters.enumM = enumM;<br/>
	enumMstring = enumMtoString(mParameters.enumM);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setN(const EnumN&amp; enumN)<br/>
{<br/>
	mParameters.enumN = enumN;<br/>
	enumNstring = enumNtoString(mParameters.enumN);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setP(const EnumP&amp; enumP)<br/>
{<br/>
	mParameters.enumP = enumP;<br/>
	enumPstring = enumPtoString(mParameters.enumP);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setQ(const EnumQ&amp; enumQ)<br/>
{<br/>
	mParameters.enumQ = enumQ;<br/>
	enumQstring = enumQtoString(mParameters.enumQ);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setR(const EnumR&amp; enumR)<br/>
{<br/>
	mParameters.enumR = enumR;<br/>
	enumRstring = enumRtoString(mParameters.enumR);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setW(const EnumW&amp; enumW)<br/>
{<br/>
	mParameters.enumW = enumW;<br/>
	enumWstring = enumWtoString(mParameters.enumW);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setDparams(const ParameterSetD&amp; params)<br/>
{<br/>
	mParameters.paramsD = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setFparams(const ParameterSetF&amp; params)<br/>
{<br/>
	mParameters.paramsF = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setGparams(const ParameterSetG&amp; params)<br/>
{<br/>
	mParameters.paramsG = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setMparams(const ParameterSetM&amp; params)<br/>
{<br/>
	mParameters.paramsM = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setNparams(const ParameterSetN&amp; params)<br/>
{<br/>
	mParameters.paramsN = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setPparams(const ParameterSetP&amp; params)<br/>
{<br/>
	mParameters.paramsP = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setQparams(const ParameterSetQ&amp; params)<br/>
{<br/>
	mParameters.paramsQ = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setRparams(const ParameterSetR&amp; params)<br/>
{<br/>
	mParameters.paramsR = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setWParams(const ParameterSetW&amp; params)<br/>
{<br/>
	mParameters.paramsW = params;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setOutputFileName(const std::string&amp; outputFileName)<br/>
{<br/>
	dot("\nSetting to outputFileName: "+outputFileName);<br/>
	mParameters.outputFileName = outputFileName;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setSeed(const unsigned int&amp; seed)<br/>
{<br/>
	mParameters.seed = seed;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setMaxTime(const unsigned int&amp; time)<br/>
{<br/>
	mParameters.maxTime = time;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setStartPopSize(const unsigned int&amp; popSize)<br/>
{<br/>
	mParameters.startingPopSize = popSize;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setStartResources(const double&amp; resources)<br/>
{<br/>
	mParameters.startingResources = resources;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setBodySizeAdult(const double&amp; bodySize)<br/>
{<br/>
	mParameters.bodySizeAdult = bodySize;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setConstA(const double&amp; constA)<br/>
{<br/>
	mParameters.A = constA;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setConstB(const double&amp; constB)<br/>
{<br/>
	mParameters.B = constB;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setConstC(const double&amp; constC)<br/>
{<br/>
	mParameters.C = constC;<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setReproductionMode(const EnumReproductionMode &amp; reproductionMode)<br/>
{<br/>
	mParameters.reproductionMode = reproductionMode;<br/>
	enumReproductionModeString = enumReproductionModeToString(mParameters.reproductionMode);<br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::setFlag(const int&amp; value) <br/>
{ <br/>
	mFlag = value; <br/>
	writeToFile();<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::showUser() const<br/>
{<br/>
	std::cout &lt;&lt; "\n\tShowing Simulation File '" &lt;&lt; mFileName &lt;&lt; "':\n"<br/>
		&lt;&lt; mParameters &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::cout(const std::string&amp; logMessage) const<br/>
{<br/>
	std::cout &lt;&lt; "LOG: " &lt;&lt; logMessage &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SimulationFile::dot(const std::string&amp; errorMessage) const<br/>
{<br/>
	#ifdef EXTREME_LOGGING<br/>
	std::cout &lt;&lt; "DOT: " &lt;&lt; errorMessage &lt;&lt; std::endl;<br/>
	#endif<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/SimulationFile.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/SimulationFile.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;SimulationFile.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 16 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
///Class SimulationFile manages a single Simulation's parameters.<br/>
///It is closely linked with file I/O: if you set a value of the<br/>
///parameter, this is always saved to disk immediatly.<br/>
///Getting the values has not file I/O side-effects. <br/>
<br/>
#ifndef __SIMULATIONFILE_H<br/>
#define __SIMULATIONFILE_H<br/>
<br/>
#include &lt;memory&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;fstream&gt;<br/>
#include "ParameterSets.h"<br/>
#include "Enumerations.h"<br/>
#include "HelperFunctions.h"<br/>
<br/>
<br/>
<br/>
class SimulationFile<br/>
{<br/>
	private:<br/>
	ParameterSetSimulation mParameters;<br/>
<br/>
	std::string mFileName;<br/>
	std::string mVersionName1;<br/>
	std::string mVersionName2;<br/>
	std::string mCurrentVersionName;<br/>
<br/>
	std::string enumDstring, enumFstring, enumGstring, enumMstring, enumNstring;<br/>
	std::string enumPstring, enumQstring, enumRstring, enumWstring;<br/>
	std::string enumReproductionModeString;<br/>
	<br/>
	//Different file readers<br/>
	void readFromFile0();<br/>
	void readFromFile1();<br/>
	void readFromFile2();<br/>
<br/>
	//Converters<br/>
	void stringsToEnums();<br/>
	void enumsToStrings();	<br/>
<br/>
	//Debugging<br/>
	int mFlag;<br/>
	void cout(const std::string&amp; logMessage = ".") const;<br/>
	void dot(const std::string&amp; errorMessage = ".") const;<br/>
<br/>
	public:<br/>
	SimulationFile(const std::string&amp; fileName = "defaultSimFile.txt", const bool&amp; overWrite = false);<br/>
	void showUser() const;<br/>
<br/>
	//Setters, formula's<br/>
	void setD(const EnumD&amp;);<br/>
	void setF(const EnumF&amp;);<br/>
	void setG(const EnumG&amp;);<br/>
	void setM(const EnumM&amp;);<br/>
	void setN(const EnumN&amp;);<br/>
	void setP(const EnumP&amp;);<br/>
	void setQ(const EnumQ&amp;);<br/>
	void setR(const EnumR&amp;);<br/>
	void setW(const EnumW&amp;);<br/>
	//Setters, parameters of functions<br/>
	void setDparams(const ParameterSetD&amp;);<br/>
	void setFparams(const ParameterSetF&amp;);<br/>
	void setGparams(const ParameterSetG&amp;);<br/>
	void setMparams(const ParameterSetM&amp;);<br/>
	void setNparams(const ParameterSetN&amp;);<br/>
	void setPparams(const ParameterSetP&amp;);<br/>
	void setQparams(const ParameterSetQ&amp;);<br/>
	void setRparams(const ParameterSetR&amp;);<br/>
	void setWParams(const ParameterSetW&amp;);<br/>
	//Setters, other parameters<br/>
	void setOutputFileName(const std::string&amp;);<br/>
	void setSeed(const unsigned int&amp;);<br/>
	void setMaxTime(const unsigned int&amp;); <br/>
	void setStartPopSize(const unsigned int&amp;);<br/>
	void setStartResources(const double&amp;);<br/>
	void setBodySizeAdult(const double&amp;);<br/>
	void setConstA(const double&amp;);<br/>
	void setConstB(const double&amp;);<br/>
	void setConstC(const double&amp;);<br/>
	void setReproductionMode(const EnumReproductionMode &amp;);<br/>
<br/>
	//----------------------------------------------------------------------------------<br/>
	//<br/>
	// COMPUTER GENERATED CODE<br/>
	// SimulationFile<br/>
	//<br/>
	//----------------------------------------------------------------------------------<br/>
	//&nbsp;&nbsp;COMPUTER GENERATED CODE<br/>
	void setDconstA(const double&amp;);<br/>
	void setFconstA(const double&amp;);<br/>
	void setGconstA(const double&amp;);<br/>
	void setMconstA(const double&amp;);<br/>
	void setNconstA(const double&amp;);<br/>
	void setPconstA(const double&amp;);<br/>
	void setQconstA(const double&amp;);<br/>
	void setRconstA(const double&amp;);<br/>
	void setWconstA(const double&amp;);<br/>
	void setDconstB(const double&amp;);<br/>
	void setFconstB(const double&amp;);<br/>
	void setGconstB(const double&amp;);<br/>
	void setMconstB(const double&amp;);<br/>
	void setNconstB(const double&amp;);<br/>
	void setPconstB(const double&amp;);<br/>
	void setQconstB(const double&amp;);<br/>
	void setRconstB(const double&amp;);<br/>
	void setWconstB(const double&amp;);<br/>
	void setDconstC(const double&amp;);<br/>
	void setFconstC(const double&amp;);<br/>
	void setGconstC(const double&amp;);<br/>
	void setMconstC(const double&amp;);<br/>
	void setNconstC(const double&amp;);<br/>
	void setPconstC(const double&amp;);<br/>
	void setQconstC(const double&amp;);<br/>
	void setRconstC(const double&amp;);<br/>
	void setWconstC(const double&amp;);<br/>
	void setDconstD(const double&amp;);<br/>
	void setFconstD(const double&amp;);<br/>
	void setGconstD(const double&amp;);<br/>
	void setMconstD(const double&amp;);<br/>
	void setNconstD(const double&amp;);<br/>
	void setPconstD(const double&amp;);<br/>
	void setQconstD(const double&amp;);<br/>
	void setRconstD(const double&amp;);<br/>
	void setWconstD(const double&amp;);<br/>
	void setDconstE(const double&amp;);<br/>
	void setFconstE(const double&amp;);<br/>
	void setGconstE(const double&amp;);<br/>
	void setMconstE(const double&amp;);<br/>
	void setNconstE(const double&amp;);<br/>
	void setPconstE(const double&amp;);<br/>
	void setQconstE(const double&amp;);<br/>
	void setRconstE(const double&amp;);<br/>
	void setWconstE(const double&amp;);<br/>
<br/>
<br/>
	//Setter, debug<br/>
	void setFlag(const int&amp;);<br/>
<br/>
	//Getters<br/>
	ParameterSetSimulation getParameterSetSimulation() const { return mParameters; }<br/>
	ParameterSetSimulation getParameters() const { return mParameters; }<br/>
	EnumReproductionMode getReproductionMode() const { return mParameters.reproductionMode; }<br/>
	std::string getFileName() const { return mFileName; }<br/>
	std::string getOutputFileName() const { return mParameters.outputFileName; }<br/>
	int getFlag() const { return mFlag; }<br/>
<br/>
	//File I/O<br/>
	void writeToFile();<br/>
	void readFromFile();	<br/>
	<br/>
	void coutAll() const;	<br/>
};<br/>
<br/>
<br/>
<br/>
#endif //#ifndef __SIMULATIONFILE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/SoilMite.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/SoilMite.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;SoilMiteBase.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 24 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
//----------------------------------------------------------------------------------<br/>
#include "SoilMite.h"<br/>
//#define EXTREME_LOGGING<br/>
//----------------------------------------------------------------------------------<br/>
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SoilMiteBase::sPopSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br/>
double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SoilMiteBase::mBodySizeAdult = -1.0;<br/>
FunctionsSingleton * SoilMiteBase::mpFunctions&nbsp;&nbsp;&nbsp;&nbsp;= FunctionsSingleton::instance();<br/>
//----------------------------------------------------------------------------------<br/>
SoilMiteBase::SoilMiteBase()<br/>
{<br/>
	mBodySize = 0.0;<br/>
	mFeedRate = 0.0;<br/>
	mAllocation = 0.0;<br/>
	mBiomassEggs = 0.0;<br/>
	sPopSize++;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
SoilMiteBase::~SoilMiteBase()<br/>
{<br/>
	sPopSize--;<br/>
	if (sPopSize&lt;0) assert(!"Population size BELOW zero!!!");<br/>
<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
bool SoilMiteBase::doIdie() const<br/>
{<br/>
	assert(mpFunctions!=NULL);<br/>
	assert(mChanceToDie&gt;=0.0 &amp;&amp; mChanceToDie&lt;=1.0);<br/>
	const double randomNumber = uniform();<br/>
	assert(randomNumber&gt;=0.0 &amp;&amp; randomNumber&lt;=1.0);<br/>
	if (mChanceToDie&gt;randomNumber) return true;<br/>
	else return false;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SoilMiteBase::intake(const double&amp; resources)<br/>
{<br/>
	assert(mpFunctions!=NULL);<br/>
	//Let the mite have its meal<br/>
	mFeedRate = mpFunctions-&gt;F(resources,mBodySize);<br/>
	assert(mFeedRate&lt;=resources);<br/>
	assert(mFeedRate&gt;=0.0);<br/>
	assert(mReserves&gt;=0.0);<br/>
	//change its body size and reserves<br/>
	mAllocation = mpFunctions-&gt;P(mFeedRate, mReserves);<br/>
	assert(mAllocation&gt;=0.0 &amp;&amp; mAllocation&lt;=1.0);<br/>
	const double metabolism = mpFunctions-&gt;M(mBodySize, mReserves);<br/>
	assert(metabolism&gt;=0.0);<br/>
	//Determine the amount of biomass invested in eggs<br/>
	mBiomassEggs = (mBodySize &lt; mBodySizeAdult&nbsp;&nbsp;? 0.0 : mpFunctions-&gt;Q(mReserves));<br/>
	assert(mpFunctions-&gt;Q(mReserves)&gt;=0.0 &amp;&amp; mpFunctions-&gt;Q(mReserves)&lt;=mReserves);<br/>
	//Change body<br/>
	const double alpha = mpFunctions-&gt;getAlpha();<br/>
	const double beta&nbsp;&nbsp;= mpFunctions-&gt;getBeta();<br/>
	const double gamma = mpFunctions-&gt;getGamma();<br/>
	assert(alpha&gt;0.0);<br/>
	assert(beta &gt;0.0);<br/>
	//assert(gamma&gt;0.0 &amp;&amp; gamma&lt;=1.0);<br/>
	<br/>
	mBodySize+=alpha*mAllocation*mFeedRate;<br/>
	mReserves+=(beta*(1.0-mAllocation)*mFeedRate) - metabolism - (gamma*mBiomassEggs);<br/>
	//assert(mReserves&gt;=0.0);<br/>
	if (mReserves&lt;0)<br/>
	{<br/>
		mChanceToDie = 1.0;<br/>
	}<br/>
	else<br/>
	{<br/>
		mChanceToDie = mpFunctions-&gt;D(mBodySize,mReserves);<br/>
	}<br/>
	assert(mChanceToDie&gt;=0.0 &amp;&amp; mChanceToDie&lt;=1.0);<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SoilMiteBase::cout(const std::string&amp; logMessage) const<br/>
{<br/>
	std::cout &lt;&lt; "LOG: " &lt;&lt; logMessage &lt;&lt; std::endl;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void SoilMiteBase::dot(const std::string&amp; errorMessage) const<br/>
{<br/>
	#ifdef EXTREME_LOGGING<br/>
	std::cout &lt;&lt; "DOT: " &lt;&lt; errorMessage &lt;&lt; std::endl;<br/>
	#endif<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
//<br/>
// VIRTUAL FUNCTIONS OF DERIVED CLASSES<br/>
//<br/>
//----------------------------------------------------------------------------------<br/>
EnumErrorCode SoilMiteFraction::reproduce(std::vector&lt;SoilMiteBase*&gt;&amp; offspring)<br/>
{<br/>
	if (mBiomassEggs==0.0) return EcNoError;<br/>
	<br/>
<br/>
	assert(mpFunctions!=NULL);<br/>
<br/>
	dot("BiomassEggs: " + ftoa(mBiomassEggs));<br/>
<br/>
	mFractionBiomassPerOffspringInitial = mpFunctions-&gt;G(mFeedRate, mReserves);<br/>
	dot("Fraction Biomass Per Offspring (Initial):" + ftoa(mFractionBiomassPerOffspringInitial));<br/>
	assert(mFractionBiomassPerOffspringInitial&gt;0.0 &amp;&amp; mFractionBiomassPerOffspringInitial &lt;=1.0);<br/>
	const double nOffspringDinitial = 1.0/mFractionBiomassPerOffspringInitial;<br/>
	const int nOffspring = static_cast&lt;int&gt;(round(nOffspringDinitial));<br/>
<br/>
	dot("nOffspringDinitial: " + ftoa(nOffspringDinitial));<br/>
<br/>
	assert(static_cast&lt;int&gt;(round(1.4))==1); assert(static_cast&lt;int&gt;(round(1.6))==2);<br/>
	const double nOffspringD = static_cast&lt;double&gt;(nOffspring);<br/>
	mFractionBiomassPerOffspring = (1.0/nOffspringD);<br/>
	const double biomassPerOffspring = mFractionBiomassPerOffspring*mBiomassEggs;<br/>
<br/>
	dot("nOffspring (final): " + ftoa(nOffspring));<br/>
<br/>
	if (nOffspring&gt;100000) <br/>
	{<br/>
		std::cout &lt;&lt; "More then 100000 offspring were created. Terminating simulation." &lt;&lt; std::endl;<br/>
		//Clean offspring vector<br/>
		unsigned int nOffspring = offspring.size();<br/>
		for (unsigned int i = 0; i&lt;nOffspring; ++i) { delete offspring[i]; offspring[i]=NULL; }<br/>
		offspring.resize(0);<br/>
		return EcNoffspringTooBigSingleParent; <br/>
	}<br/>
<br/>
	for (int i=0; i&lt;nOffspring; ++i)<br/>
	{<br/>
		SoilMiteBase * pOffspring = new SoilMiteFraction(biomassPerOffspring);<br/>
		assert(pOffspring!=NULL);<br/>
		offspring.push_back(pOffspring);<br/>
	}<br/>
	<br/>
	return EcNoError;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
EnumErrorCode SoilMiteAmount::reproduce(std::vector&lt;SoilMiteBase*&gt;&amp; offspring)<br/>
{<br/>
	if (mBiomassEggs==0.0) return EcNoError;<br/>
	assert(mpFunctions!=NULL);<br/>
<br/>
	const double nOffspringInitial = mpFunctions-&gt;N(mFeedRate, mReserves);<br/>
	const int nOffspring = static_cast&lt;int&gt;(round(nOffspringInitial));<br/>
	if (nOffspring==0) return EcNoError;<br/>
<br/>
	const double biomassPerOffspring = mBiomassEggs / static_cast&lt;double&gt;(nOffspring);<br/>
<br/>
	if (nOffspring&gt;100000) <br/>
	{ <br/>
		std::cout &lt;&lt; "More then 100000 offspring were created. Terminating simulation." &lt;&lt; std::endl;<br/>
		//Clean offspring vector<br/>
		unsigned int nOffspring = offspring.size();<br/>
		for (unsigned int i = 0; i&lt;nOffspring; ++i) { delete offspring[i]; offspring[i]=NULL; }<br/>
		offspring.resize(0);<br/>
		return EcNoffspringTooBigSingleParent; <br/>
	}<br/>
<br/>
	for (int i=0; i&lt;nOffspring; ++i)<br/>
	{<br/>
		SoilMiteBase * pOffspring = new SoilMiteAmount(biomassPerOffspring);<br/>
		assert(pOffspring!=NULL);<br/>
		offspring.push_back(pOffspring);<br/>
	}<br/>
	<br/>
	return EcNoError;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/SoilMite.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/SoilMite.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;SoilMite.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 24 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
//----------------------------------------------------------------------------------<br/>
#ifndef __SOILMITE_H<br/>
#define __SOILMITE_H<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert.h&gt;<br/>
#include &lt;string&gt;<br/>
#include "random.h"<br/>
#include "FunctionsSingleton.h"<br/>
#include "Enumerations.h"<br/>
//----------------------------------------------------------------------------------<br/>
class SoilMiteBase<br/>
{<br/>
<br/>
	public:<br/>
	SoilMiteBase();<br/>
	virtual ~SoilMiteBase();<br/>
	bool doIdie() const;<br/>
	void intake(const double&amp;);<br/>
	virtual EnumErrorCode reproduce(std::vector&lt;SoilMiteBase*&gt;&amp;) = 0;<br/>
	double getFeedRate() const { return mFeedRate; }<br/>
	double getBodySize() const { assert(mBodySize&gt;=0.0); return mBodySize; }<br/>
	double getReserves() const { return mReserves; }<br/>
	double getChanceToDie() const { return mChanceToDie; }<br/>
	double getAllocation() const { return mAllocation; }<br/>
	virtual double getFractionBiomassPerOffspring() const = 0;<br/>
	virtual double getFractionBiomassPerOffspringInitial() const = 0;<br/>
	virtual double getNoffspringInitial() const = 0;<br/>
	virtual unsigned int getNoffspring() const = 0;<br/>
<br/>
	static void setBodySizeAdult(const double&amp; size) { mBodySizeAdult = size; }<br/>
	static int getPopSize() { return sPopSize; }<br/>
	static double getBodySizeAdult() { return mBodySizeAdult; }<br/>
<br/>
	protected:<br/>
	double mBodySize;<br/>
	double mReserves;<br/>
	double mFeedRate;<br/>
	double mBiomassEggs;<br/>
	double mChanceToDie;<br/>
	double mAllocation;<br/>
	static FunctionsSingleton * mpFunctions;<br/>
	static int sPopSize;<br/>
	static double mBodySizeAdult;<br/>
<br/>
	void cout(const std::string&amp; logMessage = ".") const;<br/>
	void dot(const std::string&amp; errorMessage = ".") const;<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class SoilMiteFraction : public SoilMiteBase<br/>
{<br/>
	public:<br/>
	//Constructor for first initialization<br/>
	SoilMiteFraction(const std::string&amp; initString) <br/>
	{<br/>
		assert(initString=="INIT");<br/>
		mFractionBiomassPerOffspringInitial = 1.0;<br/>
		mFractionBiomassPerOffspring = 1.0;<br/>
		mBodySize = mBodySizeAdult*uniform();<br/>
		assert(mBodySizeAdult&gt;=0.0);<br/>
		assert(mBodySize&gt;=0.0 &amp;&amp; mBodySize&lt;=mBodySizeAdult);<br/>
		mReserves = uniform()*10.0; //Just value<br/>
		mChanceToDie = mpFunctions-&gt;D(mBodySize, mReserves);<br/>
		assert(mChanceToDie&gt;=0.0 &amp;&amp; mChanceToDie&lt;=1.0);<br/>
	}<br/>
<br/>
	SoilMiteFraction(const double&amp; biomassEggs) <br/>
	{<br/>
		mFractionBiomassPerOffspringInitial = 1.0;<br/>
		mFractionBiomassPerOffspring = 1.0;<br/>
		assert(biomassEggs&gt;=0.0);<br/>
		mBodySize = 0.0;<br/>
		mReserves = biomassEggs;<br/>
		mChanceToDie = mpFunctions-&gt;D(mBodySize, mReserves);<br/>
		assert(mChanceToDie&gt;=0.0 &amp;&amp; mChanceToDie&lt;=1.0);<br/>
	}<br/>
	EnumErrorCode reproduce(std::vector&lt;SoilMiteBase*&gt;&amp;);<br/>
	double getFractionBiomassPerOffspring() const { return mFractionBiomassPerOffspring; }<br/>
	double getFractionBiomassPerOffspringInitial() const { return mFractionBiomassPerOffspringInitial; }<br/>
	double getNoffspringInitial() const <br/>
	{ <br/>
		if (mFractionBiomassPerOffspringInitial==0.0) return 0.0;<br/>
		else return 1.0/mFractionBiomassPerOffspringInitial;<br/>
	}<br/>
	unsigned int getNoffspring() const <br/>
	{ <br/>
		if (mFractionBiomassPerOffspring==0.0) return 0;<br/>
		else return static_cast&lt;unsigned int&gt;(1.0/mFractionBiomassPerOffspring);<br/>
	}<br/>
<br/>
	private:<br/>
	double mFractionBiomassPerOffspring;<br/>
	double mFractionBiomassPerOffspringInitial;<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class SoilMiteAmount : public SoilMiteBase<br/>
{<br/>
	public:<br/>
	SoilMiteAmount(const std::string&amp; initString) <br/>
	{<br/>
		assert(initString=="INIT");<br/>
		mBodySize = mBodySizeAdult*uniform();<br/>
		assert(mBodySizeAdult&gt;=0.0);<br/>
		assert(mBodySize&gt;=0.0 &amp;&amp; mBodySize&lt;=mBodySizeAdult);<br/>
		mReserves = uniform()*10.0; //Just a number<br/>
		mChanceToDie = mpFunctions-&gt;D(mBodySize, mReserves);<br/>
		assert(mChanceToDie&gt;=0.0 &amp;&amp; mChanceToDie&lt;=1.0);<br/>
		mNoffspringInitial = 0.0;<br/>
		mNoffspring = 0;<br/>
	}<br/>
	SoilMiteAmount(const double&amp; biomassEggs) <br/>
	{<br/>
		assert(biomassEggs&gt;=0.0);<br/>
		mBodySize = 0.0;<br/>
		mReserves = biomassEggs;<br/>
		mChanceToDie = mpFunctions-&gt;D(mBodySize, mReserves);<br/>
		assert(mChanceToDie&gt;=0.0 &amp;&amp; mChanceToDie&lt;=1.0);<br/>
		mNoffspringInitial = 0.0;<br/>
		mNoffspring = 0;<br/>
	}<br/>
	<br/>
	//The only important one<br/>
	EnumErrorCode reproduce(std::vector&lt;SoilMiteBase*&gt;&amp;);<br/>
	<br/>
	double getFractionBiomassPerOffspring() const <br/>
	{ <br/>
		if (mNoffspringInitial==0.0) return 0.0;<br/>
		else return 1.0/mNoffspringInitial; <br/>
	}<br/>
	double getFractionBiomassPerOffspringInitial() const <br/>
	{ <br/>
		if (mNoffspring==0) return 0.0;<br/>
		else return 1.0/static_cast&lt;double&gt;(mNoffspring);<br/>
	}<br/>
	double getNoffspringInitial() const { return mNoffspringInitial; }<br/>
	unsigned int getNoffspring() const { return mNoffspring; }<br/>
<br/>
	private:<br/>
	double mNoffspringInitial;<br/>
	unsigned int mNoffspring;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
#endif //#ifndef __SOILMITE_DEFAULT_H<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyD.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyD.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyD.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 31 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
///StrategyD[something] embodies the function for death rate.<br/>
///<br/>
///example of the formula being embodied by StrategyDdefault:<br/>
///<br/>
///D(s_i,v_i) = (1-exp(-alph*s_i)*exp(-B*v_i)+C<br/>
///<br/>
///D : Death rate, chance to die per time unit<br/>
///s_i : individual i's body size<br/>
///v_i : individual i's reserves<br/>
///A, B, C : constants<br/>
///<br/>
///The Strategy pattern can be found described in ref. 1.<br/>
///Instead of using the standard 'evil' pointer, I use the std::auto_ptr (ref. 2)<br/>
///<br/>
///<br/>
///<br/>
///1) Design Patterns. By Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. ISBN: 0-201-63361-2<br/>
///2) Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions. By Herb Sutter. ISBN: 0-201-61562-2<br/>
<br/>
#ifndef __STRATEGY_D_H<br/>
#define __STRATEGY_D_H<br/>
<br/>
#include &lt;fstream&gt;<br/>
#include &lt;memory&gt;<br/>
#include "ParameterSets.h"<br/>
#include "HelperFunctions.h"<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyDbase<br/>
{<br/>
	public:<br/>
	StrategyDbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetD);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyDbase() {};<br/>
	virtual double eval(const double&amp;, const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual std::string getString(const double&amp;, const double&amp;) const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		<br/>
		for (double s = 0.0; s&lt;10.0; s+=0.1)<br/>
		{<br/>
			for (double v = 0.0; v&lt;10.0; v+=0.1)<br/>
			{<br/>
				fileOutput &lt;&lt; s &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; eval(s,v) &lt;&lt; "\n";<br/>
			}<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetD&gt; mpParams;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyDdefault : public StrategyDbase<br/>
{<br/>
	public:<br/>
	StrategyDdefault(const ParameterSetD * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B = pParams-&gt;B;<br/>
		mpParams-&gt;C = pParams-&gt;C;<br/>
		mpParams-&gt;D = pParams-&gt;D;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0);<br/>
		assert(mpParams-&gt;C&gt;=0.0);<br/>
		assert(mpParams-&gt;D&gt;=0.0);<br/>
	}<br/>
	~StrategyDdefault() {};<br/>
	double eval(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		//OLD const double d = (1.0-exp(-mpParams-&gt;A*s)) * exp(-mpParams-&gt;B*v) + mpParams-&gt;C;<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const double d = A + (((1.0-A)*D*pow(s/(v+B),C))/(1.0+pow(s/(v+B),C)));<br/>
		assert(d&gt;=0 &amp;&amp; d&lt;=1.0);<br/>
		return d;<br/>
	}<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string begin =&nbsp;&nbsp;"D(s,v) = ";<br/>
		const std::string part1 = "A + (1.0-A).D.((s/(v+B))^C) / (1.0+(s/(v+B))^C)";<br/>
		return begin + part1;<br/>
	}<br/>
	std::string getString(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const std::string begin =&nbsp;&nbsp;"D(s,v) = D("+ftoa(s)+","+ftoa(v)+") = ";<br/>
		const std::string part1 = ftoa(A)+" + (1.0-"+ftoa(A)+")."+ftoa(D)+".(("+ftoa(s)<br/>
		&nbsp;&nbsp;+"/("+ftoa(v)+"+"+ftoa(B)+"))^"+ftoa(C)<br/>
		&nbsp;&nbsp;+") / (1.0+("+ftoa(s)+"/("+ftoa(v)+"+"+ftoa(B)+"))^"+ftoa(C)+")";<br/>
		const std::string outcome = ftoa(eval(s,v));<br/>
		return begin + part1 + " = "+outcome;<br/>
	}<br/>
<br/>
	void testMe() const<br/>
	{<br/>
		const std::string fileName = "Ddefault.rda";<br/>
		StrategyDbase::testMe(fileName);<br/>
	}<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
/*class StrategyDsizeOnly : public StrategyDbase<br/>
{<br/>
	public:<br/>
	StrategyDsizeOnly(const ParameterSetD * pParams)<br/>
	{<br/>
		mpParams.reset(new ParameterSetD);<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
	}<br/>
	~StrategyDsizeOnly() {};<br/>
	double eval(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		const double d = (1.0-exp(-mpParams-&gt;A*s));<br/>
		assert(d&gt;=0 &amp;&amp; d&lt;=1.0);<br/>
		return d;<br/>
	}<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string begin =&nbsp;&nbsp;"D(s,v) = ";<br/>
		const std::string part1 = "(1.0-exp(-A*s))";<br/>
		return begin + part1 + " + C";<br/>
	}<br/>
	std::string getString(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		const std::string begin =&nbsp;&nbsp;"D(s,v) = D("+ftoa(s)+","+ftoa(v)+") = ";<br/>
		const std::string part1 = "(1.0-exp(-" 	+ftoa(mpParams-&gt;A) + "*"+ftoa(s)+"))";<br/>
		const std::string outcome = ftoa(eval(s,v));<br/>
		return begin + part1 +&nbsp;&nbsp;" = "+outcome;<br/>
	}<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyDconstant : public StrategyDbase<br/>
{<br/>
	public:<br/>
	StrategyDconstant(const ParameterSetD * pParams)<br/>
	{<br/>
		mpParams.reset(new ParameterSetD);<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		assert(mpParams-&gt;A&gt;=0.0&nbsp;&nbsp;&amp;&amp; mpParams-&gt;A&lt;=1.0);<br/>
	}<br/>
	~StrategyDconstant() {};<br/>
	double eval(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		const double d = mpParams-&gt;A;<br/>
		assert(d&gt;=0 &amp;&amp; d&lt;=1.0);<br/>
		return d;<br/>
	}<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string begin =&nbsp;&nbsp;"D(s,v) = ";<br/>
		const std::string part1 = "A";<br/>
		return begin + part1;<br/>
	}<br/>
	std::string getString(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		const std::string begin =&nbsp;&nbsp;"D(s,v) = D("+ftoa(s)+","+ftoa(v)+") = ";<br/>
		const std::string part1 = ftoa(mpParams-&gt;A);<br/>
		const std::string outcome = ftoa(eval(s,v));<br/>
		return begin + part1 +&nbsp;&nbsp;" = "+outcome;<br/>
	}<br/>
};*/<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
<br/>
#endif //#ifndef __STRATEGY_D_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyF.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyF.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyF.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 31 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __STRATEGY_F_H<br/>
#define __STRATEGY_F_H<br/>
<br/>
#include &lt;memory&gt;<br/>
#include "ParameterSets.h"<br/>
#include "HelperFunctions.h"<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyFbase<br/>
{<br/>
	public:<br/>
	StrategyFbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetF);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyFbase() {}<br/>
	virtual double eval(const double&amp;, const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual std::string getString(const double&amp;, const double&amp;) const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		<br/>
		for (double r = 0.0; r&lt;10.0; r+=0.1)<br/>
		{<br/>
			for (double s = 0.0; s&lt;10.0; s+=0.1)<br/>
			{<br/>
				fileOutput &lt;&lt; r &lt;&lt; " " &lt;&lt; s &lt;&lt; " " &lt;&lt; eval(r,s) &lt;&lt; "\n";<br/>
			}<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetF&gt; mpParams;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyFdefault : public StrategyFbase<br/>
{<br/>
	public:<br/>
	StrategyFdefault(const ParameterSetF * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		assert(mpParams-&gt;A&gt;=0.0 &amp;&amp; mpParams-&gt;A&lt;=1.0);<br/>
	}<br/>
	~StrategyFdefault() {}<br/>
	double eval(const double&amp; r, const double&amp; s) const<br/>
	{<br/>
		assert(r&gt;=0.0);<br/>
		assert(s&gt;=0.0);<br/>
		return (mpParams-&gt;A * r);<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string begin = "F(r,s) = ";<br/>
		const std::string part1 = "A*r";<br/>
		return begin + part1;<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; r, const double&amp; s) const<br/>
	{<br/>
		const std::string begin = "F(r,s) = F("+ftoa(r)+","+ftoa(s)+") = ";<br/>
		const std::string part1 = ftoa(mpParams-&gt;A)+"*"+ftoa(r);<br/>
		const std::string outcome = ftoa(eval(r,s));<br/>
		return begin + part1 + " = "+outcome;<br/>
	}<br/>
		void testMe() const<br/>
	{<br/>
		const std::string fileName = "Fdefault.rda";<br/>
		StrategyFbase::testMe(fileName);<br/>
	}<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
<br/>
<br/>
#endif //#ifndef __STRATEGY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyG.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyG.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyG.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 31 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __STRATEGY_G_H<br/>
#define __STRATEGY_G_H<br/>
<br/>
#include &lt;memory&gt;<br/>
#include "ParameterSets.h"<br/>
#include "HelperFunctions.h"<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyGbase<br/>
{<br/>
	public:<br/>
	StrategyGbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetG);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyGbase() {}<br/>
	virtual double eval(const double&amp;, const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual std::string getString(const double&amp;, const double&amp;) const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		<br/>
		for (double f = 0.0; f&lt;10.0; f+=0.1)<br/>
		{<br/>
			for (double v = 0.0; v&lt;10.0; v+=0.1)<br/>
			{<br/>
				fileOutput &lt;&lt; f &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; eval(f,v) &lt;&lt; "\n";<br/>
			}<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetG&gt; mpParams;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyGplastic : public StrategyGbase<br/>
{<br/>
	public:<br/>
	StrategyGplastic(const ParameterSetG * pParams)<br/>
	{<br/>
		assert(pParams-&gt;A&gt;=0.0);<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
	}<br/>
	~StrategyGplastic() {}<br/>
	double eval(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double g = 1.0-exp(-A*(f-v)*(f-v));<br/>
		assert(g&gt;=0.0 &amp;&amp; g&lt;=1.0);<br/>
		if (g&lt;0.001)<br/>
		{<br/>
			std::cout &lt;&lt; "WARNING: Value of Gdefault was smaller then 0.001. Setting this to the value of 0.001" &lt;&lt; std::endl;<br/>
			return 0.001;<br/>
		}<br/>
		return g;<br/>
	}<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string gStart =&nbsp;&nbsp;"G(f,v) = ";<br/>
		const std::string g1 = "1.0-exp(-A*(f-v)*(f-v))";<br/>
		const std::string g = gStart + g1;<br/>
		return g;<br/>
<br/>
	}<br/>
	std::string getString(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const std::string gStart =&nbsp;&nbsp;"G(f,v) = F("+ftoa(f)+","+ftoa(v)+") = ";<br/>
		const std::string g1 = "1.0-exp(-"+ftoa(A)+"*("+ftoa(f)+"-"+ftoa(v)+")*("+ftoa(f)+"-"+ftoa(v)+"))";<br/>
		const std::string gOutcome = ftoa(eval(f,v));<br/>
		const std::string g = gStart + g1+" = " + gOutcome;<br/>
		return g;<br/>
	}<br/>
<br/>
	void testMe() const<br/>
	{<br/>
		const std::string fileName = "Gplastic.rda";<br/>
		StrategyGbase::testMe(fileName);<br/>
	}<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyGconstant : public StrategyGbase<br/>
{<br/>
	public:<br/>
	StrategyGconstant(const ParameterSetG * pParams)<br/>
	{<br/>
		assert(pParams-&gt;A&gt;=0.0);<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
	}<br/>
	~StrategyGconstant() {}<br/>
	double eval(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double g = mpParams-&gt;A;<br/>
		assert(g&gt;=0.0 &amp;&amp; g&lt;=1.0);<br/>
		return g;<br/>
	}<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string gStart =&nbsp;&nbsp;"G(f,v) = ";<br/>
		const std::string g1 = "A";<br/>
		const std::string g = gStart + g1;<br/>
		return g;<br/>
<br/>
	}<br/>
	std::string getString(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const std::string gStart =&nbsp;&nbsp;"G(f,v) = G("+ftoa(f)+","+ftoa(v)+") = ";<br/>
		const std::string g1 = ftoa(A);<br/>
		const std::string gOutcome = ftoa(eval(f,v));<br/>
		const std::string g = gStart + g1+" = " + gOutcome;<br/>
		return g;<br/>
	}<br/>
<br/>
	void testMe() const<br/>
	{<br/>
		StrategyGbase::testMe("Gconstant.rda");<br/>
	}<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
<br/>
#endif //#ifndef __STRATEGY_G_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyM.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyM.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyM.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 31 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __STRATEGY_M_H<br/>
#define __STRATEGY_M_H<br/>
<br/>
#include &lt;memory&gt;<br/>
#include "ParameterSets.h"<br/>
#include "HelperFunctions.h"<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyMbase<br/>
{<br/>
	public:<br/>
	StrategyMbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetM);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyMbase() {}<br/>
	virtual double eval(const double&amp;, const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual std::string getString(const double&amp;, const double&amp;) const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		<br/>
		for (double s = 0.0; s&lt;10.0; s+=0.1)<br/>
		{<br/>
			for (double v = 0.0; v&lt;10.0; v+=0.1)<br/>
			{<br/>
				fileOutput &lt;&lt; s &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; eval(s,v) &lt;&lt; "\n";<br/>
			}<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetM&gt; mpParams;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyMdefault : public StrategyMbase<br/>
{<br/>
	public:<br/>
	StrategyMdefault(const ParameterSetM * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
	}<br/>
	~StrategyMdefault() {}<br/>
	double eval(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		return s * mpParams-&gt;A;<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		return "M(s,v) = A.s";<br/>
<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const std::string mStart = "M(s,v) = M("+ftoa(s)+","+ftoa(v)+") = ";<br/>
		const std::string m1 = ftoa(A)+"*"+ftoa(s);<br/>
		const std::string mOutcome = ftoa(eval(s,v));<br/>
		const std::string m = mStart + m1 + " = " + mOutcome;<br/>
		return m;<br/>
	}<br/>
	<br/>
		void testMe() const<br/>
	{<br/>
		StrategyMbase::testMe("Mdefault.rda");<br/>
	}<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyMconstant : public StrategyMbase<br/>
{<br/>
	public:<br/>
	StrategyMconstant(const ParameterSetM * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B&nbsp;&nbsp;= pParams-&gt;B;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
	}<br/>
	~StrategyMconstant() {}<br/>
	double eval(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		assert(s&gt;=0.0);<br/>
		assert(v&gt;=0.0);<br/>
		const double m = mpParams-&gt;A;<br/>
		return m;<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string mStart = "M(s,v) = ";<br/>
		const std::string m1 = "A";<br/>
		const std::string m = mStart + m1;<br/>
		return m;<br/>
<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; s, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const std::string mStart = "M(s,v) = M("+ftoa(s)+","+ftoa(v)+") = ";<br/>
		const std::string m1 = ftoa(A);<br/>
		const std::string mOutcome = ftoa(eval(s,v));<br/>
		const std::string m = mStart + m1 + " = " + mOutcome;<br/>
		return m;<br/>
	}<br/>
	<br/>
		void testMe() const<br/>
	{<br/>
		StrategyMbase::testMe("Mconstant.rda");<br/>
	}<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
<br/>
#endif //#ifndef __STRATEGY_M_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyN.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyN.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyN.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 30 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __STRATEGY_N_H<br/>
#define __STRATEGY_N_H<br/>
<br/>
#include &lt;memory&gt;<br/>
#include "ParameterSets.h"<br/>
#include "HelperFunctions.h"<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyNbase<br/>
{<br/>
	public:<br/>
	StrategyNbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetN);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyNbase() {}<br/>
	virtual double eval(const double&amp;, const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual std::string getString(const double&amp;, const double&amp;) const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		<br/>
		for (double f = 0.0; f&lt;10.0; f+=0.1)<br/>
		{<br/>
			for (double v = 0.0; v&lt;10.0; v+=0.1)<br/>
			{<br/>
				fileOutput &lt;&lt; f &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; eval(f,v) &lt;&lt; "\n";<br/>
			}<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetN&gt; mpParams;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyNplastic : public StrategyNbase<br/>
{<br/>
	public:<br/>
	StrategyNplastic(const ParameterSetN * pParams)<br/>
	{<br/>
		assert(pParams!=NULL);<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B = pParams-&gt;B;<br/>
		mpParams-&gt;C = pParams-&gt;C;<br/>
		mpParams-&gt;D = pParams-&gt;D;<br/>
		mpParams-&gt;E = pParams-&gt;E;<br/>
		assert(mpParams-&gt;A&gt;=0.0 &amp;&amp; mpParams-&gt;A&lt;=1.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0);<br/>
		assert(mpParams-&gt;C&gt;=0.0);<br/>
		assert(mpParams-&gt;D&gt;=0.0);<br/>
		assert(mpParams-&gt;E&gt;=0.0);<br/>
	}<br/>
	~StrategyNplastic() {}<br/>
	double eval(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const double E = mpParams-&gt;E;<br/>
		const double n = A*(D*f + E*v)+(1.0-A)*(B*D+C*E);<br/>
		assert(n&gt;=0.0);<br/>
		return n;<br/>
	}<br/>
	std::string getString() const<br/>
	{<br/>
		return "N(f,v) = A*(D*f + E*v)+(1.0-A)*(B*D+C*E)";<br/>
<br/>
	}<br/>
	std::string getString(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const double E = mpParams-&gt;E;<br/>
		<br/>
		const std::string nStart =&nbsp;&nbsp;"N(f,v) = N("+ftoa(f)+","+ftoa(v)+") = ";<br/>
		const std::string n1 = ftoa(A)+"*("+ftoa(D)+"*"+ftoa(f)+" + "+ftoa(E)+"*"+ftoa(v)+")+(1.0-"+ftoa(A)+")*("+ftoa(B)+"*"+ftoa(D)+"+"+ftoa(C)+"*"+ftoa(E)+")";<br/>
		const std::string nOutcome = ftoa(eval(f,v));<br/>
		const std::string n = nStart + n1+" = " + nOutcome;<br/>
		return n;<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyNbase::testMe("Nplastic.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyNconstant : public StrategyNbase<br/>
{<br/>
	public:<br/>
	StrategyNconstant(const ParameterSetN * pParams)<br/>
	{<br/>
		assert(pParams!=NULL);<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		assert(pParams-&gt;A&gt;=0.0);<br/>
	}<br/>
	~StrategyNconstant() {}<br/>
	double eval(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		return mpParams-&gt;A;<br/>
	}<br/>
	std::string getString() const<br/>
	{<br/>
		return "N(f,v) = A";<br/>
<br/>
	}<br/>
	std::string getString(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const std::string nStart =&nbsp;&nbsp;"N(f,v) = N("+ftoa(f)+","+ftoa(v)+") = ";<br/>
		const std::string n1 = ftoa(A);<br/>
		const std::string nOutcome = ftoa(eval(f,v));<br/>
		const std::string n = nStart + n1+" = " + nOutcome;<br/>
		return n;<br/>
	}<br/>
<br/>
	void testMe() const { StrategyNbase::testMe("Nconstant.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
#endif //#ifndef __STRATEGY_N_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyP.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyP.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyP.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 31 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __STRATEGY_P_H<br/>
#define __STRATEGY_P_H<br/>
<br/>
#include &lt;memory&gt;<br/>
#include "ParameterSets.h"<br/>
#include "HelperFunctions.h"<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyPbase<br/>
{<br/>
	public:<br/>
	StrategyPbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetP);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyPbase() {}<br/>
	virtual double eval(const double&amp;, const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual std::string getString(const double&amp;, const double&amp;) const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		<br/>
		for (double f = 0.0; f&lt;10.0; f+=0.1)<br/>
		{<br/>
			for (double v = 0.0; v&lt;10.0; v+=0.1)<br/>
			{<br/>
				fileOutput &lt;&lt; f &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; eval(f,v) &lt;&lt; "\n";<br/>
			}<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetP&gt; mpParams;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
/* Removed at 01-08-2005<br/>
class StrategyPplasticA : public StrategyPbase<br/>
{<br/>
	public:<br/>
	StrategyPplasticA(const ParameterSetP * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B&nbsp;&nbsp;= pParams-&gt;B;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0);<br/>
	}<br/>
	~StrategyPplasticA() {}<br/>
	double eval(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		assert(f&gt;=0.0);<br/>
		assert(v&gt;=0.0);<br/>
		const double p1 = 1.0-exp(-mpParams-&gt;A * f);<br/>
		const double p2 = 1.0-exp(-mpParams-&gt;B&nbsp;&nbsp;* v);<br/>
		const double p&nbsp;&nbsp;= p1 * p2;<br/>
		assert(p1&gt;=0.0 &amp;&amp; p1&lt;=1.0);<br/>
		assert(p2&gt;=0.0 &amp;&amp; p2&lt;=1.0);<br/>
		assert(p &gt;=0.0 &amp;&amp; p &lt;=1.0);<br/>
		return p;<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string pBegin = "P(f,v) = ";<br/>
		const std::string p1 = "[1.0-exp(-A*f)]";<br/>
		const std::string p2 = "[1.0-exp(-B *v)]";<br/>
		const std::string p = pBegin + p1 + " * " + p2;<br/>
		return p;<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B&nbsp;&nbsp;= mpParams-&gt;B;<br/>
		const std::string pBegin = "P(f,v) = P("+ftoa(f)+","+ftoa(v)+") = ";<br/>
		const std::string p1 = "[1.0-exp(-"+ftoa(A)+"*"+ftoa(f)+")]";<br/>
		const std::string p2 = "[1.0-exp(-"+ftoa(B )+"*"+ftoa(v)+")]";<br/>
		const std::string pOutcome = ftoa(eval(f,v));<br/>
		const std::string p = pBegin + p1 + " * " + p2 + " = " + pOutcome;<br/>
		return p;<br/>
	}<br/>
};*/<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyPplastic : public StrategyPbase<br/>
{<br/>
	public:<br/>
	StrategyPplastic(const ParameterSetP * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B = pParams-&gt;B;<br/>
		mpParams-&gt;C = pParams-&gt;C;<br/>
		mpParams-&gt;D = pParams-&gt;D;<br/>
		mpParams-&gt;E = pParams-&gt;E;<br/>
		assert(mpParams-&gt;A&gt;=0.0 &amp;&amp; mpParams-&gt;A&lt;=1.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0);<br/>
		assert(!(mpParams-&gt;C==0.0 &amp;&amp; mpParams-&gt;A!=0.0));<br/>
		assert(mpParams-&gt;D&gt;=0.0);<br/>
		assert(!(mpParams-&gt;E==0.0 &amp;&amp; mpParams-&gt;A!=0.0));<br/>
	}<br/>
	~StrategyPplastic() {}<br/>
	double eval(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		assert(f&gt;=0.0);<br/>
		assert(v&gt;=0.0);<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const double E = mpParams-&gt;E;<br/>
		#ifndef __HACK_RIOGWIGUIGUOYG<br/>
		if (!((pow(f/C,B)/(1.0+pow(f/C,B))) * (pow(v/E,D)/(1.0+pow(v/E,D)))&gt;=0.0))<br/>
		{<br/>
		&nbsp;&nbsp;std::cout &lt;&lt; "ERROR: " &lt;&lt; std::endl<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "f: " &lt;&lt; f &lt;&lt; std::endl<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "v: " &lt;&lt; v &lt;&lt; std::endl<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "A: " &lt;&lt; A &lt;&lt; std::endl<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "B: " &lt;&lt; B &lt;&lt; std::endl<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "C: " &lt;&lt; C &lt;&lt; std::endl<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "D: " &lt;&lt; D &lt;&lt; std::endl<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "E: " &lt;&lt; E &lt;&lt; std::endl<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ((pow(f/C,B)/(1.0+pow(f/C,B))) * (pow(v/E,D)/(1.0+pow(v/E,D)))) <br/>
			&lt;&lt; std::endl;<br/>
		}<br/>
		#endif<br/>
		//Assert((pow(f/C,B)/(1.0+pow(f/C,B))) * (pow(v/E,D)/(1.0+pow(v/E,D)))&gt;=0.0);<br/>
		const double p = ( A==0.0 ? 0.5 : A*(sqrt((pow(f/C,B)/(1.0+pow(f/C,B))) * (pow(v/E,D)/(1.0+pow(v/E,D)))))+((1.0-A)*0.5));<br/>
		#ifndef __HACK_UYGEFOUYG<br/>
		if (!(p &gt;=-0.0001 &amp;&amp; p &lt;=1.0001)) std::cout &lt;&lt; "ERROR: p: " &lt;&lt; p &lt;&lt; std::endl;<br/>
		#endif<br/>
		assert(p &gt;=-0.0001 &amp;&amp; p &lt;=1.0001);<br/>
		return p;<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string pBegin = "P(f,v) = ";<br/>
		const std::string p1 = "A*(sqrt((pow(f/C,B)/(1.0+pow(f/C,B))) * (pow(v/E,D)/(1.0+pow(v/E,D)))))+((1.0-A)*0.5)";<br/>
		const std::string p = pBegin + p1;<br/>
		return p;<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const std::string pBegin = "P(f,v) = P("+ftoa(f)+","+ftoa(v)+") = ";<br/>
		const std::string p1 = "something";<br/>
		const std::string pOutcome = ftoa(eval(f,v));<br/>
		const std::string p = pBegin + p1 + " = " + pOutcome;<br/>
		return p;<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyPbase::testMe("Pplastic.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyPconstant : public StrategyPbase<br/>
{<br/>
	public:<br/>
	StrategyPconstant(const ParameterSetP * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
	}<br/>
	~StrategyPconstant() {}<br/>
	double eval(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		assert(f&gt;=0.0);<br/>
		assert(v&gt;=0.0);<br/>
		const double p = mpParams-&gt;A;<br/>
		assert(p &gt;=0.0 &amp;&amp; p &lt;=1.0);<br/>
		return p;<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string pBegin = "P(f,v) = ";<br/>
		const std::string p1 = "A";<br/>
		const std::string p = pBegin + p1;<br/>
		return p;<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; f, const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const std::string pBegin = "P(f,v) = P("+ftoa(f)+","+ftoa(v)+") = ";<br/>
		const std::string p1 = ftoa(A);<br/>
		const std::string pOutcome = ftoa(eval(f,v));<br/>
		const std::string p = pBegin +&nbsp;&nbsp;" = " + pOutcome;<br/>
		return p;<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyPbase::testMe("Pconstant.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
<br/>
#endif //#ifndef __STRATEGY_P_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyQ.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyQ.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyQ.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 31 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __STRATEGY_Q_H<br/>
#define __STRATEGY_Q_H<br/>
<br/>
<br/>
#include &lt;memory&gt;<br/>
#include &lt;math.h&gt;<br/>
#include "ParameterSets.h"<br/>
#include "HelperFunctions.h"<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyQbase<br/>
{<br/>
	public:<br/>
	StrategyQbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetQ);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyQbase() {}<br/>
	virtual double eval(const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual std::string getString(const double&amp;) const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		for (double v = 0.0; v&lt;10.0; v+=0.1)<br/>
		{<br/>
			fileOutput &lt;&lt;&nbsp;&nbsp;v &lt;&lt; " " &lt;&lt; eval(v) &lt;&lt; "\n";<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetQ&gt; mpParams;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyQdefault : public StrategyQbase<br/>
{<br/>
	public:<br/>
	StrategyQdefault(const ParameterSetQ * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B = pParams-&gt;B;<br/>
		mpParams-&gt;C = pParams-&gt;C;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0);<br/>
		assert(mpParams-&gt;C&gt;=0.0);<br/>
	}<br/>
	~StrategyQdefault() {}<br/>
	double eval(const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		//OLD: const double q = (exp(-A*v))*v;<br/>
		const double q = (A*v)/(1.0+(pow(v,B)*(C/A)));<br/>
		assert(q&gt;=0 &amp;&amp; q&lt;=v);<br/>
		return (q);<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string qBegin = "Q(v) = ";<br/>
		const std::string q = "(A.v)/(1.0+(pow(v,B).(C/A)))";<br/>
		return (qBegin + q);<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const std::string qBegin = "Q(v) = Q("+ftoa(v)+") = ";<br/>
		const std::string q = "(" + ftoa(A)+"." + ftoa(v)+")/(1.0+(pow(" + ftoa(v)+"," + ftoa(B)+").(" + ftoa(C)+"/" + ftoa(A)+")))";<br/>
		const std::string qOutcome = ftoa(eval(v));<br/>
		return (qBegin + q + " = " + qOutcome);<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyQbase::testMe("Qdefault.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyQconstant : public StrategyQbase<br/>
{<br/>
	public:<br/>
	StrategyQconstant(const ParameterSetQ * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		assert(mpParams-&gt;A&gt;=0.0 &amp;&amp; mpParams-&gt;A&lt;=1.0);<br/>
	}<br/>
	~StrategyQconstant() {}<br/>
	double eval(const double&amp; v) const<br/>
	{<br/>
		return (mpParams-&gt;A*v);<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string qBegin = "Q(v) = ";<br/>
		const std::string q = "A.v";<br/>
		return (qBegin + q);<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; v) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const std::string qBegin = "Q(v) = Q("+ftoa(v)+") = ";<br/>
		const std::string q = ftoa(A)+"*"+ftoa(v);<br/>
		const std::string qOutcome = ftoa(eval(v));<br/>
		return (qBegin + q + " = " + qOutcome);<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyQbase::testMe("Qconstant.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
#endif //#ifndef __STRATEGY_P_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyR.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyR.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyR.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Tue May 31 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __STRATEGY_R_H<br/>
#define __STRATEGY_R_H<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include &lt;memory&gt;<br/>
#include "ParameterSets.h"<br/>
#include "HelperFunctions.h"<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyRbase<br/>
{<br/>
	public:<br/>
	StrategyRbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetR);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyRbase() {}<br/>
	virtual double eval(const double&amp;, const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual std::string getString(const double&amp;, const double&amp;) const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		<br/>
		for (double x = 0.0; x&lt;10.0; x+=0.1)<br/>
		{<br/>
			for (double t = 0.0; t&lt;10.0; t+=0.1)<br/>
			{<br/>
				fileOutput &lt;&lt; x &lt;&lt; " " &lt;&lt; t &lt;&lt; " " &lt;&lt; eval(x,t) &lt;&lt; "\n";<br/>
			}<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetR&gt; mpParams;<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyRconstant : public StrategyRbase<br/>
{<br/>
	public:<br/>
	StrategyRconstant(const ParameterSetR * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B&nbsp;&nbsp;= pParams-&gt;B;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0 &amp;&amp; mpParams-&gt;B &lt;=1.0);<br/>
	}<br/>
	~StrategyRconstant() {}<br/>
	double eval(const double&amp; x, const double&amp; t) const<br/>
	{<br/>
		assert(x&gt;-0.001);<br/>
		assert(t&gt;=0.0);<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B&nbsp;&nbsp;= mpParams-&gt;B;<br/>
		const double inflow = A - (B*x);<br/>
		return (inflow);<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string rBegin = "R(x,t) = ";<br/>
		const std::string r = "A - (B*x)";<br/>
		return (rBegin + r);<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; x, const double&amp; t) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B&nbsp;&nbsp;= mpParams-&gt;B;<br/>
		<br/>
		const std::string rBegin = "R(x,t) = R("+ftoa(x)+","+ftoa(t)+") = ";<br/>
		const std::string r = ftoa(A)+"-("+ftoa(B)+"*"+ftoa(x)+")";<br/>
		const std::string rOutcome = ftoa(eval(x,t));<br/>
		return (rBegin + r + " = " + rOutcome);<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyRbase::testMe("Rconstant.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyRlogistic : public StrategyRbase<br/>
{<br/>
	public:<br/>
	StrategyRlogistic(const ParameterSetR * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B&nbsp;&nbsp;= pParams-&gt;B;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0);<br/>
	}<br/>
	~StrategyRlogistic() {}<br/>
	//Inflow can be negative<br/>
	double eval(const double&amp; x, const double&amp; t) const<br/>
	{<br/>
		double xCopy = x;<br/>
		if (x&gt;-0.001 &amp;&amp; x&lt;0.0) xCopy=0.0;<br/>
		assert(xCopy&gt;=0.0);<br/>
		assert(t&gt;=0.0);<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		//const double r = x + (A*x*(1.0-(B/x))); //NOT THIS ONE!!! R SHOULD BE INFLOW ONLY!<br/>
		const double r = (A*xCopy*(1.0-(x/B)));<br/>
		return (r);<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string rBegin = "R(x,t) = ";<br/>
		//const std::string r = "A*x*(1.0-(B/x))";<br/>
		const std::string r = "A*x*(1.0-(x/B))";<br/>
		return (rBegin + r);<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; x, const double&amp; t) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const std::string rBegin = "R(x,t) = R("+ftoa(x)+","+ftoa(t)+") = ";<br/>
		//const std::string r = ftoa(A)+"*"+ftoa(x)+"*(1.0-("+ftoa(B)+"/"+ftoa(x)+"))";<br/>
		const std::string r = ftoa(A)+"*"+ftoa(x)+"*(1.0-("+ftoa(x)+"/"+ftoa(B)+"))";<br/>
		const std::string rOutcome = ftoa(eval(x,t));<br/>
		return (rBegin + r + " = " + rOutcome);<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyRbase::testMe("Rlogistic.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyRcosine : public StrategyRbase<br/>
{<br/>
	public:<br/>
	StrategyRcosine(const ParameterSetR * pParams)<br/>
	{<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B = pParams-&gt;B;<br/>
		mpParams-&gt;C = pParams-&gt;C;<br/>
		mpParams-&gt;D = pParams-&gt;D;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0);<br/>
		assert(mpParams-&gt;C&gt;=0.0);<br/>
	}<br/>
	~StrategyRcosine() {}<br/>
	//Inflow can be negative<br/>
	double eval(const double&amp; x, const double&amp; t) const<br/>
	{<br/>
		assert(x&gt;=0.0);<br/>
		assert(t&gt;=0.0);<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const double r = A + (B*(cos( ((M_PI*2.0)/C)*t + D)));<br/>
		return (r);<br/>
	}<br/>
<br/>
	std::string getString() const<br/>
	{<br/>
		const std::string rBegin = "R(x,t) = ";<br/>
		const std::string r = "A+B*cos( (2pi/C)*t + D )";<br/>
		return (rBegin + r);<br/>
	}<br/>
<br/>
	std::string getString(const double&amp; x, const double&amp; t) const<br/>
	{<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const std::string rBegin = "R(x,t) = R("+ftoa(x)+","+ftoa(t)+") = ";<br/>
<br/>
		const std::string r = ftoa(A)+"+"+ftoa(B)+"*cos( (2pi/"+ftoa(C)+")*"+ftoa(t)+" + "+ftoa(D)+" )";<br/>
		const std::string rOutcome = ftoa(eval(x,t));<br/>
		return (rBegin + r + " = " + rOutcome);<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyRbase::testMe("Rcosine.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
#endif //#ifndef __STRATEGY_P_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/StrategyW.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/StrategyW.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;StrategyW.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Wed Jun 01 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
 <br/>
///Strategy W denotes the hunting success.<br/>
///Hunting success is dependent on size.<br/>
///This class needs as input a population size and a total amount of resources.<br/>
///The population size is extracted from a vector given by reference as input, with size equal to popSize.<br/>
<br/>
///StrategyWzero = everybody gets equal share<br/>
///StrategyWuniform = uniform deviation from equal share, size independent<br/>
///StrategyWsizeDependent = uniform deviation from size-dependent hunting success<br/>
<br/>
///01-08-2005: Changed:<br/>
///eval(size) returns r_i (==w_i)<br/>
///after every individual has its r_i calculated (==maximal amount of resources possible to eat),<br/>
///it has to be checked if SUM(r_i) is smaller or equal then the total amunt of resources, as the<br/>
///derived class StrategyWsizeDependent does NOT scale nicely.<br/>
<br/>
#ifndef __STRATEGY_W_H<br/>
#define __STRATEGY_W_H<br/>
<br/>
#include &lt;memory&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;assert.h&gt;<br/>
#include "ParameterSets.h"<br/>
#include "random.h"<br/>
#include "HelperFunctions.h"<br/>
<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyWbase<br/>
{<br/>
	public:<br/>
	StrategyWbase() <br/>
	{<br/>
		mpParams.reset(new ParameterSetW);<br/>
		assert(mpParams.get()!=NULL);<br/>
	}<br/>
	virtual ~StrategyWbase() {}<br/>
	//virtual void distributeResources(const double&amp;, std::vector&lt;double&gt;&amp;) = 0;<br/>
	virtual double eval(const double&amp;, const double&amp;) const = 0;<br/>
	virtual std::string getString() const = 0;<br/>
	virtual void testMe() const = 0;<br/>
	void testMe(const std::string&amp; filename) const<br/>
	{<br/>
		std::ofstream fileOutput(filename.c_str());<br/>
		assert(fileOutput.is_open()==true);<br/>
		<br/>
		for (double size = 0.0; size&lt;10.0; size+=0.1)<br/>
		{<br/>
			for (double equalShareResources = 0.0; equalShareResources&lt;10.0; equalShareResources+=0.1)<br/>
			{<br/>
				fileOutput &lt;&lt; size &lt;&lt; " " &lt;&lt; equalShareResources &lt;&lt; " " &lt;&lt; eval(size,equalShareResources) &lt;&lt; "\n";<br/>
			}<br/>
		}<br/>
		fileOutput.close();<br/>
	}	<br/>
<br/>
	protected:<br/>
	std::auto_ptr&lt;ParameterSetW&gt; mpParams;<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyWzero : public StrategyWbase<br/>
{<br/>
	public:<br/>
	StrategyWzero(const ParameterSetW * pParams)<br/>
	{<br/>
		//Nothing<br/>
	}<br/>
	~StrategyWzero() {}<br/>
	double eval(const double&amp; size, const double&amp; equalShareResources) const<br/>
	{<br/>
		return equalShareResources;<br/>
	}<br/>
	/*void distributeResources(const double&amp; totalResources, std::vector&lt;double&gt;&amp; vectorResources)<br/>
	{<br/>
		assert(totalResources&gt;=0.0);<br/>
		assert(vectorResources.size()!=0);<br/>
		const unsigned int popSize = vectorResources.size();<br/>
		const double resourcesShare = totalResources / static_cast&lt;double&gt;(popSize);<br/>
		assert(resourcesShare&gt;=0.0);<br/>
		for (unsigned int i=0; i&lt;popSize; ++i)<br/>
		{<br/>
			vectorResources[i] = resourcesShare;<br/>
		}<br/>
<br/>
<br/>
		#ifndef DEBUG_ZXC_GDF_635_ALPHA<br/>
		double sumResources = 0.0;<br/>
		for (unsigned int i=0; i&lt;popSize; ++i)<br/>
		{<br/>
			sumResources+=vectorResources[i];<br/>
			#ifdef EXTREME_LOGGING<br/>
			std::cout<br/>
				&lt;&lt; "Resources[" &lt;&lt; i <br/>
				&lt;&lt; "]: " &lt;&lt; vectorResources[i] &lt;&lt; std::endl;<br/>
			#endif<br/>
		}<br/>
		//std::cout &lt;&lt; "100.0+(1.0/1000.0): " &lt;&lt; 100.0+(1.0/1000.0) &lt;&lt; std::endl; <br/>
		#ifdef LOGGING_RESOURCE_ACCURACY<br/>
		std::cout &lt;&lt; "Resource accuracy: " &lt;&lt; 100.0*sumResources/totalResources &lt;&lt; "%" &lt;&lt; std::endl;<br/>
		#endif<br/>
		if (sumResources&lt;0.999*totalResources || sumResources&gt;1.001*totalResources)<br/>
		{<br/>
			assert(!"Kut!");<br/>
		}<br/>
		#endif<br/>
<br/>
	}*/<br/>
	std::string getString() const<br/>
	{<br/>
		return ("W: WZero, all individuals get equal share of food");<br/>
	}<br/>
<br/>
<br/>
	void testMe() const { StrategyWbase::testMe("Wzero.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
class StrategyWuniform : public StrategyWbase<br/>
{<br/>
	public:<br/>
	StrategyWuniform(const ParameterSetW * pParams)<br/>
	{<br/>
		assert(mpParams.get()!=NULL);<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B = pParams-&gt;B;<br/>
		mpParams-&gt;C = pParams-&gt;C;<br/>
		mpParams-&gt;D = pParams-&gt;D;<br/>
		assert(mpParams-&gt;A&gt;=0.0 &amp;&amp; mpParams-&gt;A&lt;=1.0);<br/>
	}<br/>
	~StrategyWuniform() {}<br/>
	double eval(const double&amp; size, const double&amp; equalShareResources) const<br/>
	{<br/>
		//01-08-2005: OLD: return equalShareResources * (1.0 + (2.0*mpParams-&gt;A * (uniform()-0.5)));<br/>
		//Only called when SoilMite is not an egg anymore<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const double r_i = (1.0+(A*(size-B)*(size-B))) * C * (1.0 + (2.0* D * (uniform()-0.5)));<br/>
		return r_i;<br/>
	}<br/>
<br/>
	/*void distributeResources(const double&amp; totalResources, std::vector&lt;double&gt;&amp; vectorResources)<br/>
	{<br/>
		assert(totalResources&gt;=0.0);<br/>
		assert(vectorResources.size()!=0);<br/>
		const unsigned int popSize = vectorResources.size();<br/>
		if (popSize==1) { vectorResources[0]=totalResources; return; }<br/>
		const double resourcesEqual = totalResources / static_cast&lt;double&gt;(popSize);<br/>
		assert(resourcesEqual&gt;=0.0);<br/>
		const double A = mpParams-&gt;A;<br/>
<br/>
		const double step = (2.0*A)/static_cast&lt;double&gt;(popSize-1);<br/>
<br/>
<br/>
		//for (unsigned int i=0,double fraction = mpParams-&gt;A; i&lt;popSize; ++i , fraction+=step)<br/>
		double fraction = 1.0-A;<br/>
		for (unsigned int i=0; i&lt;popSize; ++i)<br/>
		{<br/>
			vectorResources[i] = resourcesEqual*fraction;<br/>
			fraction+=step;<br/>
		}<br/>
<br/>
		random_shuffle(vectorResources.begin(), vectorResources.end());<br/>
<br/>
		#ifndef DEBUG_ZXC_GDF_635_ALPHA<br/>
		double sumResources = 0.0;<br/>
		for (unsigned int i=0; i&lt;popSize; ++i)<br/>
		{<br/>
			sumResources+=vectorResources[i];<br/>
			#ifdef EXTREME_LOGGING<br/>
			std::cout<br/>
				&lt;&lt; "Resources[" &lt;&lt; i <br/>
				&lt;&lt; "]: " &lt;&lt; vectorResources[i] &lt;&lt; std::endl;<br/>
			#endif<br/>
		}<br/>
		#ifdef LOGGING_RESOURCE_ACCURACY<br/>
		std::cout &lt;&lt; "Resource accuracy: " &lt;&lt; 100.0*sumResources/totalResources &lt;&lt; "%" &lt;&lt; std::endl;<br/>
		#endif<br/>
		if (sumResources&lt;0.999*totalResources || sumResources&gt;1.001*totalResources)<br/>
		{<br/>
			assert(!"Kut!");<br/>
		}<br/>
		#endif<br/>
<br/>
	}*/<br/>
	std::string getString() const<br/>
	{<br/>
		return ("W: WUniform: Resources are unequally distributed, from "<br/>
			+ftoa(1.0-mpParams-&gt;A)+" to "<br/>
			+ftoa(1.0+mpParams-&gt;A)+" the equal resource share."<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;+"\nr_i = (1.0+(A*(size-B)*(size-B))) * C * (1.0 + (2.0* D * (uniform()-0.5)))");<br/>
	}<br/>
	<br/>
	void testMe() const { StrategyWbase::testMe("Wuniform.rda"); }<br/>
<br/>
};<br/>
//----------------------------------------------------------------------------------<br/>
/*class StrategyWsizeDependent : public StrategyWbase<br/>
{<br/>
	public:<br/>
	StrategyWsizeDependent(const ParameterSetW * pParams)<br/>
	{<br/>
		assert(mpParams.get()!=NULL);<br/>
		mpParams-&gt;A = pParams-&gt;A;<br/>
		mpParams-&gt;B = pParams-&gt;B;<br/>
		mpParams-&gt;C = pParams-&gt;C;<br/>
		mpParams-&gt;D = pParams-&gt;D;<br/>
		assert(mpParams-&gt;A&gt;=0.0);<br/>
		assert(mpParams-&gt;B&gt;=0.0);<br/>
		assert(mpParams-&gt;C&gt;=0.0 &amp;&amp; mpParams-&gt;A&lt;=1.0);<br/>
		assert(mpParams-&gt;D&gt;=0.0 &amp;&amp; mpParams-&gt;A&lt;=1.0);<br/>
	}<br/>
	~StrategyWsizeDependent() {}<br/>
	double eval(const double&amp; size, const double&amp; equalShareResources) const<br/>
	{<br/>
		//Only called when SoilMite is not an egg anymore<br/>
		const double A = mpParams-&gt;A;<br/>
		const double B = mpParams-&gt;B;<br/>
		const double C = mpParams-&gt;C;<br/>
		const double D = mpParams-&gt;D;<br/>
		const double r_i = (1.0+(A*(size-B)*(size-B))) * C * (1.0 + (2.0* D * (uniform()-0.5)));<br/>
		return r_i;<br/>
	}*/<br/>
<br/>
	/*void distributeResources(const double&amp; totalResources, std::vector&lt;double&gt;&amp; vectorResources)<br/>
	{<br/>
		assert(totalResources&gt;=0.0);<br/>
		assert(vectorResources.size()!=0);<br/>
		const unsigned int popSize = vectorResources.size();<br/>
		if (popSize==1) { vectorResources[0]=totalResources; return; }<br/>
		const double resourcesEqual = totalResources / static_cast&lt;double&gt;(popSize);<br/>
		assert(resourcesEqual&gt;=0.0);<br/>
		const double A = mpParams-&gt;A;<br/>
<br/>
		const double step = (2.0*A)/static_cast&lt;double&gt;(popSize-1);<br/>
<br/>
<br/>
		//for (unsigned int i=0,double fraction = mpParams-&gt;A; i&lt;popSize; ++i , fraction+=step)<br/>
		double fraction = 1.0-A;<br/>
		for (unsigned int i=0; i&lt;popSize; ++i)<br/>
		{<br/>
			vectorResources[i] = resourcesEqual*fraction;<br/>
			fraction+=step;<br/>
		}<br/>
<br/>
		random_shuffle(vectorResources.begin(), vectorResources.end());<br/>
<br/>
		#ifndef DEBUG_ZXC_GDF_635_ALPHA<br/>
		double sumResources = 0.0;<br/>
		for (unsigned int i=0; i&lt;popSize; ++i)<br/>
		{<br/>
			sumResources+=vectorResources[i];<br/>
			#ifdef EXTREME_LOGGING<br/>
			std::cout<br/>
				&lt;&lt; "Resources[" &lt;&lt; i <br/>
				&lt;&lt; "]: " &lt;&lt; vectorResources[i] &lt;&lt; std::endl;<br/>
			#endif<br/>
		}<br/>
		#ifdef LOGGING_RESOURCE_ACCURACY<br/>
		std::cout &lt;&lt; "Resource accuracy: " &lt;&lt; 100.0*sumResources/totalResources &lt;&lt; "%" &lt;&lt; std::endl;<br/>
		#endif<br/>
		if (sumResources&lt;0.999*totalResources || sumResources&gt;1.001*totalResources)<br/>
		{<br/>
			assert(!"Kut!");<br/>
		}<br/>
		#endif<br/>
<br/>
	}*/<br/>
/*<br/>
	std::string getString() const<br/>
	{<br/>
		return ("W: WsizeDependent: Resources are unequally distributed dependent on size:"<br/>
		"\nr_i = (1.0+(A*(size-B)*(size-B))) * C * (1.0 + (2.0* D * (uniform()-0.5)))"<br/>
		+ "\nA: " + ftoa(mpParams-&gt;A) <br/>
		+ "\nB: " + ftoa(mpParams-&gt;B) <br/>
		+ "\nC: " + ftoa(mpParams-&gt;C) <br/>
		+ "\nD: " + ftoa(mpParams-&gt;D)<br/>
		);&nbsp;&nbsp;<br/>
		<br/>
	}<br/>
};*/<br/>
//----------------------------------------------------------------------------------<br/>
<br/>
#endif //#ifndef __STRATEGY_SIMGA_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Test.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Test.cpp" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Test.cpp<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Robert Payne on Thu Jun 09 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 __MyCompanyName__. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#include "Test.h"<br/>
//----------------------------------------------------------------------------------<br/>
void testGnuPlot3D()<br/>
{<br/>
	const int nPoints = 10;<br/>
	std::vector&lt;double&gt; x,y,z;<br/>
	<br/>
	for (int i=0; i&lt;nPoints; ++i)<br/>
	{<br/>
		const double xD = static_cast&lt;double&gt;(i); <br/>
		for(int j=0; j&lt;nPoints; ++j)<br/>
		{<br/>
			const double yD = static_cast&lt;double&gt;(j); <br/>
			const double zD = cos(xD)+sin(yD);<br/>
			x.push_back(xD);<br/>
			y.push_back(yD);<br/>
			z.push_back(zD);<br/>
			std::cout &lt;&lt; xD &lt;&lt; '\t' &lt;&lt; yD &lt;&lt; '\t' &lt;&lt; zD &lt;&lt; std::endl;<br/>
		}<br/>
	}<br/>
<br/>
	Gnuplot myPlot;<br/>
	//myPlot.cmd("set terminal x11");<br/>
	//myPlot.cmd("set terminal aqua");<br/>
<br/>
	//myPlot.cmd("set pm3d");<br/>
	//myPlot.cmd("set palette color mode RGB");<br/>
	//myPlot.set_style("lines");<br/>
	<br/>
	myPlot.plot(x,y,z,"Test");<br/>
	sleep(5);<br/>
	std::cout &lt;&lt; "Testing done. Press key to quit\n";<br/>
	std::string nothing; std::cin &gt;&gt; nothing;<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void testGnuPlotWindows()<br/>
{<br/>
	Gnuplot myPlot;<br/>
	for (unsigned int i=0; i&lt;10; ++i)<br/>
	{<br/>
		setSeed(i);<br/>
		myPlot.changeWindow(i);<br/>
		std::vector&lt;double&gt; data1(1000);<br/>
		std::vector&lt;double&gt; data2(1000);<br/>
		const double iD = static_cast&lt;double&gt;(i);<br/>
		for (unsigned int j=0; j&lt;1000; ++j)<br/>
		{<br/>
			const double jD = static_cast&lt;double&gt;(j);<br/>
			data1[j]= cos(jD/(2.0+iD));<br/>
			data2[j]= sin(jD/(3.0+iD));<br/>
			//data1[j]= uniform();// + cos(static_cast&lt;double&gt;(j)/10.0);<br/>
			//data2[j]= uniform();// * cos(static_cast&lt;double&gt;(j)/20.0);<br/>
		}<br/>
		myPlot.plot(data1);<br/>
		myPlot.plot(data2);<br/>
	}<br/>
	<br/>
	/*Gnuplot myPlot1, myPlot2;<br/>
	const unsigned int datasetSize = 100;<br/>
	std::vector&lt;double&gt;dataset(datasetSize);<br/>
	for(unsigned int i=0; i&lt;datasetSize; ++i)<br/>
	{<br/>
		const double iD = static_cast&lt;double&gt;(i);<br/>
		dataset[i] = cos(iD/10.0);<br/>
	}<br/>
	myPlot1.execute("set terminal aqua 1");<br/>
	myPlot1.plot(dataset);<br/>
	sleep(1);<br/>
<br/>
	for(unsigned int i=0; i&lt;datasetSize; ++i)<br/>
	{<br/>
		const double iD = static_cast&lt;double&gt;(i);<br/>
		dataset[i]=0.01*iD*sin(iD/100.0);<br/>
	}<br/>
<br/>
	myPlot2.execute("set terminal aqua 2");<br/>
	myPlot2.plot(dataset);<br/>
	sleep(1);*/<br/>
	<br/>
	<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
void demoGnuplot()<br/>
{<br/>
	Gnuplot myPlot;<br/>
<br/>
	std::vector&lt;double&gt; data1(1000);<br/>
	std::vector&lt;double&gt; data2(1000);<br/>
	for (unsigned int j=0; j&lt;1000; ++j)<br/>
	{<br/>
		const double jD = static_cast&lt;double&gt;(j);<br/>
		data1[j]= sin(jD/100.0);<br/>
		data2[j]= sin(jD/100.0);<br/>
	}<br/>
<br/>
	for (unsigned int i=0; i&lt;10; ++i)<br/>
	{<br/>
		setSeed(i);<br/>
		myPlot.changeWindow(i);<br/>
		const double iD = static_cast&lt;double&gt;(i);<br/>
		for (unsigned int j=0; j&lt;1000; ++j)<br/>
		{<br/>
			const double jD = static_cast&lt;double&gt;(j);<br/>
			data1[j]*= sin(jD/(20.0-iD));<br/>
			data2[j]*= sin(jD/(21.0-iD));<br/>
		}<br/>
		myPlot.plot(data1);<br/>
		myPlot.plot(data2);<br/>
	}<br/>
}<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
//----------------------------------------------------------------------------------<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/Test.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/Test.h" border = "1"><tr><td><code>
/*<br/>
 *&nbsp;&nbsp;Test.h<br/>
 *&nbsp;&nbsp;Sim4<br/>
 *<br/>
 *&nbsp;&nbsp;Created by Richel Bilderbeek on Thu Jun 09 2005.<br/>
 *&nbsp;&nbsp;Copyright (c) 2005 Richel Bilderbeek. All rights reserved.<br/>
 *<br/>
 */<br/>
<br/>
#ifndef __TEST_H<br/>
#define __TEST_H<br/>
<br/>
#include &lt;iostream&gt;<br/>
#include "gnuplot.h"<br/>
#include "random.h"<br/>
<br/>
void testGnuPlot3D();<br/>
void testGnuPlotWindows();<br/>
void demoGnuplot();<br/>
<br/>
<br/>
<br/>
#endif<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./ProjectBristol/testScript.txt</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./ProjectBristol/testScript.txt" border = "1"><tr><td><code>
./Sim4<br/>
usf 0<br/>
#<br/>
setplotting off<br/>
settext off<br/>
#<br/>
usf all<br/>
setsimtime 1000<br/>
#<br/>
setd 0<br/>
setdconsta 0.2<br/>
setdconstb 2.0<br/>
setdconstc 5.0<br/>
setdconstd 0.2<br/>
#<br/>
setf 0<br/>
setfconsta 1<br/>
#<br/>
setg 0<br/>
setgconsta 0.0<br/>
#<br/>
setm 1<br/>
setmconsta 0.05<br/>
#<br/>
setn 0<br/>
setnconsta 0.0<br/>
setnconstb 1.0<br/>
setnconstc 0.1<br/>
setnconstd 1.5<br/>
setnconste 15.0<br/>
#<br/>
setp 1<br/>
setpconsta 1.0<br/>
setpconstb 1.0<br/>
setpconstc 0.1<br/>
setpconstd 2.0 <br/>
setpconsta 2.0<br/>
#<br/>
setq 1<br/>
setqconsta 1.0<br/>
setqconstb 0<br/>
setqconstc 10.0<br/>
#<br/>
setr 0<br/>
setrconsta 100<br/>
setrconstb 0.001<br/>
#<br/>
setw 1<br/>
setwconsta 0.0<br/>
setwconstb 5,0<br/>
setwconstc 0.1<br/>
setwconstd 0.5<br/>
 <br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
