<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <title>OpenFoam</title>
  <meta name="description" content="C++ OpenFoam"/>
  <meta name="keywords" content="C++ OpenFoam "/>
  <link rel="stylesheet" href="Richelbilderbeek.css" type="text/css"/>
</head>
<!-- End of head, start of body -->
<body>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- Page header -->
<h1>(<a href="Cpp.htm">C++</a>) <a href="CppOpenFoam.htm">OpenFoam</a></h1>
<p>&nbsp;</p>
<h2>./CppOpenFoam/blockMeshDict_1x1x1</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/blockMeshDict_1x1x1" border = "1"><tr><td><code>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dictionary;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMeshDict;<br/>
}<br/>
<br/>
//The unit of the vertices is 1.0 meter<br/>
convertToMeters 1.0;<br/>
<br/>
//A cube with the following vertex indices:<br/>
//<br/>
//&nbsp;&nbsp; 7-----6<br/>
//&nbsp;&nbsp;/|&nbsp;&nbsp;&nbsp;&nbsp;/|<br/>
// 4-----5 |<br/>
// | |&nbsp;&nbsp; | |<br/>
// | 3---|-2<br/>
// |/&nbsp;&nbsp;&nbsp;&nbsp;|/<br/>
// 0-----1<br/>
//<br/>
//Each vertex is of the form (x y z)<br/>
//<br/>
//The local coordinate system is defined by the order in which the vertices are presented in the block definition according to:<br/>
//- the axis origin is the first entry in the block definition, vertex 0 in our example;<br/>
//- the x direction is described by moving from vertex 0 to vertex 1;<br/>
//- the y direction is described by moving from vertex 1 to vertex 2;<br/>
//- vertices 0, 1, 2, 3 define the plane z<br/>
//- vertex 4 is found by moving from vertex 0 in the z direction;<br/>
//- vertices 5,6 and 7 are similarly found by moving in the z direction from vertices 1,2 and 3<br/>
vertices<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 1)<br/>
);<br/>
<br/>
//Ordered list of vertex labels and mesh size<br/>
blocks<br/>
(<br/>
&nbsp;&nbsp;hex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The shape is always hex, as blocks are always hexahedra<br/>
&nbsp;&nbsp;(0 1 2 3 4 5 6 7)&nbsp;&nbsp;&nbsp;&nbsp; // vertex numbers <br/>
&nbsp;&nbsp;(1 1 1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// numbers of cells in each direction <br/>
&nbsp;&nbsp;simpleGrading (1 1 1) // cell expansion ratios <br/>
);<br/>
<br/>
//Used to describe arc or spline edges <br/>
//Keyword selection | Description&nbsp;&nbsp;&nbsp;&nbsp;| Additional entries <br/>
//- arc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Circular arc&nbsp;&nbsp; | Single interpolation point<br/>
//- simpleSpline&nbsp;&nbsp;&nbsp;&nbsp;| Spline curve&nbsp;&nbsp; | List of interpolation points<br/>
//- polyLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of lines&nbsp;&nbsp; | List of interpolation points<br/>
//- polySpline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of splines | List of interpolation points<br/>
//- line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Straight line&nbsp;&nbsp;| <br/>
edges<br/>
(<br/>
);<br/>
<br/>
//List of patches <br/>
//Do not uncomment this 'patches' part:<br/>
//it will result in a 'undefined faces' warning<br/>
//patches<br/>
//(<br/>
&nbsp;&nbsp;//Possible values are:<br/>
&nbsp;&nbsp;//- symmetryPlane<br/>
&nbsp;&nbsp;//- patch<br/>
//);<br/>
<br/>
boundary<br/>
(<br/>
&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 3 2 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 4 7 3)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 5 4 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2 6 5 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3 7 6 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4 5 6 7)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
);<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/blockMeshDict_1x1x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/blockMeshDict_1x1x2" border = "1"><tr><td><code>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dictionary;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMeshDict;<br/>
}<br/>
<br/>
//The unit of the vertices is 1.0 meter<br/>
convertToMeters 1.0;<br/>
<br/>
//A cube with the following vertex indices:<br/>
//<br/>
//&nbsp;&nbsp; 7-----6<br/>
//&nbsp;&nbsp;/|&nbsp;&nbsp;&nbsp;&nbsp;/|<br/>
// 4-----5 |<br/>
// | |&nbsp;&nbsp; | |<br/>
// | 3---|-2<br/>
// |/&nbsp;&nbsp;&nbsp;&nbsp;|/<br/>
// 0-----1<br/>
//<br/>
//Each vertex is of the form (x y z)<br/>
//<br/>
//The local coordinate system is defined by the order in which the vertices are presented in the block definition according to:<br/>
//- the axis origin is the first entry in the block definition, vertex 0 in our example;<br/>
//- the x direction is described by moving from vertex 0 to vertex 1;<br/>
//- the y direction is described by moving from vertex 1 to vertex 2;<br/>
//- vertices 0, 1, 2, 3 define the plane z<br/>
//- vertex 4 is found by moving from vertex 0 in the z direction;<br/>
//- vertices 5,6 and 7 are similarly found by moving in the z direction from vertices 1,2 and 3<br/>
vertices<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 1)<br/>
);<br/>
<br/>
//Ordered list of vertex labels and mesh size<br/>
blocks<br/>
(<br/>
&nbsp;&nbsp;hex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The shape is always hex, as blocks are always hexahedra<br/>
&nbsp;&nbsp;(0 1 2 3 4 5 6 7)&nbsp;&nbsp;&nbsp;&nbsp; // vertex numbers <br/>
&nbsp;&nbsp;(1 1 2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// numbers of cells in each direction <br/>
&nbsp;&nbsp;simpleGrading (1 1 1) // cell expansion ratios <br/>
);<br/>
<br/>
//Used to describe arc or spline edges <br/>
//Keyword selection | Description&nbsp;&nbsp;&nbsp;&nbsp;| Additional entries <br/>
//- arc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Circular arc&nbsp;&nbsp; | Single interpolation point<br/>
//- simpleSpline&nbsp;&nbsp;&nbsp;&nbsp;| Spline curve&nbsp;&nbsp; | List of interpolation points<br/>
//- polyLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of lines&nbsp;&nbsp; | List of interpolation points<br/>
//- polySpline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of splines | List of interpolation points<br/>
//- line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Straight line&nbsp;&nbsp;| <br/>
edges<br/>
(<br/>
);<br/>
<br/>
//List of patches <br/>
//Do not uncomment this 'patches' part:<br/>
//it will result in a 'undefined faces' warning<br/>
//patches<br/>
//(<br/>
&nbsp;&nbsp;//Possible values are:<br/>
&nbsp;&nbsp;//- symmetryPlane<br/>
&nbsp;&nbsp;//- patch<br/>
//);<br/>
<br/>
boundary<br/>
(<br/>
&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 3 2 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 4 7 3)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 5 4 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2 6 5 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3 7 6 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4 5 6 7)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
);<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/blockMeshDict_1x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/blockMeshDict_1x2x2" border = "1"><tr><td><code>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dictionary;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMeshDict;<br/>
}<br/>
<br/>
//The unit of the vertices is 1.0 meter<br/>
convertToMeters 1.0;<br/>
<br/>
//A cube with the following vertex indices:<br/>
//<br/>
//&nbsp;&nbsp; 7-----6<br/>
//&nbsp;&nbsp;/|&nbsp;&nbsp;&nbsp;&nbsp;/|<br/>
// 4-----5 |<br/>
// | |&nbsp;&nbsp; | |<br/>
// | 3---|-2<br/>
// |/&nbsp;&nbsp;&nbsp;&nbsp;|/<br/>
// 0-----1<br/>
//<br/>
//Each vertex is of the form (x y z)<br/>
//<br/>
//The local coordinate system is defined by the order in which the vertices are presented in the block definition according to:<br/>
//- the axis origin is the first entry in the block definition, vertex 0 in our example;<br/>
//- the x direction is described by moving from vertex 0 to vertex 1;<br/>
//- the y direction is described by moving from vertex 1 to vertex 2;<br/>
//- vertices 0, 1, 2, 3 define the plane z<br/>
//- vertex 4 is found by moving from vertex 0 in the z direction;<br/>
//- vertices 5,6 and 7 are similarly found by moving in the z direction from vertices 1,2 and 3<br/>
vertices<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 1)<br/>
);<br/>
<br/>
//Ordered list of vertex labels and mesh size<br/>
blocks<br/>
(<br/>
&nbsp;&nbsp;hex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The shape is always hex, as blocks are always hexahedra<br/>
&nbsp;&nbsp;(0 1 2 3 4 5 6 7)&nbsp;&nbsp;&nbsp;&nbsp; // vertex numbers <br/>
&nbsp;&nbsp;(1 2 2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// numbers of cells in each direction<br/>
&nbsp;&nbsp;simpleGrading (1 1 1) // cell expansion ratios<br/>
);<br/>
<br/>
//Used to describe arc or spline edges <br/>
//Keyword selection | Description&nbsp;&nbsp;&nbsp;&nbsp;| Additional entries <br/>
//- arc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Circular arc&nbsp;&nbsp; | Single interpolation point<br/>
//- simpleSpline&nbsp;&nbsp;&nbsp;&nbsp;| Spline curve&nbsp;&nbsp; | List of interpolation points<br/>
//- polyLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of lines&nbsp;&nbsp; | List of interpolation points<br/>
//- polySpline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of splines | List of interpolation points<br/>
//- line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Straight line&nbsp;&nbsp;| <br/>
edges<br/>
(<br/>
);<br/>
<br/>
//List of patches <br/>
//Do not uncomment this 'patches' part:<br/>
//it will result in a 'undefined faces' warning<br/>
//patches<br/>
//(<br/>
&nbsp;&nbsp;//Possible values are:<br/>
&nbsp;&nbsp;//- symmetryPlane<br/>
&nbsp;&nbsp;//- patch<br/>
//);<br/>
<br/>
boundary<br/>
(<br/>
&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 3 2 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 4 7 3)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 5 4 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2 6 5 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3 7 6 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4 5 6 7)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
);<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/blockMeshDict_2x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/blockMeshDict_2x2x2" border = "1"><tr><td><code>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dictionary;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMeshDict;<br/>
}<br/>
<br/>
//The unit of the vertices is 1.0 meter<br/>
convertToMeters 1.0;<br/>
<br/>
//A cube with the following vertex indices:<br/>
//<br/>
//&nbsp;&nbsp; 7-----6<br/>
//&nbsp;&nbsp;/|&nbsp;&nbsp;&nbsp;&nbsp;/|<br/>
// 4-----5 |<br/>
// | |&nbsp;&nbsp; | |<br/>
// | 3---|-2<br/>
// |/&nbsp;&nbsp;&nbsp;&nbsp;|/<br/>
// 0-----1<br/>
//<br/>
//Each vertex is of the form (x y z)<br/>
//<br/>
//The local coordinate system is defined by the order in which the vertices are presented in the block definition according to:<br/>
//- the axis origin is the first entry in the block definition, vertex 0 in our example;<br/>
//- the x direction is described by moving from vertex 0 to vertex 1;<br/>
//- the y direction is described by moving from vertex 1 to vertex 2;<br/>
//- vertices 0, 1, 2, 3 define the plane z<br/>
//- vertex 4 is found by moving from vertex 0 in the z direction;<br/>
//- vertices 5,6 and 7 are similarly found by moving in the z direction from vertices 1,2 and 3<br/>
vertices<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 1)<br/>
);<br/>
<br/>
//Ordered list of vertex labels and mesh size<br/>
blocks<br/>
(<br/>
&nbsp;&nbsp;hex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The shape is always hex, as blocks are always hexahedra<br/>
&nbsp;&nbsp;(0 1 2 3 4 5 6 7)&nbsp;&nbsp;&nbsp;&nbsp; // vertex numbers <br/>
&nbsp;&nbsp;(2 2 2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// numbers of cells in each direction <br/>
&nbsp;&nbsp;simpleGrading (1 1 1) // cell expansion ratios <br/>
);<br/>
<br/>
//Used to describe arc or spline edges <br/>
//Keyword selection | Description&nbsp;&nbsp;&nbsp;&nbsp;| Additional entries <br/>
//- arc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Circular arc&nbsp;&nbsp; | Single interpolation point<br/>
//- simpleSpline&nbsp;&nbsp;&nbsp;&nbsp;| Spline curve&nbsp;&nbsp; | List of interpolation points<br/>
//- polyLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of lines&nbsp;&nbsp; | List of interpolation points<br/>
//- polySpline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of splines | List of interpolation points<br/>
//- line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Straight line&nbsp;&nbsp;| <br/>
edges<br/>
(<br/>
);<br/>
<br/>
//List of patches <br/>
//Do not uncomment this 'patches' part:<br/>
//it will result in a 'undefined faces' warning<br/>
//patches<br/>
//(<br/>
&nbsp;&nbsp;//Possible values are:<br/>
&nbsp;&nbsp;//- symmetryPlane<br/>
&nbsp;&nbsp;//- patch<br/>
//);<br/>
<br/>
boundary<br/>
(<br/>
&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 3 2 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 4 7 3)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 5 4 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2 6 5 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3 7 6 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4 5 6 7)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
);<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/blockMeshDict_3x4x5</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/blockMeshDict_3x4x5" border = "1"><tr><td><code>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dictionary;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMeshDict;<br/>
}<br/>
<br/>
//The unit of the vertices is 1.0 meter<br/>
convertToMeters 1.0;<br/>
<br/>
//A cube with the following vertex indices:<br/>
//<br/>
//&nbsp;&nbsp; 7-----6<br/>
//&nbsp;&nbsp;/|&nbsp;&nbsp;&nbsp;&nbsp;/|<br/>
// 4-----5 |<br/>
// | |&nbsp;&nbsp; | |<br/>
// | 3---|-2<br/>
// |/&nbsp;&nbsp;&nbsp;&nbsp;|/<br/>
// 0-----1<br/>
//<br/>
//Each vertex is of the form (x y z)<br/>
//<br/>
//The local coordinate system is defined by the order in which the vertices are presented in the block definition according to:<br/>
//- the axis origin is the first entry in the block definition, vertex 0 in our example;<br/>
//- the x direction is described by moving from vertex 0 to vertex 1;<br/>
//- the y direction is described by moving from vertex 1 to vertex 2;<br/>
//- vertices 0, 1, 2, 3 define the plane z<br/>
//- vertex 4 is found by moving from vertex 0 in the z direction;<br/>
//- vertices 5,6 and 7 are similarly found by moving in the z direction from vertices 1,2 and 3<br/>
vertices<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 0 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(1 1 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(0 1 1)<br/>
);<br/>
<br/>
//Ordered list of vertex labels and mesh size<br/>
blocks<br/>
(<br/>
&nbsp;&nbsp;hex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The shape is always hex, as blocks are always hexahedra<br/>
&nbsp;&nbsp;(0 1 2 3 4 5 6 7)&nbsp;&nbsp;&nbsp;&nbsp; // vertex numbers <br/>
&nbsp;&nbsp;(3 4 5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// numbers of cells in each direction <br/>
&nbsp;&nbsp;simpleGrading (1 1 1) // cell expansion ratios <br/>
);<br/>
<br/>
//Used to describe arc or spline edges <br/>
//Keyword selection | Description&nbsp;&nbsp;&nbsp;&nbsp;| Additional entries <br/>
//- arc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Circular arc&nbsp;&nbsp; | Single interpolation point<br/>
//- simpleSpline&nbsp;&nbsp;&nbsp;&nbsp;| Spline curve&nbsp;&nbsp; | List of interpolation points<br/>
//- polyLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of lines&nbsp;&nbsp; | List of interpolation points<br/>
//- polySpline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Set of splines | List of interpolation points<br/>
//- line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Straight line&nbsp;&nbsp;| <br/>
edges<br/>
(<br/>
);<br/>
<br/>
//List of patches <br/>
//Do not uncomment this 'patches' part:<br/>
//it will result in a 'undefined faces' warning<br/>
//patches<br/>
//(<br/>
&nbsp;&nbsp;//Possible values are:<br/>
&nbsp;&nbsp;//- symmetryPlane<br/>
&nbsp;&nbsp;//- patch<br/>
//);<br/>
<br/>
boundary<br/>
(<br/>
&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 3 2 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0 4 7 3)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1 5 4 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2 6 5 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3 7 6 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4 5 6 7)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
);<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/boundary_1x1x1</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/boundary_1x1x1" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyBoundaryMesh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
6<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
)<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/boundary_1x1x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/boundary_1x1x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyBoundaryMesh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
6<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
)<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/boundary_1x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/boundary_1x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyBoundaryMesh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
6<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
)<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/boundary_2x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/boundary_2x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyBoundaryMesh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
6<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 28;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
)<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/boundary_3x4x5</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/boundary_3x4x5" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; polyBoundaryMesh;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
6<br/>
(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_bottom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 133;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_left<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 145;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_front<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 165;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 180;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_back<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;my_cube_top<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 215;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
)<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/CppOpenFoam.qrc</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/CppOpenFoam.qrc" border = "1"><tr><td><code>
&lt;RCC&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;qresource prefix="/CppOpenFoam/files"&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;blockMeshDict_1x1x1&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;blockMeshDict_1x1x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;blockMeshDict_1x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;blockMeshDict_2x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;boundary_1x1x1&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;boundary_1x1x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;boundary_1x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;boundary_2x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;faces_1x1x1&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;faces_1x1x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;faces_1x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;faces_2x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;neighbour_1x1x1&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;neighbour_1x1x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;neighbour_1x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;neighbour_2x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;owner_1x1x1&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;owner_1x1x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;owner_1x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;owner_2x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;points_1x1x1&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;points_1x1x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;points_1x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;points_2x2x2&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;blockMeshDict_3x4x5&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;boundary_3x4x5&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;faces_3x4x5&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;neighbour_3x4x5&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;owner_3x4x5&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;file&gt;points_3x4x5&lt;/file&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/qresource&gt;<br/>
&lt;/RCC&gt;<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/faces_1x1x1</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/faces_1x1x1" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; faceList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faces;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
6<br/>
(<br/>
4(0 2 3 1)<br/>
4(0 4 6 2)<br/>
4(0 1 5 4)<br/>
4(1 3 7 5)<br/>
4(2 6 7 3)<br/>
4(4 5 7 6)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/faces_1x1x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/faces_1x1x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; faceList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faces;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
11<br/>
(<br/>
4(4 5 7 6)<br/>
4(0 2 3 1)<br/>
4(0 4 6 2)<br/>
4(4 8 10 6)<br/>
4(0 1 5 4)<br/>
4(4 5 9 8)<br/>
4(1 3 7 5)<br/>
4(5 7 11 9)<br/>
4(2 6 7 3)<br/>
4(6 10 11 7)<br/>
4(8 9 11 10)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/faces_1x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/faces_1x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; faceList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faces;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
20<br/>
(<br/>
4(2 8 9 3)<br/>
4(6 7 9 8)<br/>
4(8 9 11 10)<br/>
4(8 14 15 9)<br/>
4(0 2 3 1)<br/>
4(2 4 5 3)<br/>
4(0 6 8 2)<br/>
4(2 8 10 4)<br/>
4(6 12 14 8)<br/>
4(8 14 16 10)<br/>
4(0 1 7 6)<br/>
4(6 7 13 12)<br/>
4(1 3 9 7)<br/>
4(3 5 11 9)<br/>
4(7 9 15 13)<br/>
4(9 11 17 15)<br/>
4(4 10 11 5)<br/>
4(10 16 17 11)<br/>
4(12 13 15 14)<br/>
4(14 15 17 16)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/faces_2x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/faces_2x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; faceList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faces;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
36<br/>
(<br/>
4(1 4 13 10)<br/>
4(3 12 13 4)<br/>
4(9 10 13 12)<br/>
4(4 13 14 5)<br/>
4(10 11 14 13)<br/>
4(4 7 16 13)<br/>
4(12 13 16 15)<br/>
4(13 14 17 16)<br/>
4(10 13 22 19)<br/>
4(12 21 22 13)<br/>
4(13 22 23 14)<br/>
4(13 16 25 22)<br/>
4(0 3 4 1)<br/>
4(3 6 7 4)<br/>
4(1 4 5 2)<br/>
4(4 7 8 5)<br/>
4(0 9 12 3)<br/>
4(3 12 15 6)<br/>
4(9 18 21 12)<br/>
4(12 21 24 15)<br/>
4(0 1 10 9)<br/>
4(9 10 19 18)<br/>
4(1 2 11 10)<br/>
4(10 11 20 19)<br/>
4(2 5 14 11)<br/>
4(5 8 17 14)<br/>
4(11 14 23 20)<br/>
4(14 17 26 23)<br/>
4(6 15 16 7)<br/>
4(15 24 25 16)<br/>
4(7 16 17 8)<br/>
4(16 25 26 17)<br/>
4(18 19 22 21)<br/>
4(21 22 25 24)<br/>
4(19 20 23 22)<br/>
4(22 23 26 25)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/faces_3x4x5</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/faces_3x4x5" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; faceList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faces;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
227<br/>
(<br/>
4(1 5 25 21)<br/>
4(4 24 25 5)<br/>
4(20 21 25 24)<br/>
4(2 6 26 22)<br/>
4(5 25 26 6)<br/>
4(21 22 26 25)<br/>
4(6 26 27 7)<br/>
4(22 23 27 26)<br/>
4(5 9 29 25)<br/>
4(8 28 29 9)<br/>
4(24 25 29 28)<br/>
4(6 10 30 26)<br/>
4(9 29 30 10)<br/>
4(25 26 30 29)<br/>
4(10 30 31 11)<br/>
4(26 27 31 30)<br/>
4(9 13 33 29)<br/>
4(12 32 33 13)<br/>
4(28 29 33 32)<br/>
4(10 14 34 30)<br/>
4(13 33 34 14)<br/>
4(29 30 34 33)<br/>
4(14 34 35 15)<br/>
4(30 31 35 34)<br/>
4(13 17 37 33)<br/>
4(32 33 37 36)<br/>
4(14 18 38 34)<br/>
4(33 34 38 37)<br/>
4(34 35 39 38)<br/>
4(21 25 45 41)<br/>
4(24 44 45 25)<br/>
4(40 41 45 44)<br/>
4(22 26 46 42)<br/>
4(25 45 46 26)<br/>
4(41 42 46 45)<br/>
4(26 46 47 27)<br/>
4(42 43 47 46)<br/>
4(25 29 49 45)<br/>
4(28 48 49 29)<br/>
4(44 45 49 48)<br/>
4(26 30 50 46)<br/>
4(29 49 50 30)<br/>
4(45 46 50 49)<br/>
4(30 50 51 31)<br/>
4(46 47 51 50)<br/>
4(29 33 53 49)<br/>
4(32 52 53 33)<br/>
4(48 49 53 52)<br/>
4(30 34 54 50)<br/>
4(33 53 54 34)<br/>
4(49 50 54 53)<br/>
4(34 54 55 35)<br/>
4(50 51 55 54)<br/>
4(33 37 57 53)<br/>
4(52 53 57 56)<br/>
4(34 38 58 54)<br/>
4(53 54 58 57)<br/>
4(54 55 59 58)<br/>
4(41 45 65 61)<br/>
4(44 64 65 45)<br/>
4(60 61 65 64)<br/>
4(42 46 66 62)<br/>
4(45 65 66 46)<br/>
4(61 62 66 65)<br/>
4(46 66 67 47)<br/>
4(62 63 67 66)<br/>
4(45 49 69 65)<br/>
4(48 68 69 49)<br/>
4(64 65 69 68)<br/>
4(46 50 70 66)<br/>
4(49 69 70 50)<br/>
4(65 66 70 69)<br/>
4(50 70 71 51)<br/>
4(66 67 71 70)<br/>
4(49 53 73 69)<br/>
4(52 72 73 53)<br/>
4(68 69 73 72)<br/>
4(50 54 74 70)<br/>
4(53 73 74 54)<br/>
4(69 70 74 73)<br/>
4(54 74 75 55)<br/>
4(70 71 75 74)<br/>
4(53 57 77 73)<br/>
4(72 73 77 76)<br/>
4(54 58 78 74)<br/>
4(73 74 78 77)<br/>
4(74 75 79 78)<br/>
4(61 65 85 81)<br/>
4(64 84 85 65)<br/>
4(80 81 85 84)<br/>
4(62 66 86 82)<br/>
4(65 85 86 66)<br/>
4(81 82 86 85)<br/>
4(66 86 87 67)<br/>
4(82 83 87 86)<br/>
4(65 69 89 85)<br/>
4(68 88 89 69)<br/>
4(84 85 89 88)<br/>
4(66 70 90 86)<br/>
4(69 89 90 70)<br/>
4(85 86 90 89)<br/>
4(70 90 91 71)<br/>
4(86 87 91 90)<br/>
4(69 73 93 89)<br/>
4(72 92 93 73)<br/>
4(88 89 93 92)<br/>
4(70 74 94 90)<br/>
4(73 93 94 74)<br/>
4(89 90 94 93)<br/>
4(74 94 95 75)<br/>
4(90 91 95 94)<br/>
4(73 77 97 93)<br/>
4(92 93 97 96)<br/>
4(74 78 98 94)<br/>
4(93 94 98 97)<br/>
4(94 95 99 98)<br/>
4(81 85 105 101)<br/>
4(84 104 105 85)<br/>
4(82 86 106 102)<br/>
4(85 105 106 86)<br/>
4(86 106 107 87)<br/>
4(85 89 109 105)<br/>
4(88 108 109 89)<br/>
4(86 90 110 106)<br/>
4(89 109 110 90)<br/>
4(90 110 111 91)<br/>
4(89 93 113 109)<br/>
4(92 112 113 93)<br/>
4(90 94 114 110)<br/>
4(93 113 114 94)<br/>
4(94 114 115 95)<br/>
4(93 97 117 113)<br/>
4(94 98 118 114)<br/>
4(0 4 5 1)<br/>
4(4 8 9 5)<br/>
4(8 12 13 9)<br/>
4(12 16 17 13)<br/>
4(1 5 6 2)<br/>
4(5 9 10 6)<br/>
4(9 13 14 10)<br/>
4(13 17 18 14)<br/>
4(2 6 7 3)<br/>
4(6 10 11 7)<br/>
4(10 14 15 11)<br/>
4(14 18 19 15)<br/>
4(0 20 24 4)<br/>
4(4 24 28 8)<br/>
4(8 28 32 12)<br/>
4(12 32 36 16)<br/>
4(20 40 44 24)<br/>
4(24 44 48 28)<br/>
4(28 48 52 32)<br/>
4(32 52 56 36)<br/>
4(40 60 64 44)<br/>
4(44 64 68 48)<br/>
4(48 68 72 52)<br/>
4(52 72 76 56)<br/>
4(60 80 84 64)<br/>
4(64 84 88 68)<br/>
4(68 88 92 72)<br/>
4(72 92 96 76)<br/>
4(80 100 104 84)<br/>
4(84 104 108 88)<br/>
4(88 108 112 92)<br/>
4(92 112 116 96)<br/>
4(0 1 21 20)<br/>
4(20 21 41 40)<br/>
4(40 41 61 60)<br/>
4(60 61 81 80)<br/>
4(80 81 101 100)<br/>
4(1 2 22 21)<br/>
4(21 22 42 41)<br/>
4(41 42 62 61)<br/>
4(61 62 82 81)<br/>
4(81 82 102 101)<br/>
4(2 3 23 22)<br/>
4(22 23 43 42)<br/>
4(42 43 63 62)<br/>
4(62 63 83 82)<br/>
4(82 83 103 102)<br/>
4(3 7 27 23)<br/>
4(7 11 31 27)<br/>
4(11 15 35 31)<br/>
4(15 19 39 35)<br/>
4(23 27 47 43)<br/>
4(27 31 51 47)<br/>
4(31 35 55 51)<br/>
4(35 39 59 55)<br/>
4(43 47 67 63)<br/>
4(47 51 71 67)<br/>
4(51 55 75 71)<br/>
4(55 59 79 75)<br/>
4(63 67 87 83)<br/>
4(67 71 91 87)<br/>
4(71 75 95 91)<br/>
4(75 79 99 95)<br/>
4(83 87 107 103)<br/>
4(87 91 111 107)<br/>
4(91 95 115 111)<br/>
4(95 99 119 115)<br/>
4(16 36 37 17)<br/>
4(36 56 57 37)<br/>
4(56 76 77 57)<br/>
4(76 96 97 77)<br/>
4(96 116 117 97)<br/>
4(17 37 38 18)<br/>
4(37 57 58 38)<br/>
4(57 77 78 58)<br/>
4(77 97 98 78)<br/>
4(97 117 118 98)<br/>
4(18 38 39 19)<br/>
4(38 58 59 39)<br/>
4(58 78 79 59)<br/>
4(78 98 99 79)<br/>
4(98 118 119 99)<br/>
4(100 101 105 104)<br/>
4(104 105 109 108)<br/>
4(108 109 113 112)<br/>
4(112 113 117 116)<br/>
4(101 102 106 105)<br/>
4(105 106 110 109)<br/>
4(109 110 114 113)<br/>
4(113 114 118 117)<br/>
4(102 103 107 106)<br/>
4(106 107 111 110)<br/>
4(110 111 115 114)<br/>
4(114 115 119 118)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/neighbour_1x1x1</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/neighbour_1x1x1" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 8 nCells: 1 nFaces: 6 nInternalFaces: 0";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbour;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
0()<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/neighbour_1x1x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/neighbour_1x1x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 12 nCells: 2 nFaces: 11 nInternalFaces: 1";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbour;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
1(1)<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/neighbour_1x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/neighbour_1x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 18 nCells: 4 nFaces: 20 nInternalFaces: 4";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbour;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
4(1 2 3 3)<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/neighbour_2x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/neighbour_2x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 27 nCells: 8 nFaces: 36 nInternalFaces: 12";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbour;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
12<br/>
(<br/>
1<br/>
2<br/>
4<br/>
3<br/>
5<br/>
3<br/>
6<br/>
7<br/>
5<br/>
6<br/>
7<br/>
7<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/neighbour_3x4x5</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/neighbour_3x4x5" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 120 nCells: 60 nFaces: 227 nInternalFaces: 133";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbour;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
133<br/>
(<br/>
1<br/>
3<br/>
12<br/>
2<br/>
4<br/>
13<br/>
5<br/>
14<br/>
4<br/>
6<br/>
15<br/>
5<br/>
7<br/>
16<br/>
8<br/>
17<br/>
7<br/>
9<br/>
18<br/>
8<br/>
10<br/>
19<br/>
11<br/>
20<br/>
10<br/>
21<br/>
11<br/>
22<br/>
23<br/>
13<br/>
15<br/>
24<br/>
14<br/>
16<br/>
25<br/>
17<br/>
26<br/>
16<br/>
18<br/>
27<br/>
17<br/>
19<br/>
28<br/>
20<br/>
29<br/>
19<br/>
21<br/>
30<br/>
20<br/>
22<br/>
31<br/>
23<br/>
32<br/>
22<br/>
33<br/>
23<br/>
34<br/>
35<br/>
25<br/>
27<br/>
36<br/>
26<br/>
28<br/>
37<br/>
29<br/>
38<br/>
28<br/>
30<br/>
39<br/>
29<br/>
31<br/>
40<br/>
32<br/>
41<br/>
31<br/>
33<br/>
42<br/>
32<br/>
34<br/>
43<br/>
35<br/>
44<br/>
34<br/>
45<br/>
35<br/>
46<br/>
47<br/>
37<br/>
39<br/>
48<br/>
38<br/>
40<br/>
49<br/>
41<br/>
50<br/>
40<br/>
42<br/>
51<br/>
41<br/>
43<br/>
52<br/>
44<br/>
53<br/>
43<br/>
45<br/>
54<br/>
44<br/>
46<br/>
55<br/>
47<br/>
56<br/>
46<br/>
57<br/>
47<br/>
58<br/>
59<br/>
49<br/>
51<br/>
50<br/>
52<br/>
53<br/>
52<br/>
54<br/>
53<br/>
55<br/>
56<br/>
55<br/>
57<br/>
56<br/>
58<br/>
59<br/>
58<br/>
59<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamboundary.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamboundary.cpp" border = "1"><tr><td><code>
#include "openfoamboundary.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;ostream&gt;<br/>
<br/>
#include "trace.h"<br/>
#include "openfoamface.h"<br/>
<br/>
ribi::foam::Boundary::Boundary(<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt; &gt;&amp; faces,<br/>
&nbsp;&nbsp;const std::string&amp; name,<br/>
&nbsp;&nbsp;const std::string&amp; type<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_faces(faces),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_name(name),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_type(type)<br/>
{<br/>
<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;const ribi::foam::Face&gt; &gt; ribi::foam::Boundary::GetFaces() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;const ribi::foam::Face&gt;&gt; v;<br/>
&nbsp;&nbsp;std::transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(v),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](const boost::shared_ptr&lt;Face&gt; face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const ribi::foam::Face&gt; const_face {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;face<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face == const_face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return const_face;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(v.size() == m_faces.size());<br/>
&nbsp;&nbsp;//Only check first and last<br/>
&nbsp;&nbsp;assert(v.empty() || v[0] == m_faces[0]);<br/>
&nbsp;&nbsp;assert(v.empty() || v[ v.size() - 1 ] == m_faces[ v.size() - 1 ]);<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const ribi::foam::Boundary&amp; boundary)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; boundary.m_name &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; boundary.m_type &lt;&lt; '\n';<br/>
&nbsp;&nbsp;for (const boost::shared_ptr&lt;Face&gt; face: boundary.m_faces)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; *face &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamboundary.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamboundary.h" border = "1"><tr><td><code>
#ifndef OPENFOAMBOUNDARY_H<br/>
#define OPENFOAMBOUNDARY_H<br/>
<br/>
#include &lt;vector&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#include "openfoamfwd.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///A Boundary contains Faces that form a surface boundary<br/>
struct Boundary<br/>
{<br/>
&nbsp;&nbsp;Boundary(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt; &gt;&amp; faces,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; type<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Face&gt; &gt;&amp; GetFaces() noexcept { return m_faces; }<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const Face&gt; &gt;&nbsp;&nbsp;GetFaces() const noexcept;<br/>
&nbsp;&nbsp;const std::string&amp; GetName() const noexcept { return m_name; }<br/>
&nbsp;&nbsp;const std::string&amp; GetType() const noexcept { return m_type; }<br/>
<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt; &gt; m_faces;<br/>
&nbsp;&nbsp;const std::string m_name;<br/>
&nbsp;&nbsp;const std::string m_type;<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Boundary&amp; boundary);<br/>
};<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Boundary&amp; boundary);<br/>
<br/>
} //namespace foam<br/>
} //namespace ribi<br/>
<br/>
#endif // OPENFOAMBOUNDARY_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamboundaryfile.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamboundaryfile.cpp" border = "1"><tr><td><code>
#include "openfoamboundaryfile.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<br/>
#include &lt;boost/algorithm/string/trim.hpp&gt;<br/>
#include &lt;boost/algorithm/string/split.hpp&gt;<br/>
#include &lt;boost/lexical_cast.hpp&gt;<br/>
<br/>
#include &lt;QFile&gt;<br/>
<br/>
#include "filename.h"<br/>
#include "fileio.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoamboundaryindex.h"<br/>
#include "openfoamboundaryfileitem.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
<br/>
ribi::foam::BoundaryFile::BoundaryFile(<br/>
&nbsp;&nbsp;const Header header,<br/>
&nbsp;&nbsp;const std::vector&lt;BoundaryFileItem&gt;&amp; items)<br/>
&nbsp;&nbsp;: m_header{header},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items(items)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
bool ribi::foam::BoundaryFile::CanGet(const FaceIndex&amp; face_index) const noexcept<br/>
{<br/>
&nbsp;&nbsp;for (const BoundaryFileItem&amp; item: m_items)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int i = face_index.Get();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int min = item.GetStartFace().Get();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int max = min + item.GetNfaces();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (i &gt;= min &amp;&amp; i &lt; max) return true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return false;<br/>
}<br/>
<br/>
ribi::foam::BoundaryFileItem&amp; ribi::foam::BoundaryFile::Find(const FaceIndex&amp; face_index) noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(CanGet(face_index));<br/>
&nbsp;&nbsp;const int sz = static_cast&lt;int&gt;(m_items.size());<br/>
&nbsp;&nbsp;for (int i=0; i!=sz; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int j = face_index.Get();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int min = m_items[i].GetStartFace().Get();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int max = min + m_items[i].GetNfaces();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (j &gt;= min &amp;&amp; j &lt; max) return m_items[i];<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!"Should not get here");<br/>
&nbsp;&nbsp;throw std::logic_error("ribi::foam::BoundaryFile::Find");<br/>
}<br/>
<br/>
const ribi::foam::Header ribi::foam::BoundaryFile::GetDefaultHeader() noexcept<br/>
{<br/>
&nbsp;&nbsp;const std::string class_name = "polyBoundaryMesh";<br/>
&nbsp;&nbsp;const std::string location&nbsp;&nbsp; = "constant" + fileio::GetPathSeperator() + "polyMesh";<br/>
&nbsp;&nbsp;const std::string note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = "";<br/>
&nbsp;&nbsp;const std::string object&nbsp;&nbsp;&nbsp;&nbsp; = "boundary";<br/>
<br/>
&nbsp;&nbsp;return Header(class_name,location,note,object);<br/>
}<br/>
<br/>
const ribi::foam::BoundaryFileItem ribi::foam::BoundaryFile::GetItem(const ribi::foam::BoundaryIndex&amp; boundary_index) const noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(boundary_index.Get() &gt;= 0);<br/>
&nbsp;&nbsp;assert(boundary_index &lt; GetMaxBoundaryIndex());<br/>
&nbsp;&nbsp;return m_items[ boundary_index.Get() ];<br/>
}<br/>
<br/>
const ribi::foam::BoundaryIndex ribi::foam::BoundaryFile::GetMaxBoundaryIndex() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return BoundaryIndex(static_cast&lt;int&gt;(m_items.size()));<br/>
}<br/>
<br/>
const ribi::foam::BoundaryFile ribi::foam::BoundaryFile::Parse(std::istream&amp; is)<br/>
{<br/>
&nbsp;&nbsp;BoundaryFile b;<br/>
&nbsp;&nbsp;is &gt;&gt; b;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return b;<br/>
}<br/>
<br/>
const ribi::foam::BoundaryFile ribi::foam::BoundaryFile::Parse(const std::string&amp; filename)<br/>
{<br/>
&nbsp;&nbsp;const std::string tmp_filename { fileio::GetTempFileName() };<br/>
&nbsp;&nbsp;fileio::CopyFile(filename,tmp_filename);<br/>
&nbsp;&nbsp;Header::CleanFile(tmp_filename);<br/>
&nbsp;&nbsp;std::ifstream f(tmp_filename.c_str());<br/>
&nbsp;&nbsp;const ribi::foam::BoundaryFile file { Parse(f) };<br/>
&nbsp;&nbsp;f.close();<br/>
&nbsp;&nbsp;fileio::DeleteFile(tmp_filename);<br/>
&nbsp;&nbsp;return file;<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::BoundaryFile::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::BoundaryFile::Test");<br/>
&nbsp;&nbsp;//Some initial data<br/>
&nbsp;&nbsp;const Header header("some_name","some_location","some_object");<br/>
&nbsp;&nbsp;std::vector&lt;BoundaryFileItem&gt; items;<br/>
&nbsp;&nbsp;for (int i=1; i!=4; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string name = "some_name" + boost::lexical_cast&lt;std::string&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string type = "some_type" + boost::lexical_cast&lt;std::string&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_faces = i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex start_face(i * i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoundaryFileItem item(name,type,n_faces,start_face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;items.push_back(item);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator==<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFile c(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header == header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header other_header("some_other_name","some_other_location","some_other_object");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header != other_header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFile c(other_header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;BoundaryFileItem&gt; other_items;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=1; i!=3; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string name = "some_other_name" + boost::lexical_cast&lt;std::string&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string type = "some_other_type" + boost::lexical_cast&lt;std::string&gt;(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int n_faces = i + 123;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex start_face((i * i) + 456);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundaryFileItem item(name,type,n_faces,start_face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFile c(header,other_items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Stream conversion<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoundaryFile c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (b != c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Read from testing file<br/>
&nbsp;&nbsp;for (int test_index = 0; test_index!=5; ++test_index)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;switch (test_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: filename_appendix = "_1x1x1"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: filename_appendix = "_1x1x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: filename_appendix = "_1x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: filename_appendix = "_2x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: filename_appendix = "_3x4x5"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Should never get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("foam::Files::CreateTestFiles: unknown test index");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!filename_appendix.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename_base { GetDefaultHeader().GetObject() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename = filename_base + filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string resources_path { ":/CppOpenFoam/files/" + filename };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QFile f( resources_path.c_str() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.copy(filename.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!fileio::IsRegularFile(filename))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(fileio::IsRegularFile(filename));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundaryFile b(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (b.GetItems().empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert( (!b.GetItems().empty() || b.GetItems().empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "If a mesh has no non-boundary cells, neighbour can be empty");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::Header::BoundaryFile successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const BoundaryFile&amp; lhs,const BoundaryFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;if (lhs.GetHeader() != rhs.GetHeader())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Headers differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(lhs.GetHeader());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(rhs.GetHeader());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const std::vector&lt;BoundaryFileItem&gt;&amp; lhs_items = lhs.GetItems();<br/>
&nbsp;&nbsp;const std::vector&lt;BoundaryFileItem&gt;&amp; rhs_items = rhs.GetItems();<br/>
&nbsp;&nbsp;if (lhs_items.size() != rhs_items.size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Number of items differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(lhs_items.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(rhs_items.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const bool all_items_equal {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::equal(lhs_items.begin(),lhs_items.end(),rhs_items.begin())<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;//if (!all_items_equal)<br/>
&nbsp;&nbsp;//{<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;TRACE("Items differ:");<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;TRACE(all_items_equal);<br/>
&nbsp;&nbsp;//}<br/>
&nbsp;&nbsp;return all_items_equal;<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const BoundaryFile&amp; lhs,const BoundaryFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, BoundaryFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;assert(f.m_items.empty()); //Make empty otherwise<br/>
<br/>
&nbsp;&nbsp;//Read header<br/>
&nbsp;&nbsp;is &gt;&gt; f.m_header;<br/>
&nbsp;&nbsp;assert(is);<br/>
<br/>
&nbsp;&nbsp;//Read items<br/>
&nbsp;&nbsp;int n_items = 0;<br/>
&nbsp;&nbsp;char opening_bracket = '\0';<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Eat comment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char c = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (c &gt;= '0' &amp;&amp; c &lt;= '9')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (c != '(' &amp;&amp; c != '{')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Start eating n_items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items *= 10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int n = c - '0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(n &gt;= 0 &amp;&amp; n &lt;= 9);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items += n;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;opening_bracket = c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(opening_bracket == '(' || opening_bracket == '{'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(opening_bracket);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;if (opening_bracket == '(')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundaryFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '{');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Read once, push n_items times<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BoundaryFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Eat comments until bracket close<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_close = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (bracket_close != ')' &amp;&amp; bracket_close != '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_close == ')' || bracket_close == '}');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (opening_bracket == '(' &amp;&amp; bracket_close == ')')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (opening_bracket == '{' &amp;&amp; bracket_close == '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const BoundaryFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.GetHeader() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.m_items.size() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "(" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;for(const BoundaryFileItem item: f.m_items)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; item &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ")" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamboundaryfile.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamboundaryfile.h" border = "1"><tr><td><code>
#ifndef OPENFOAMBOUNDARYFILE_H<br/>
#define OPENFOAMBOUNDARYFILE_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "fileiofwd.h"<br/>
#include "openfoamfwd.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoamboundaryfileitem.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///Reads and writes an OpenFOAM boundary file<br/>
struct BoundaryFile<br/>
{<br/>
&nbsp;&nbsp;///Read an OpenFOAM 'boundary' file.<br/>
&nbsp;&nbsp;///Throws std::runtime_error if file is incorrectly formed<br/>
&nbsp;&nbsp;explicit BoundaryFile(const std::string&amp; filename) : BoundaryFile(Parse(filename)) {}<br/>
&nbsp;&nbsp;explicit BoundaryFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header header = GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;BoundaryFileItem&gt;&amp; items = {});<br/>
<br/>
<br/>
&nbsp;&nbsp;static const Header GetDefaultHeader() noexcept;<br/>
&nbsp;&nbsp;const Header&amp; GetHeader() const noexcept { return m_header; }<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;BoundaryFileItem&gt; GetItems() const noexcept { return m_items; }<br/>
<br/>
&nbsp;&nbsp;const BoundaryFileItem GetItem(const BoundaryIndex&amp; boundary_index) const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the number of boundaries, the size of m_items, or the first boundary index not available<br/>
&nbsp;&nbsp;const BoundaryIndex GetMaxBoundaryIndex() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Is the Face belonging to a Boundary?<br/>
&nbsp;&nbsp;///(if not, it belongs to a Cell)<br/>
&nbsp;&nbsp;bool IsBoundary(const FaceIndex&amp; face_index) const noexcept { return CanGet(face_index); }<br/>
<br/>
&nbsp;&nbsp;///Swap the face indices between<br/>
&nbsp;&nbsp;//void Swap(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///Read an OpenFOAM 'boundary' file.<br/>
&nbsp;&nbsp;///Throws std::runtime_error if file is incorrectly formed<br/>
&nbsp;&nbsp;explicit BoundaryFile(std::istream&amp; is) : BoundaryFile(Parse(is)) {}<br/>
<br/>
&nbsp;&nbsp;///The OpenFOAM header<br/>
&nbsp;&nbsp;Header m_header;<br/>
&nbsp;&nbsp;///The items boundary contains<br/>
&nbsp;&nbsp;std::vector&lt;BoundaryFileItem&gt; m_items;<br/>
<br/>
&nbsp;&nbsp;///Is the FaceIndex present among the current items?<br/>
&nbsp;&nbsp;bool CanGet(const FaceIndex&amp; face_index) const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Find out which BoundaryFileItem the face belongs to<br/>
&nbsp;&nbsp;///Assumes CanGet(face_index) == true<br/>
&nbsp;&nbsp;BoundaryFileItem&amp; Find(const FaceIndex&amp; face_index) noexcept;<br/>
<br/>
<br/>
&nbsp;&nbsp;///Read an OpenFOAM 'boundary' file.<br/>
&nbsp;&nbsp;///Throws std::runtime_error if file is incorrectly formed<br/>
&nbsp;&nbsp;static const BoundaryFile Parse(std::istream&amp; is);<br/>
<br/>
&nbsp;&nbsp;static const BoundaryFile Parse(const std::string&amp; filename);<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const BoundaryFile&amp; f);<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, BoundaryFile&amp; f);<br/>
};<br/>
<br/>
bool operator==(const BoundaryFile&amp; lhs,const BoundaryFile&amp; rhs);<br/>
bool operator!=(const BoundaryFile&amp; lhs,const BoundaryFile&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const BoundaryFile&amp; f);<br/>
<br/>
///Read an OpenFOAM 'boundary' file.<br/>
///Throws std::runtime_error if file is incorrectly formed<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, BoundaryFile&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMBOUNDARYFILE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamboundaryfileitem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamboundaryfileitem.cpp" border = "1"><tr><td><code>
#include "openfoamboundaryfileitem.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::BoundaryFileItem::BoundaryFileItem(<br/>
&nbsp;&nbsp;const std::string&amp; name,<br/>
&nbsp;&nbsp;const std::string&amp; type,<br/>
&nbsp;&nbsp;const int n_faces,<br/>
&nbsp;&nbsp;const FaceIndex n_start_face<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_n_faces{n_faces},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_name{name},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_start_face{n_start_face},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_type{type}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(m_n_faces &gt;= 0);<br/>
&nbsp;&nbsp;assert(m_start_face.Get() &gt;= 0);<br/>
}<br/>
<br/>
const ribi::foam::FaceIndex ribi::foam::BoundaryFileItem::GetEndFace() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return m_start_face + FaceIndex(m_n_faces);<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::BoundaryFileItem::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::BoundaryFileItem::Test");<br/>
&nbsp;&nbsp;const BoundaryFileItem i("some_name","some_type",123,FaceIndex(456));<br/>
&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;s &lt;&lt; i;<br/>
&nbsp;&nbsp;BoundaryFileItem j;<br/>
&nbsp;&nbsp;s &gt;&gt; j;<br/>
&nbsp;&nbsp;if (i != j)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(j);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(i == j);<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::BoundaryFileItem::Test successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const BoundaryFileItem&amp; lhs, const BoundaryFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetName() == rhs.GetName()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; lhs.GetNfaces() == rhs.GetNfaces()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; lhs.GetStartFace() == rhs.GetStartFace()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; lhs.GetType() == rhs.GetType()<br/>
&nbsp;&nbsp;;<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const BoundaryFileItem&amp; lhs, const BoundaryFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const BoundaryFileItem&amp; item)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;" &lt;&lt; item.GetName() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;{" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;type " &lt;&lt; item.GetType() &lt;&lt; ";\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;nFaces " &lt;&lt; item.GetNfaces() &lt;&lt; ";\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;&nbsp;&nbsp;startFace " &lt;&lt; item.GetStartFace() &lt;&lt; ";\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;}" &lt;&lt; '\n';<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, BoundaryFileItem&amp; f)<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; f.m_name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string bracket_open;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_open;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_open == std::string("{"));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string type_text;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; type_text;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(type_text == std::string("type"));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; f.m_type;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f.m_type.back() == ';');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f.m_type.pop_back();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f.m_type.back() != ';');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string n_faces_text;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; n_faces_text;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(n_faces_text == std::string("nFaces"));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; f.m_n_faces;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string semicolon;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; semicolon;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (semicolon != std::string(";"))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(semicolon);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(semicolon == std::string(";"));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string start_face_text;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; start_face_text;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (start_face_text != std::string("startFace"))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(start_face_text);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(start_face_text == std::string("startFace"));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; f.m_start_face;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string semicolon;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; semicolon;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(semicolon == std::string(";"));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_close == std::string("}"));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamboundaryfileitem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamboundaryfileitem.h" border = "1"><tr><td><code>
#ifndef OPENFOAMBOUNDARYFILEITEM_H<br/>
#define OPENFOAMBOUNDARYFILEITEM_H<br/>
<br/>
#include &lt;string&gt;<br/>
#include &lt;iosfwd&gt;<br/>
<br/>
#include "openfoamfaceindex.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///An item in an OpenFOAM boundary file<br/>
struct BoundaryFileItem<br/>
{<br/>
&nbsp;&nbsp;explicit BoundaryFileItem(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; name = "",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; type = "",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_faces = 0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex n_start_face = FaceIndex(0)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const std::string&amp; GetName() const noexcept { return m_name; }<br/>
&nbsp;&nbsp;int GetNfaces() const noexcept { return m_n_faces; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the first Face its index<br/>
&nbsp;&nbsp;const FaceIndex GetStartFace() const noexcept { return m_start_face; }<br/>
<br/>
&nbsp;&nbsp;///Obtain the last+1 Face index<br/>
&nbsp;&nbsp;const FaceIndex GetEndFace() const noexcept;<br/>
<br/>
&nbsp;&nbsp;const std::string GetType() const noexcept { return m_type; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;int m_n_faces;<br/>
&nbsp;&nbsp;std::string m_name;<br/>
&nbsp;&nbsp;FaceIndex m_start_face;<br/>
&nbsp;&nbsp;std::string m_type;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend class OpenFoamBoundaryFile;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, BoundaryFileItem&amp; f);<br/>
};<br/>
<br/>
bool operator==(const BoundaryFileItem&amp; lhs, const BoundaryFileItem&amp; rhs);<br/>
bool operator!=(const BoundaryFileItem&amp; lhs, const BoundaryFileItem&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const BoundaryFileItem&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, BoundaryFileItem&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
<br/>
#endif // OPENFOAMBOUNDARYFILEITEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamboundaryindex.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamboundaryindex.cpp" border = "1"><tr><td><code>
#include "openfoamboundaryindex.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::BoundaryIndex::BoundaryIndex(const int index)<br/>
&nbsp;&nbsp;: m_index(index)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;if (m_index &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(m_index);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(m_index &gt;= 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A BoundaryIndex must be zero or a positive value");<br/>
&nbsp;&nbsp;if (m_index &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::invalid_argument("A BoundaryIndex must be zero or a positive value");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
ribi::foam::BoundaryIndex&amp; ribi::foam::BoundaryIndex::operator-=(const BoundaryIndex&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;m_index -= rhs.Get();<br/>
<br/>
&nbsp;&nbsp;assert(m_index &gt;= 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A BoundaryIndex must be zero or a positive value");<br/>
&nbsp;&nbsp;if (m_index &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::invalid_argument(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"BoundaryIndex::operator-=: BoundaryIndex cannot be negative");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return *this;<br/>
}<br/>
<br/>
ribi::foam::BoundaryIndex&amp; ribi::foam::BoundaryIndex::operator++() noexcept<br/>
{<br/>
&nbsp;&nbsp;++m_index;<br/>
&nbsp;&nbsp;return *this;<br/>
}<br/>
<br/>
ribi::foam::BoundaryIndex ribi::foam::BoundaryIndex::operator++(int) noexcept<br/>
{<br/>
&nbsp;&nbsp;BoundaryIndex old(*this);<br/>
&nbsp;&nbsp;++(*this);<br/>
&nbsp;&nbsp;return old;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const BoundaryIndex&amp; face_index) noexcept<br/>
{<br/>
&nbsp;&nbsp;os &lt;&lt; face_index.Get();<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, BoundaryIndex&amp; face_index) noexcept<br/>
{<br/>
&nbsp;&nbsp;is &gt;&gt; face_index.m_index;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
const ribi::foam::BoundaryIndex ribi::foam::operator+(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return BoundaryIndex(lhs.Get() + rhs.Get());<br/>
}<br/>
<br/>
const ribi::foam::BoundaryIndex ribi::foam::operator-(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return BoundaryIndex(lhs.Get() - rhs.Get());<br/>
}<br/>
<br/>
bool ribi::foam::operator==(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() == rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
bool ribi::foam::operator&lt;(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() &lt; rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator&gt;(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() &gt; rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator&gt;=(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs &lt; rhs);<br/>
}<br/>
<br/>
bool ribi::foam::operator&lt;=(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs &gt; rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamboundaryindex.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamboundaryindex.h" border = "1"><tr><td><code>
#ifndef OPENFOAMBOUNDARYINDEX_H<br/>
#define OPENFOAMBOUNDARYINDEX_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
struct BoundaryIndex<br/>
{<br/>
&nbsp;&nbsp;///Throws std::invalid_argument if the index is invalid<br/>
&nbsp;&nbsp;explicit BoundaryIndex(const int index);<br/>
&nbsp;&nbsp;int Get() const noexcept { return m_index; }<br/>
<br/>
&nbsp;&nbsp;///Throws std::invalid_argument if the new index is invalid<br/>
&nbsp;&nbsp;BoundaryIndex&amp; operator-=(const BoundaryIndex&amp; rhs);<br/>
&nbsp;&nbsp;BoundaryIndex&amp; operator++() noexcept;&nbsp;&nbsp; //Prefix<br/>
&nbsp;&nbsp;BoundaryIndex operator++(int) noexcept; //Postfix<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;int m_index;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, BoundaryIndex&amp; face_index) noexcept;<br/>
};<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const BoundaryIndex&amp; face_index) noexcept;<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, BoundaryIndex&amp; face_index) noexcept;<br/>
<br/>
const BoundaryIndex operator+(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept;<br/>
const BoundaryIndex operator-(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs);<br/>
<br/>
bool operator==(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept;<br/>
bool operator!=(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept;<br/>
bool operator&lt;(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept;<br/>
bool operator&gt;(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept;<br/>
bool operator&gt;=(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept;<br/>
bool operator&lt;=(const BoundaryIndex&amp; lhs, const BoundaryIndex&amp; rhs) noexcept;<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMBOUNDARYINDEX_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamcell.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamcell.cpp" border = "1"><tr><td><code>
#include "openfoamcell.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;ostream&gt;<br/>
<br/>
#include "openfoamface.h"<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::Cell::Cell(<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; owned_faces,<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; all_faces<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_all_faces{all_faces},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owned_faces{owned_faces}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;for (const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; face: m_owned_faces)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(std::count(m_all_faces.begin(),m_all_faces.end(),face) == 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "m_owned_faces must be a subset of m_all_faces");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
void ribi::foam::Cell::AssignOwnedFaces(const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;&amp; owned_faces)<br/>
{<br/>
&nbsp;&nbsp;assert(m_owned_faces.empty() &amp;&amp; "owned faces can only be assigned once");<br/>
&nbsp;&nbsp;assert(!owned_faces.empty());<br/>
&nbsp;&nbsp;m_owned_faces = owned_faces;<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;const ribi::foam::Face&gt; &gt; ribi::foam::Cell::GetOwnedFaces() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;const ribi::foam::Face&gt;&gt; v;<br/>
&nbsp;&nbsp;std::transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owned_faces.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owned_faces.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(v),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](const boost::shared_ptr&lt;Face&gt; face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const ribi::foam::Face&gt; const_face {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;face<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face == const_face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return const_face;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(v.size() == m_owned_faces.size());<br/>
&nbsp;&nbsp;//Only check first and last<br/>
&nbsp;&nbsp;assert(v.empty() || v[0] == m_owned_faces[0]);<br/>
&nbsp;&nbsp;assert(v.empty() || v[ v.size() - 1 ] == m_owned_faces[ v.size() - 1 ]);<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
bool ribi::foam::Cell::HasFace(const boost::shared_ptr&lt;const ribi::foam::Face&gt; face) const noexcept<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;assert(m_all_faces.size() &gt;= m_owned_faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "m_owned_faces must be a subset of m_all_faces: there should be more m_all_faces"<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;for (const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; face: m_owned_faces)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(std::count(m_all_faces.begin(),m_all_faces.end(),face) == 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "m_owned_faces must be a subset of m_all_faces: every owned Face must be in m_all_faces"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;return std::count(m_all_faces.begin(),m_all_faces.end(),face);<br/>
}<br/>
<br/>
bool ribi::foam::Cell::OwnsFace(const boost::shared_ptr&lt;const ribi::foam::Face&gt; face) const noexcept<br/>
{<br/>
&nbsp;&nbsp;return std::count(m_owned_faces.begin(),m_owned_faces.end(),face);<br/>
<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const ribi::foam::Cell&amp; cell)<br/>
{<br/>
&nbsp;&nbsp;for (boost::shared_ptr&lt;Face&gt; face: cell.m_owned_faces)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; *face &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamcell.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamcell.h" border = "1"><tr><td><code>
#ifndef OPENFOAMCELL_H<br/>
#define OPENFOAMCELL_H<br/>
<br/>
#include &lt;vector&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#include "openfoamfwd.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///A Cell contains Faces that enclose a volume<br/>
///These Faces are<br/>
///- owned/managed by this Cell: m_owned_faces<br/>
///- owned/managed by a neighbouring Cell: m_faces<br/>
///Faces know<br/>
///- the Cell that owns them<br/>
///- optionally, the Cell they are also a member of, called 'neighbour'.<br/>
///&nbsp;&nbsp;If this is nullptr, the Face is a boundary face<br/>
///If a Cell contains a boundary Face, it is a boundary cell<br/>
struct Cell<br/>
{<br/>
&nbsp;&nbsp;///owned_faces is a subset of all_faces<br/>
&nbsp;&nbsp;Cell(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; owned_faces = {},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; all_faces = {}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;///Can only assign once<br/>
&nbsp;&nbsp;void AssignOwnedFaces(const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;&amp; owned_faces);<br/>
<br/>
&nbsp;&nbsp;//const boost::shared_ptr&lt;const Cell&gt; GetNeighbour() const noexcept;<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const Face&gt; &gt; GetOwnedFaces() const noexcept;<br/>
<br/>
&nbsp;&nbsp;bool HasFace(const boost::shared_ptr&lt;const Face&gt; face) const noexcept;<br/>
&nbsp;&nbsp;bool OwnsFace(const boost::shared_ptr&lt;const Face&gt; face) const noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;///m_owned_faces is a subset of m_all_faces<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; m_all_faces;<br/>
<br/>
&nbsp;&nbsp;///m_owned_faces is a subset of m_all_faces<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; m_owned_faces;<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Cell&amp; cell);<br/>
};<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Cell&amp; cell);<br/>
<br/>
} //namespace foam<br/>
} //namespace ribi<br/>
<br/>
#endif // OPENFOAMCELL_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamcellindex.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamcellindex.cpp" border = "1"><tr><td><code>
#include "openfoamcellindex.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::CellIndex::CellIndex(const int index)<br/>
&nbsp;&nbsp;: m_index(index)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;assert(m_index &gt;= -1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A CellIndex must be minus one or higher");<br/>
}<br/>
<br/>
ribi::foam::CellIndex&amp; ribi::foam::CellIndex::operator++() noexcept<br/>
{<br/>
&nbsp;&nbsp;++m_index;<br/>
&nbsp;&nbsp;return *this;<br/>
}<br/>
<br/>
ribi::foam::CellIndex ribi::foam::CellIndex::operator++(int) noexcept<br/>
{<br/>
&nbsp;&nbsp;CellIndex old(*this);<br/>
&nbsp;&nbsp;++(*this);<br/>
&nbsp;&nbsp;return old;<br/>
}<br/>
<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::CellIndex::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::CellIndex::Test");<br/>
&nbsp;&nbsp;CellIndex a(2);<br/>
&nbsp;&nbsp;CellIndex b(2);<br/>
&nbsp;&nbsp;CellIndex c(3);<br/>
&nbsp;&nbsp;assert(a == a);<br/>
&nbsp;&nbsp;assert(a == b);<br/>
&nbsp;&nbsp;assert(b == a);<br/>
&nbsp;&nbsp;assert(b == b);<br/>
&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;assert(c != b);<br/>
&nbsp;&nbsp;assert(c == c);<br/>
<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::CellIndex::Test successfully");<br/>
<br/>
}<br/>
#endif<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const CellIndex&amp; cell_index)<br/>
{<br/>
&nbsp;&nbsp;os &lt;&lt; cell_index.Get();<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, CellIndex&amp; cell_index)<br/>
{<br/>
&nbsp;&nbsp;is &gt;&gt; cell_index.m_index;<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;if (!is)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
bool ribi::foam::operator==(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() == rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
bool ribi::foam::operator&lt;(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() &lt; rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator&gt;(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() &gt; rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator&gt;=(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs &lt; rhs);<br/>
}<br/>
<br/>
bool ribi::foam::operator&lt;=(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs &gt; rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamcellindex.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamcellindex.h" border = "1"><tr><td><code>
#ifndef OPENFOAMCELLINDEX_H<br/>
#define OPENFOAMCELLINDEX_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
struct CellIndex<br/>
{<br/>
&nbsp;&nbsp;explicit CellIndex(const int index = -1);<br/>
&nbsp;&nbsp;int Get() const noexcept { return m_index; }<br/>
<br/>
&nbsp;&nbsp;CellIndex&amp; operator++() noexcept;&nbsp;&nbsp; //Prefix<br/>
&nbsp;&nbsp;CellIndex operator++(int) noexcept; //Postfix<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;int m_index;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, CellIndex&amp; cell_index);<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
};<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CellIndex&amp; cell_index);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, CellIndex&amp; cell_index);<br/>
<br/>
bool operator==(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept;<br/>
bool operator!=(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept;<br/>
bool operator&lt;(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept;<br/>
bool operator&gt;(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept;<br/>
bool operator&gt;=(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept;<br/>
bool operator&lt;=(const CellIndex&amp; lhs, const CellIndex&amp; rhs) noexcept;<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMCELLINDEX_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamface.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamface.cpp" border = "1"><tr><td><code>
#include "openfoamface.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;ostream&gt;<br/>
<br/>
#include "openfoamcell.h"<br/>
#include "coordinat3d.h"<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::Face::Face(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; neighbour,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; owner,<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt; &gt;&amp; points<br/>
)<br/>
&nbsp;&nbsp;: m_neighbour(neighbour),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owner(owner),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points(points)<br/>
{<br/>
<br/>
}<br/>
<br/>
void ribi::foam::Face::AssignNeighbour(const boost::shared_ptr&lt;ribi::foam::Cell&gt; neighbour) noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(!m_neighbour &amp;&amp; "neighbour can only be assigned once");<br/>
&nbsp;&nbsp;assert(neighbour);<br/>
&nbsp;&nbsp;m_neighbour = neighbour;<br/>
}<br/>
<br/>
void ribi::foam::Face::AssignOwner(const boost::shared_ptr&lt;ribi::foam::Cell&gt; owner) noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(!m_owner &amp;&amp; "Can only assign owner once");<br/>
&nbsp;&nbsp;assert(owner);<br/>
<br/>
&nbsp;&nbsp;m_owner = owner;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::Cell&gt; ribi::foam::Face::GetOwner() noexcept<br/>
{<br/>
&nbsp;&nbsp;assert( (m_owner || !m_owner) &amp;&amp; "Allow Face to have no owner");<br/>
&nbsp;&nbsp;return m_owner;<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt; ribi::foam::Face::GetPoints() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt;&gt; v;<br/>
&nbsp;&nbsp;std::transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(v),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](const boost::shared_ptr&lt;ribi::Coordinat3D&gt; point)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(point);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const ribi::Coordinat3D&gt; const_point {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(point == const_point);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return const_point;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert(v.size() == m_points.size());<br/>
&nbsp;&nbsp;//Only check first and last<br/>
&nbsp;&nbsp;assert(v.empty() || v[0] == m_points[0]);<br/>
&nbsp;&nbsp;assert(v.empty() || v[ v.size() - 1 ] == m_points[ v.size() - 1 ]);<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
ribi::Coordinat3D ribi::foam::CalcCenter(const Face&amp; face) noexcept<br/>
{<br/>
&nbsp;&nbsp;Coordinat3D d;<br/>
&nbsp;&nbsp;for (boost::shared_ptr&lt;const ribi::Coordinat3D&gt; c: face.GetPoints())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;d += *c;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;d /= static_cast&lt;double&gt;(face.GetPoints().size());<br/>
&nbsp;&nbsp;return d;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const ribi::foam::Face&amp; face)<br/>
{<br/>
&nbsp;&nbsp;if (face.m_neighbour)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Only display the address of a neighbour to prevent recursion<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face.m_neighbour);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; face.m_neighbour;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;os &lt;&lt; '\n';<br/>
&nbsp;&nbsp;assert(face.m_owner &amp;&amp; "Every Face has an owner");<br/>
&nbsp;&nbsp;//if (face.m_owner)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Only display the address of a owner to prevent recursion<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face.m_owner);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; face.m_owner;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;os &lt;&lt; '\n';<br/>
&nbsp;&nbsp;for (const boost::shared_ptr&lt;ribi::Coordinat3D&gt; coordinat: face.m_points)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(coordinat);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; *coordinat &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return os;<br/>
<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamface.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamface.h" border = "1"><tr><td><code>
#ifndef OPENFOAMFACE_H<br/>
#define OPENFOAMFACE_H<br/>
<br/>
#include &lt;vector&gt;<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#include "openfoamfwd.h"<br/>
//#include "openfoamcellindex.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
<br/>
namespace foam {<br/>
<br/>
///An OpenFOAM face:<br/>
///- has a collection of points/vertices/coordinats<br/>
///- has a/no neighbouring cell<br/>
///- has a/no cell owning this face<br/>
struct Face<br/>
{<br/>
&nbsp;&nbsp;Face(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; neighbour,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; owner,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt; &gt;&amp; points<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;Face(const Face&amp;) = delete;<br/>
&nbsp;&nbsp;Face&amp; operator=(const Face&amp;) = delete;<br/>
<br/>
&nbsp;&nbsp;///Can only assign once<br/>
&nbsp;&nbsp;void AssignNeighbour(const boost::shared_ptr&lt;Cell&gt; neighbour) noexcept;<br/>
<br/>
&nbsp;&nbsp;///Can only assign once<br/>
&nbsp;&nbsp;void AssignOwner(const boost::shared_ptr&lt;Cell&gt; owner) noexcept;<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const Cell&gt; GetNeighbour() const noexcept { return m_neighbour; }<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const Cell&gt; GetOwner() const noexcept { return m_owner; }<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cell&gt; GetOwner()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noexcept;<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt; GetPoints() const noexcept;<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ribi::Coordinat3D&gt; &gt;&amp;GetPoints()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noexcept { return m_points; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;///If this Face has no Neighbour, this is nullptr<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;Cell&gt; m_neighbour;<br/>
<br/>
&nbsp;&nbsp;///If this Face has no Owner, this is nullptr<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;Cell&gt; m_owner;<br/>
<br/>
&nbsp;&nbsp;///The points/vertices/coordinats this face consists of<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt; &gt; m_points;<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Face&amp; face);<br/>
};<br/>
<br/>
///Calculate the center of the Face<br/>
ribi::Coordinat3D CalcCenter(const Face&amp; face) noexcept;<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Face&amp; face);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMFACE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfaceindex.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfaceindex.cpp" border = "1"><tr><td><code>
#include "openfoamfaceindex.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::FaceIndex::FaceIndex(const int index)<br/>
&nbsp;&nbsp;: m_index(index)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;if (m_index &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(m_index);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(m_index &gt;= 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A FaceIndex must be zero or a positive value");<br/>
&nbsp;&nbsp;if (m_index &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::invalid_argument("A FaceIndex must be zero or a positive value");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
ribi::foam::FaceIndex&amp; ribi::foam::FaceIndex::operator+=(const FaceIndex&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;m_index += rhs.Get();<br/>
<br/>
&nbsp;&nbsp;assert(m_index &gt;= 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A FaceIndex must be zero or a positive value, must have overflowed");<br/>
&nbsp;&nbsp;if (m_index &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::invalid_argument(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FaceIndex::operator+=: FaceIndex cannot be negative, must have overflowed");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return *this;<br/>
}<br/>
<br/>
ribi::foam::FaceIndex&amp; ribi::foam::FaceIndex::operator-=(const FaceIndex&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;m_index -= rhs.Get();<br/>
<br/>
&nbsp;&nbsp;assert(m_index &gt;= 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A FaceIndex must be zero or a positive value");<br/>
&nbsp;&nbsp;if (m_index &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::invalid_argument(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FaceIndex::operator-=: FaceIndex cannot be negative");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return *this;<br/>
}<br/>
<br/>
ribi::foam::FaceIndex&amp; ribi::foam::FaceIndex::operator++() noexcept<br/>
{<br/>
&nbsp;&nbsp;++m_index;<br/>
&nbsp;&nbsp;return *this;<br/>
}<br/>
<br/>
ribi::foam::FaceIndex ribi::foam::FaceIndex::operator++(int) noexcept<br/>
{<br/>
&nbsp;&nbsp;FaceIndex old(*this);<br/>
&nbsp;&nbsp;++(*this);<br/>
&nbsp;&nbsp;return old;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const FaceIndex&amp; face_index) noexcept<br/>
{<br/>
&nbsp;&nbsp;os &lt;&lt; face_index.Get();<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, FaceIndex&amp; face_index) noexcept<br/>
{<br/>
&nbsp;&nbsp;is &gt;&gt; face_index.m_index;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
const ribi::foam::FaceIndex ribi::foam::operator+(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return FaceIndex(lhs.Get() + rhs.Get());<br/>
}<br/>
<br/>
const ribi::foam::FaceIndex ribi::foam::operator-(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return FaceIndex(lhs.Get() - rhs.Get());<br/>
}<br/>
<br/>
bool ribi::foam::operator==(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() == rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
bool ribi::foam::operator&lt;(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() &lt; rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator&gt;(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() &gt; rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator&gt;=(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs &lt; rhs);<br/>
}<br/>
<br/>
bool ribi::foam::operator&lt;=(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs &gt; rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfaceindex.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfaceindex.h" border = "1"><tr><td><code>
#ifndef OPENFOAMFACEINDEX_H<br/>
#define OPENFOAMFACEINDEX_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
struct FaceIndex<br/>
{<br/>
&nbsp;&nbsp;///Throws std::invalid_argument if the index is invalid<br/>
&nbsp;&nbsp;explicit FaceIndex(const int index);<br/>
&nbsp;&nbsp;int Get() const noexcept { return m_index; }<br/>
<br/>
&nbsp;&nbsp;///Throws std::invalid_argument if the new index is invalid<br/>
&nbsp;&nbsp;FaceIndex&amp; operator+=(const FaceIndex&amp; rhs);<br/>
&nbsp;&nbsp;FaceIndex&amp; operator-=(const FaceIndex&amp; rhs);<br/>
&nbsp;&nbsp;FaceIndex&amp; operator++() noexcept;&nbsp;&nbsp; //Prefix<br/>
&nbsp;&nbsp;FaceIndex operator++(int) noexcept; //Postfix<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;int m_index;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, FaceIndex&amp; face_index) noexcept;<br/>
};<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const FaceIndex&amp; face_index) noexcept;<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, FaceIndex&amp; face_index) noexcept;<br/>
<br/>
const FaceIndex operator+(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept;<br/>
const FaceIndex operator-(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs);<br/>
<br/>
bool operator==(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept;<br/>
bool operator!=(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept;<br/>
bool operator&lt;(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept;<br/>
bool operator&gt;(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept;<br/>
bool operator&gt;=(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept;<br/>
bool operator&lt;=(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs) noexcept;<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMFACEINDEX_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfacesfile.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfacesfile.cpp" border = "1"><tr><td><code>
#include "openfoamfacesfile.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/algorithm/string/trim.hpp&gt;<br/>
#include &lt;boost/algorithm/string/split.hpp&gt;<br/>
#include &lt;boost/lexical_cast.hpp&gt;<br/>
<br/>
#include &lt;QFile&gt;<br/>
<br/>
#include "filename.h"<br/>
#include "fileio.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoamfacesfileitem.h"<br/>
#include "openfoamfaceindex.h"<br/>
#include "openfoamparseerror.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
<br/>
ribi::foam::FacesFile::FacesFile(<br/>
&nbsp;&nbsp;const Header header,<br/>
&nbsp;&nbsp;const std::vector&lt;FacesFileItem&gt;&amp; items)<br/>
&nbsp;&nbsp;: m_header{header},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items(items)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
bool ribi::foam::FacesFile::CanGetItem(const ribi::foam::FaceIndex&amp; face_index) const noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(face_index.Get() &gt;= 0);<br/>
&nbsp;&nbsp;return face_index.Get() &lt; static_cast&lt;int&gt;(m_items.size());<br/>
}<br/>
<br/>
const ribi::foam::Header ribi::foam::FacesFile::GetDefaultHeader() noexcept<br/>
{<br/>
&nbsp;&nbsp;return Header("faceList","constant/polyMesh","","faces");<br/>
}<br/>
<br/>
const ribi::foam::FacesFileItem&amp; ribi::foam::FacesFile::GetItem(const ribi::foam::FaceIndex&amp; face_index) const noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(CanGetItem(face_index));<br/>
&nbsp;&nbsp;return m_items[ face_index.Get() ];<br/>
}<br/>
<br/>
<br/>
const ribi::foam::FaceIndex ribi::foam::FacesFile::GetMaxFaceIndex() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return FaceIndex(static_cast&lt;int&gt;(m_items.size()));<br/>
}<br/>
<br/>
const ribi::foam::FacesFile ribi::foam::FacesFile::Parse(std::istream&amp; is)<br/>
{<br/>
&nbsp;&nbsp;FacesFile b;<br/>
&nbsp;&nbsp;is &gt;&gt; b;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return b;<br/>
}<br/>
<br/>
const ribi::foam::FacesFile ribi::foam::FacesFile::Parse(const std::string&amp; filename)<br/>
{<br/>
&nbsp;&nbsp;const std::string tmp_filename { fileio::GetTempFileName() };<br/>
&nbsp;&nbsp;fileio::CopyFile(filename,tmp_filename);<br/>
&nbsp;&nbsp;Header::CleanFile(tmp_filename);<br/>
&nbsp;&nbsp;std::ifstream f(tmp_filename.c_str());<br/>
&nbsp;&nbsp;const FacesFile file { Parse(f) };<br/>
&nbsp;&nbsp;f.close();<br/>
&nbsp;&nbsp;fileio::DeleteFile(tmp_filename);<br/>
&nbsp;&nbsp;return file;<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::FacesFile::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::FacesFile::Test");<br/>
&nbsp;&nbsp;//Some initial data<br/>
&nbsp;&nbsp;const Header header("some_name","some_location","some_object");<br/>
&nbsp;&nbsp;std::vector&lt;FacesFileItem&gt; items;<br/>
&nbsp;&nbsp;for (int i=1; i!=4; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FacesFileItem item( std::vector&lt;PointIndex&gt;(i,PointIndex(i)));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;items.push_back(item);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator==<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FacesFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FacesFile c(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header == header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FacesFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header other_header("some_other_name","some_other_location","some_other_object");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header != other_header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FacesFile c(other_header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FacesFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;FacesFileItem&gt; other_items;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=1; i!=3; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FacesFileItem item( std::vector&lt;PointIndex&gt;(i+1,PointIndex(i*i)) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FacesFile c(header,other_items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Stream conversion<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FacesFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FacesFile c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (b != c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Read from testing file<br/>
&nbsp;&nbsp;for (int test_index = 0; test_index!=5; ++test_index)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;switch (test_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: filename_appendix = "_1x1x1"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: filename_appendix = "_1x1x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: filename_appendix = "_1x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: filename_appendix = "_2x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: filename_appendix = "_3x4x5"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Should never get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("foam::Files::CreateTestFiles: unknown test index");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!filename_appendix.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename_base { GetDefaultHeader().GetObject() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename = filename_base + filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string resources_path { ":/CppOpenFoam/files/" + filename };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QFile f( resources_path.c_str() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.copy(filename.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!fileio::IsRegularFile(filename))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(fileio::IsRegularFile(filename));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FacesFile b(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (b.GetItems().empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert( (!b.GetItems().empty() || b.GetItems().empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "If a mesh has no non-bhoundary cells, neighbour can be empty");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::Header::FacesFile successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const FacesFile&amp; lhs,const FacesFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;if (lhs.GetHeader() != rhs.GetHeader())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const std::vector&lt;FacesFileItem&gt;&amp; lhs_items = lhs.GetItems();<br/>
&nbsp;&nbsp;const std::vector&lt;FacesFileItem&gt;&amp; rhs_items = rhs.GetItems();<br/>
&nbsp;&nbsp;if (lhs_items.size() != rhs_items.size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return std::equal(lhs_items.begin(),lhs_items.end(),rhs_items.begin());<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const FacesFile&amp; lhs,const FacesFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, FacesFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;assert(f.m_items.empty()); //Make empty otherwise<br/>
<br/>
&nbsp;&nbsp;//Read header<br/>
&nbsp;&nbsp;is &gt;&gt; f.m_header;<br/>
&nbsp;&nbsp;assert(is);<br/>
<br/>
&nbsp;&nbsp;//Read items<br/>
&nbsp;&nbsp;int n_items = 0;<br/>
&nbsp;&nbsp;char opening_bracket = '\0';<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Eat comment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char c = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (c &gt;= '0' &amp;&amp; c &lt;= '9')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (c != '(' &amp;&amp; c != '{')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Start eating n_items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items *= 10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int n = c - '0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(n &gt;= 0 &amp;&amp; n &lt;= 9);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items += n;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;opening_bracket = c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(opening_bracket == '(' || opening_bracket == '{'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(opening_bracket);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;if (opening_bracket == '(')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FacesFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '{');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Read once, push n_items times<br/>
&nbsp;&nbsp;&nbsp;&nbsp;FacesFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Eat comments until bracket close<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_close = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (bracket_close != ')' &amp;&amp; bracket_close != '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_close == ')' || bracket_close == '}');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (opening_bracket == '(' &amp;&amp; bracket_close == ')')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (opening_bracket == '{' &amp;&amp; bracket_close == '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const FacesFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.GetHeader() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.m_items.size() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "(" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;for(const FacesFileItem item: f.m_items)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; item &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ")" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfacesfile.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfacesfile.h" border = "1"><tr><td><code>
#ifndef OPENFOAMFACESFILE_H<br/>
#define OPENFOAMFACESFILE_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "fileiofwd.h"<br/>
#include "openfoamfwd.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoamfacesfileitem.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///Reads and writes an OpenFOAM boundary file<br/>
struct FacesFile<br/>
{<br/>
&nbsp;&nbsp;explicit FacesFile(const std::string&amp; filename) : FacesFile(Parse(filename)) {}<br/>
&nbsp;&nbsp;explicit FacesFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header header = GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;FacesFileItem&gt;&amp; items = {});<br/>
<br/>
&nbsp;&nbsp;bool CanGetItem(const FaceIndex&amp; face_index) const noexcept;<br/>
<br/>
&nbsp;&nbsp;static const Header GetDefaultHeader() noexcept;<br/>
&nbsp;&nbsp;const Header&amp; GetHeader() const noexcept { return m_header; }<br/>
&nbsp;&nbsp;const std::vector&lt;FacesFileItem&gt; GetItems() const noexcept { return m_items; }<br/>
<br/>
&nbsp;&nbsp;///Assumes CanGetItem is true<br/>
&nbsp;&nbsp;const FacesFileItem&amp; GetItem(const FaceIndex&amp; face_index) const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Obtain the number of faces, the size of m_items, or the first face index not available<br/>
&nbsp;&nbsp;const FaceIndex GetMaxFaceIndex() const noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;explicit FacesFile(std::istream&amp; is) : FacesFile(Parse(is)) {}<br/>
<br/>
&nbsp;&nbsp;///The OpenFOAM header<br/>
&nbsp;&nbsp;Header m_header;<br/>
&nbsp;&nbsp;///The items faces contains<br/>
&nbsp;&nbsp;std::vector&lt;FacesFileItem&gt; m_items;<br/>
<br/>
&nbsp;&nbsp;static const FacesFile Parse(std::istream&amp; is);<br/>
&nbsp;&nbsp;static const FacesFile Parse(const std::string&amp; filename);<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const FacesFile&amp; f);<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, FacesFile&amp; f);<br/>
};<br/>
<br/>
bool operator==(const FacesFile&amp; lhs,const FacesFile&amp; rhs);<br/>
bool operator!=(const FacesFile&amp; lhs,const FacesFile&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const FacesFile&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, FacesFile&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMFACESFILE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfacesfileitem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfacesfileitem.cpp" border = "1"><tr><td><code>
#include "openfoamfacesfileitem.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;sstream&gt;<br/>
<br/>
#include "openfoamparseerror.h"<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::FacesFileItem::FacesFileItem(<br/>
&nbsp;&nbsp;const std::vector&lt;PointIndex&gt;&amp; point_indices<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_point_indices{point_indices}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;for (PointIndex index: m_point_indices)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(index.Get() &gt;= 0 &amp;&amp; "Sure, there is a point with index 0");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::FacesFileItem::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::FacesFileItem::Test");<br/>
&nbsp;&nbsp;const FacesFileItem i( { PointIndex(1),PointIndex(2),PointIndex(3),PointIndex(4) } );<br/>
&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;s &lt;&lt; i;<br/>
&nbsp;&nbsp;FacesFileItem j;<br/>
&nbsp;&nbsp;s &gt;&gt; j;<br/>
&nbsp;&nbsp;if (i != j)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(j);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(i == j);<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::FacesFileItem::Test successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const FacesFileItem&amp; lhs, const FacesFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetPointIndices() == rhs.GetPointIndices()<br/>
&nbsp;&nbsp;;<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const FacesFileItem&amp; lhs, const FacesFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const FacesFileItem&amp; item)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; item.GetPointIndices().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "("<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;for (const PointIndex i: item.GetPointIndices()) { s &lt;&lt; i &lt;&lt; " "; }<br/>
&nbsp;&nbsp;std::string t { s.str() };<br/>
&nbsp;&nbsp;assert(t.back() == ' ');<br/>
&nbsp;&nbsp;t.pop_back();<br/>
&nbsp;&nbsp;assert(t.back() != ' ');<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ")"<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, FacesFileItem&amp; f)<br/>
{<br/>
&nbsp;&nbsp;assert(f.GetPointIndices().empty()); //Or empty it<br/>
&nbsp;&nbsp;int n_nodes = 0;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; n_nodes;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (n_nodes &lt;= 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw ParseError();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(n_nodes &gt; 0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_open;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_open;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_open == '(');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;for (int i=0; i!=n_nodes; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PointIndex node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; node;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f.m_point_indices.push_back(node);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_close == ')');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfacesfileitem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfacesfileitem.h" border = "1"><tr><td><code>
#ifndef OPENFOAMFACESFILEITEM_H<br/>
#define OPENFOAMFACESFILEITEM_H<br/>
<br/>
#include &lt;vector&gt;<br/>
#include &lt;iosfwd&gt;<br/>
#include "openfoampointindex.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///An item in an OpenFOAM 'faces' file<br/>
struct FacesFileItem<br/>
{<br/>
&nbsp;&nbsp;explicit FacesFileItem(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;PointIndex&gt;&amp; point_indices = {}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;PointIndex&gt;&amp; GetPointIndices() const noexcept { return m_point_indices; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;std::vector&lt;PointIndex&gt; m_point_indices;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend class OpenFoamFacesFile;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, FacesFileItem&amp; f);<br/>
};<br/>
<br/>
bool operator==(const FacesFileItem&amp; lhs, const FacesFileItem&amp; rhs);<br/>
bool operator!=(const FacesFileItem&amp; lhs, const FacesFileItem&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const FacesFileItem&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, FacesFileItem&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
<br/>
#endif // OPENFOAMFACESFILEITEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfilenames.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfilenames.cpp" border = "1"><tr><td><code>
#include "openfoamfilenames.h"<br/>
<br/>
#include "parameterfilenamesopenfoam.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;sstream&gt;<br/>
<br/>
#include "fileio.h"<br/>
#include "xml.h"<br/>
<br/>
const std::vector&lt;ribi::fileio::Filename&gt; ribi::foam::Filenames::GetAll() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetBoundary(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetFaces(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetNeighbour(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetOpenFoamCase(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetOwner(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;GetPoints()<br/>
&nbsp;&nbsp;};<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetBoundary() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"constant"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "polyMesh"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "boundary"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetFaces() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"constant"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "polyMesh"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "faces"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetNeighbour() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"constant"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "polyMesh"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "neighbour"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetOpenFoamCase() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename("case.foam");<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetOpenFoamControlDict() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"system"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "controlDict"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetOpenFoamFvSchemes() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"system"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "fvSchemes"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetOpenFoamFvSolution() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"system"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "fvSolution"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetOpenFoamPressureField() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"0"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "p"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetOpenFoamTransportProperties() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"constant"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "transportProperties"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetOpenFoamVelocityField() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"0"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "U"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetOwner() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"constant"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "polyMesh"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "owner"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
const ribi::fileio::Filename ribi::foam::Filenames::GetPoints() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return ribi::fileio::Filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"constant"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "polyMesh"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ "points"<br/>
&nbsp;&nbsp;);<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const ribi::foam::Filenames&amp; filenames)<br/>
{<br/>
&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;s<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ribi::xml::ToXml("filename_boundary",filenames.GetBoundary())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ribi::xml::ToXml("filename_faces",filenames.GetFaces())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ribi::xml::ToXml("filename_neightbour",filenames.GetNeighbour())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ribi::xml::ToXml("filename_openfoam",filenames.GetOpenFoamCase())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ribi::xml::ToXml("filename_owner",filenames.GetOwner())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ribi::xml::ToXml("filename_points",filenames.GetPoints())<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;os &lt;&lt; ribi::xml::ToXml("parameter_filenames_openfoam",s.str());<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfilenames.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfilenames.h" border = "1"><tr><td><code>
#ifndef OPENFOAMFILENAMES_H<br/>
#define OPENFOAMFILENAMES_H<br/>
<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
<br/>
#include "filename.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///Filenames used for OpenFOAM<br/>
struct Filenames<br/>
{<br/>
&nbsp;&nbsp;const std::vector&lt;ribi::fileio::Filename&gt; GetAll() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename the resulting boundary (needed by OpenFoam) will be written to<br/>
&nbsp;&nbsp;///Must use Win32 backslashes<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetBoundary() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename the resulting faces will be written to<br/>
&nbsp;&nbsp;///Must use Win32 backslashes<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetFaces() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename the resulting neighbour (needed by OpenFOAM) will be written to<br/>
&nbsp;&nbsp;///Must use Win32 backslashes<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetNeighbour() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename that indicates that this is an OpenFOAM case<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetOpenFoamCase() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename for the OpenFOAM its controlDict<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetOpenFoamControlDict() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename of the OpenFOAM solver schemes<br/>
&nbsp;&nbsp;///Must use Win32 backslashes<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetOpenFoamFvSchemes() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename of the OpenFOAM solver solution<br/>
&nbsp;&nbsp;///Must use Win32 backslashes<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetOpenFoamFvSolution() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename for the OpenFOAM its case its pressure field<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetOpenFoamPressureField() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename for the OpenFOAM its case its TransportProperties<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetOpenFoamTransportProperties() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename for the OpenFOAM its case its velocity field<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetOpenFoamVelocityField() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename the resulting owner (needed by OpenFOAM) will be written to<br/>
&nbsp;&nbsp;///Must use Win32 backslashes<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetOwner() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///The filename the resulting nodes will be written to<br/>
&nbsp;&nbsp;///Must use Win32 backslashes<br/>
&nbsp;&nbsp;const ribi::fileio::Filename GetPoints() const noexcept;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
};<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Filenames&amp; filenames);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMFILENAMES_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfiles.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfiles.cpp" border = "1"><tr><td><code>
#include "openfoamfiles.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;map&gt;<br/>
#include &lt;set&gt;<br/>
#include &lt;sstream&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;QFile&gt;<br/>
<br/>
#include "fileio.h"<br/>
#include "filename.h"<br/>
#include "openfoamboundaryfile.h"<br/>
#include "openfoamfacesfile.h"<br/>
#include "coordinat3d.h"<br/>
#include "openfoamneighbourfile.h"<br/>
#include "openfoamownerfile.h"<br/>
#include "openfoamfilenames.h"<br/>
#include "openfoampointsfile.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
/*<br/>
ribi::foam::Files::Files(const std::string&amp; folder_name)<br/>
&nbsp;&nbsp;: m_boundary(CreateBoundary(folder_name)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces(CreateFaces(folder_name)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_neighbour(CreateNeighbour(folder_name)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owner(CreateOwner(folder_name)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points(CreatePoints(folder_name))<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(ribi::fileio::IsFolder(folder_name));<br/>
&nbsp;&nbsp;assert(m_boundary);<br/>
&nbsp;&nbsp;assert(m_faces);<br/>
&nbsp;&nbsp;assert(m_neighbour);<br/>
&nbsp;&nbsp;assert(m_owner);<br/>
&nbsp;&nbsp;assert(m_points);<br/>
}<br/>
*/<br/>
<br/>
ribi::foam::Files::Files(<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;BoundaryFile&gt; boundary,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FacesFile&gt; faces,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;NeighbourFile&gt; neighbour,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;OwnerFile&gt; owner,<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;PointsFile&gt; points<br/>
) : m_boundary(boundary),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces(faces),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_neighbour(neighbour),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owner(owner),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points(points)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(m_boundary);<br/>
&nbsp;&nbsp;assert(m_faces);<br/>
&nbsp;&nbsp;assert(m_neighbour);<br/>
&nbsp;&nbsp;assert(m_owner);<br/>
&nbsp;&nbsp;assert(m_points);<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;CheckMe();<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
}<br/>
<br/>
void ribi::foam::Files::CheckMe() const<br/>
{<br/>
&nbsp;&nbsp;TRACE_FUNC();<br/>
&nbsp;&nbsp;const FaceIndex n_faces { FaceIndex(static_cast&lt;int&gt;(this-&gt;m_faces-&gt;GetItems().size())) };<br/>
&nbsp;&nbsp;const PointIndex n_points { PointIndex(static_cast&lt;int&gt;(this-&gt;m_points-&gt;GetItems().size())) };<br/>
<br/>
&nbsp;&nbsp;TRACE("CheckMe: 'boundary' file individuals items");<br/>
&nbsp;&nbsp;for (const BoundaryFileItem&amp; item: m_boundary-&gt;GetItems())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "Error in 'boundary' file in this item:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; item &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (item.GetNfaces() &lt;= 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "nFaces (" &lt;&lt; item.GetNfaces() &lt;&lt; ") must be a positive non-zero value";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (item.GetStartFace() &gt; n_faces)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "startFace (" &lt;&lt; item.GetStartFace() &lt;&lt; ") beyond number of faces (" &lt;&lt; n_faces &lt;&lt; ")";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (item.GetStartFace() + FaceIndex(item.GetNfaces()) &gt; n_faces)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "startFace (" &lt;&lt; item.GetStartFace() &lt;&lt; ")"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; " + nFaces (" &lt;&lt; n_faces &lt;&lt; ")"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; " = " &lt;&lt; (item.GetStartFace() + FaceIndex(item.GetNfaces()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; " is beyond number of faces (" &lt;&lt; n_faces &lt;&lt; ")"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("CheckMe: 'boundary' file: no ranges should overlap");<br/>
&nbsp;&nbsp;const int n_boundary_items { static_cast&lt;int&gt;(m_boundary-&gt;GetItems().size()) };<br/>
&nbsp;&nbsp;for (int i=0; i!=n_boundary_items; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFileItem item_i = m_boundary-&gt;GetItems()[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex first_i = item_i.GetStartFace();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(first_i.Get() &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(item_i.GetNfaces() &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex last_i = first_i + FaceIndex(item_i.GetNfaces());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int j=0; j!=n_boundary_items; ++j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i == j) continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFileItem item_j = m_boundary-&gt;GetItems()[j];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex first_j = item_j.GetStartFace();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(item_j.GetNfaces() &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex last_j = first_j + FaceIndex(item_j.GetNfaces());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (first_i &gt;= first_j &amp;&amp; first_i &lt; last_j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (last_i&nbsp;&nbsp;&gt;&nbsp;&nbsp;first_j &amp;&amp; last_i&nbsp;&nbsp;&lt; last_j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (first_j &gt;= first_i &amp;&amp; first_j &lt; last_i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (last_j&nbsp;&nbsp;&gt;&nbsp;&nbsp;first_i &amp;&amp; last_j&nbsp;&nbsp;&lt; last_i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(*m_boundary);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "Error in 'boundary' file in these items:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; item_i &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; item_j &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Face index ranges overlap: "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "[" &lt;&lt; first_i &lt;&lt; "," &lt;&lt; last_i &lt;&lt; "&gt; and "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "[" &lt;&lt; first_j &lt;&lt; "," &lt;&lt; last_j &lt;&lt; "&gt;";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;TRACE("CheckMe: 'faces' files: point indices must be valid");<br/>
&nbsp;&nbsp;for (const FacesFileItem&amp; item: m_faces-&gt;GetItems())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (const PointIndex&amp; index: item.GetPointIndices())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index.Get() &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (index &gt;= n_points)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "Error in 'faces' file in this item:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; item &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "point index (" &lt;&lt; index &lt;&lt; ") beyond number of points (" &lt;&lt; n_points &lt;&lt; ")"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(s.str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("CheckMe: 'faces' files: detect doublures");<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (FaceIndex i = FaceIndex(0); i!=n_faces; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;PointIndex&gt; v_i { m_faces-&gt;GetItem(i).GetPointIndices() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::sort(v_i.begin(),v_i.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (FaceIndex j = FaceIndex(0); j!=n_faces; ++j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i == j) continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;PointIndex&gt; v_j { m_faces-&gt;GetItem(j).GetPointIndices() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::sort(v_j.begin(),v_j.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (v_i == v_j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "Error in 'faces' file in these items:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Item " &lt;&lt; i &lt;&lt; ": " &lt;&lt; m_faces-&gt;GetItem(i) &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Item " &lt;&lt; j &lt;&lt; ": " &lt;&lt; m_faces-&gt;GetItem(j) &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Faces at index " &lt;&lt; i &lt;&lt; " and " &lt;&lt; j &lt;&lt; " consist of the same Point indices";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(s.str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("CheckMe: 'owner' files");<br/>
&nbsp;&nbsp;if (m_owner-&gt;GetItems().size() != m_faces-&gt;GetItems().size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "The file 'owner' has a different amount of faces than 'faces':\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "'faces' has " &lt;&lt; m_faces-&gt;GetItems().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ", where 'owner' has " &lt;&lt; m_owner-&gt;GetItems().size()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(s.str());<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;#ifdef SURE_THIS_CODE_CANNOT_BE_REUSED_20131212<br/>
&nbsp;&nbsp;//Faces that have the same owner (which is a cell index) are member of the same cell<br/>
&nbsp;&nbsp;//Each point index of all faces must be present at least one times: at least three faces are<br/>
&nbsp;&nbsp;//needed at each vertex to form an enclosing/non-leaking cell surface, yet not all faces<br/>
&nbsp;&nbsp;//are owned by each cell<br/>
&nbsp;&nbsp;//Because each point index must be present once, it has no use collecting these<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::map&lt;CellIndex,std::multiset&lt;PointIndex&gt;&gt; m;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (FaceIndex face_index = FaceIndex(0); face_index!=n_faces; ++face_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find the point indices of this face<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;PointIndex&gt; p { m_faces-&gt;GetItem(face_index).GetPointIndices() };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find the owner of this face<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex c { m_owner-&gt;GetItem(face_index).GetCellIndex() };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Add the combination to m<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m.find(c) == m.end()) { m.insert(std::make_pair(c,std::multiset&lt;PointIndex&gt;())); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(m.find(c) != m.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::copy(p.begin(),p.end(),std::inserter(m.find(c)-&gt;second,m.find(c)-&gt;second.begin()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Check that each point index is present at least twice<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (const std::pair&lt;CellIndex,std::multiset&lt;PointIndex&gt;&gt;&amp; s: m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (const PointIndex&amp; i: s.second)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int count = s.second.count(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (count &lt; 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(*m_owner);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(*m_faces);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream str;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Error in 'owner' and 'faces' file combination:\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "The file 'owner' has faces owned by the same cell,"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "of which these faces do not cover each vertex with at least two times\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "In this case, cell index " &lt;&lt; s.first<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; " its faces have a point index " &lt;&lt; i &lt;&lt; " that is only a member of "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; count &lt;&lt; " faces"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error(str.str());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;TRACE("CheckMe finished successfully");<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::BoundaryFile&gt; ribi::foam::Files::CreateBoundary(<br/>
&nbsp;&nbsp;const std::string&amp; folder_name)<br/>
{<br/>
&nbsp;&nbsp;std::cout &lt;&lt; (__func__) &lt;&lt; std::endl;<br/>
<br/>
&nbsp;&nbsp;assert(ribi::fileio::IsFolder(folder_name));<br/>
<br/>
&nbsp;&nbsp;const ribi::fileio::Filename filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(folder_name.empty() ? folder_name : folder_name + fileio::GetPathSeperator())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ CreateFilenames()-&gt;GetBoundary().Get()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;if (!fileio::IsRegularFile(filename))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE("BREAK");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;assert(fileio::IsRegularFile(filename));<br/>
<br/>
&nbsp;&nbsp;std::ifstream is(filename.Get().c_str());<br/>
<br/>
&nbsp;&nbsp;try<br/>
&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::foam::BoundaryFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ribi::foam::BoundaryFile(filename.Get())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return p;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;catch(std::runtime_error&amp; e)<br/>
&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "File '" &lt;&lt; filename &lt;&lt; "' is not an OpenFOAM 'boundary' file: "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; e.what();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error(s.str());<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
void ribi::foam::Files::CreateCopy(<br/>
&nbsp;&nbsp;const ribi::foam::Files&amp; files,<br/>
&nbsp;&nbsp;const std::string copy_folder_name) noexcept<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;if (fileio::IsFolder(copy_folder_name))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(copy_folder_name);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(!fileio::IsFolder(copy_folder_name)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Cannot make a copy in an existing folder");<br/>
<br/>
&nbsp;&nbsp;CreateFolders(copy_folder_name);<br/>
&nbsp;&nbsp;//boundary<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string destination_path {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy_folder_name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ BoundaryFile::GetDefaultHeader().GetLocation()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ BoundaryFile::GetDefaultHeader().GetObject()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::ofstream f(destination_path.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f &lt;&lt; *files.GetBoundary();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//faces<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string destination_path {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy_folder_name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ FacesFile::GetDefaultHeader().GetLocation()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ FacesFile::GetDefaultHeader().GetObject()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::ofstream f(destination_path.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f &lt;&lt; *files.GetFaces();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//neighbour<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string destination_path {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy_folder_name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ NeighbourFile::GetDefaultHeader().GetLocation()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ NeighbourFile::GetDefaultHeader().GetObject()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::ofstream f(destination_path.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f &lt;&lt; *files.GetNeighbour();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//owner<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string destination_path {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy_folder_name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ OwnerFile::GetDefaultHeader().GetLocation()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ OwnerFile::GetDefaultHeader().GetObject()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::ofstream f(destination_path.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f &lt;&lt; *files.GetOwner();<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//points<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string destination_path {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy_folder_name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ PointsFile::GetDefaultHeader().GetLocation()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ PointsFile::GetDefaultHeader().GetObject()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::ofstream f(destination_path.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f &lt;&lt; *files.GetPoints();<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;try<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(Files(copy_folder_name) == files<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Resulting Files must be same");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;catch (std::runtime_error&amp; e)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(e.what());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!"Resulting Files must be same");<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::BoundaryFile&gt; ribi::foam::Files::CreateDefaultBoundary() noexcept<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;BoundaryFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new BoundaryFile<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::FacesFile&gt; ribi::foam::Files::CreateDefaultFaces() noexcept<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FacesFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new FacesFile<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::NeighbourFile&gt; ribi::foam::Files::CreateDefaultNeighbour() noexcept<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;NeighbourFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new NeighbourFile<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::OwnerFile&gt; ribi::foam::Files::CreateDefaultOwner() noexcept<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;OwnerFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new OwnerFile<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::PointsFile&gt; ribi::foam::Files::CreateDefaultPoints() noexcept<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;PointsFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new PointsFile<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::FacesFile&gt; ribi::foam::Files::CreateFaces(<br/>
&nbsp;&nbsp;const std::string&amp; folder_name)<br/>
{<br/>
&nbsp;&nbsp;std::cout &lt;&lt; (__func__) &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;assert(ribi::fileio::IsFolder(folder_name));<br/>
&nbsp;&nbsp;const ribi::fileio::Filename filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(folder_name.empty() ? folder_name : folder_name + fileio::GetPathSeperator())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ CreateFilenames()-&gt;GetFaces().Get()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;//std::ifstream is(filename.Get().c_str());<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;ribi::foam::FacesFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new ribi::foam::FacesFile(filename.Get())<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::Filenames&gt; ribi::foam::Files::CreateFilenames() noexcept<br/>
{<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::foam::Filenames&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new Filenames<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
void ribi::foam::Files::CreateFolders(const std::string&amp; folder_name)<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string s { fileio::GetPathSeperator() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string f { folder_name + s + std::string("constant") };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!fileio::IsFolder(f)) { fileio::CreateFolder(f); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(fileio::IsFolder(f));<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string s { fileio::GetPathSeperator() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string f { folder_name + s + std::string("constant") + s + std::string("polyMesh") };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!fileio::IsFolder(f)) { fileio::CreateFolder(f); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(fileio::IsFolder(f));<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::NeighbourFile&gt; ribi::foam::Files::CreateNeighbour(<br/>
&nbsp;&nbsp;const std::string&amp; folder_name)<br/>
{<br/>
&nbsp;&nbsp;std::cout &lt;&lt; (__func__) &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;assert(ribi::fileio::IsFolder(folder_name));<br/>
&nbsp;&nbsp;const ribi::fileio::Filename filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(folder_name.empty() ? folder_name : folder_name + fileio::GetPathSeperator())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ CreateFilenames()-&gt;GetNeighbour().Get()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;//std::ifstream is(filename.Get().c_str());<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;ribi::foam::NeighbourFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new ribi::foam::NeighbourFile(filename.Get())<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::OwnerFile&gt; ribi::foam::Files::CreateOwner(<br/>
&nbsp;&nbsp;const std::string&amp; folder_name)<br/>
{<br/>
&nbsp;&nbsp;std::cout &lt;&lt; (__func__) &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;assert(ribi::fileio::IsFolder(folder_name));<br/>
&nbsp;&nbsp;const ribi::fileio::Filename filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(folder_name.empty() ? folder_name : folder_name + fileio::GetPathSeperator())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ CreateFilenames()-&gt;GetOwner().Get()<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::foam::OwnerFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new ribi::foam::OwnerFile(filename.Get())<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;//std::ifstream is(filename.Get().c_str());<br/>
&nbsp;&nbsp;//const boost::shared_ptr&lt;ribi::foam::OwnerFile&gt; p {<br/>
&nbsp;&nbsp;//&nbsp;&nbsp;new ribi::foam::OwnerFile(is)<br/>
&nbsp;&nbsp;//};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::PointsFile&gt; ribi::foam::Files::CreatePoints(<br/>
&nbsp;&nbsp;const std::string&amp; folder_name)<br/>
{<br/>
&nbsp;&nbsp;std::cout &lt;&lt; (__func__) &lt;&lt; std::endl;<br/>
&nbsp;&nbsp;assert(ribi::fileio::IsFolder(folder_name));<br/>
&nbsp;&nbsp;const ribi::fileio::Filename filename(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(folder_name.empty() ? folder_name : folder_name + fileio::GetPathSeperator())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ CreateFilenames()-&gt;GetPoints().Get()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;//std::ifstream is(filename.Get().c_str());<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;ribi::foam::PointsFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new ribi::foam::PointsFile(filename.Get())<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;ribi::foam::Files&gt;&gt; ribi::foam::Files::CreateTestFiles() noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;ribi::foam::Files&gt;&gt; v;<br/>
&nbsp;&nbsp;//Empty<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Files&gt; files {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Files<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(files);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(files);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Complex from resources<br/>
&nbsp;&nbsp;for (int i=0; i!=5; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string folder_name = ribi::fileio::GetTempFolderName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreateTestFiles(folder_name,i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Files&gt; files {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Files(folder_name)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(files);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(files);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ribi::fileio::DeleteFolder(folder_name);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
void ribi::foam::Files::CreateTestFiles(const std::string&amp; folder_name, const int test_index)<br/>
{<br/>
&nbsp;&nbsp;assert(test_index &gt;= 0 &amp;&amp; test_index &lt; 5);<br/>
<br/>
&nbsp;&nbsp;CreateFolders(folder_name);<br/>
<br/>
&nbsp;&nbsp;//Read from testing file<br/>
&nbsp;&nbsp;for (const std::string filename_base:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundaryFile::GetDefaultHeader().GetObject(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FacesFile::GetDefaultHeader().GetObject(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NeighbourFile::GetDefaultHeader().GetObject(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OwnerFile::GetDefaultHeader().GetObject(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointsFile::GetDefaultHeader().GetObject()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;switch (test_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: filename_appendix = "_1x1x1"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: filename_appendix = "_1x1x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: filename_appendix = "_1x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: filename_appendix = "_2x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: filename_appendix = "_3x4x5"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Should never get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("foam::Files::CreateTestFiles: unknown test index");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!filename_appendix.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename = filename_base + filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string resources_path { ":/CppOpenFoam/files/" + filename };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string destination_path {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;folder_name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ "constant"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ "polyMesh"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ fileio::GetPathSeperator()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ filename_base<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;QFile f(resources_path.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f.copy(destination_path.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(fileio::IsRegularFile(destination_path));<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
void ribi::foam::Files::Swap(const ribi::foam::FaceIndex&amp; lhs, const ribi::foam::FaceIndex&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;assert(lhs != rhs);<br/>
&nbsp;&nbsp;//Boundary<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Cleanest interface I could think of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//m_boundary-&gt;Swap(lhs,rhs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boost::shared_ptr&lt;int&gt; lhs_n_faces;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (m_boundary-&gt;CanGetItem(lhs))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lhs_n_faces.reset(new int(m_boundary-&gt;Find(lhs).GetNfaces()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boost::shared_ptr&lt;int&gt; rhs_n_faces;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryIndex lhs_boundary_index = m_boundary-&gt;GetItem(lhs).GetCellIndex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryIndex rhs_boundary_index = m_owner-&gt;GetItem(rhs).GetCellIndex();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Set swapped<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owner-&gt;SetItem(lhs,OwnerFileItem(rhs_cell_index));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owner-&gt;SetItem(rhs,OwnerFileItem(lhs_cell_index));<br/>
&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Neighbour<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Can only swap two cellIndices when either both of them are absent<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//(both cells are boundary cells)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//or both of them are present<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//(both cells are non-boundary cells)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const bool lhs_is_boundary = m_neighbour-&gt;CanGetItem(lhs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const bool rhs_is_boundary = m_neighbour-&gt;CanGetItem(rhs);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(lhs_is_boundary == rhs_is_boundary<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Can only swap two boundary or two non-boundary faces");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (lhs_is_boundary != rhs_is_boundary)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("Can only swap two boundary or two non-boundary faces");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (lhs_is_boundary)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(rhs_is_boundary);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Done! Boundary cells have no neighbours<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex lhs_cell_index = m_neighbour-&gt;GetItem(lhs).GetCellIndex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex rhs_cell_index = m_neighbour-&gt;GetItem(rhs).GetCellIndex();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Set swapped<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_neighbour-&gt;SetItem(lhs,NeighbourFileItem(rhs_cell_index));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_neighbour-&gt;SetItem(rhs,NeighbourFileItem(lhs_cell_index));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*/<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Owner<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex lhs_cell_index = m_owner-&gt;GetItem(lhs).GetCellIndex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex rhs_cell_index = m_owner-&gt;GetItem(rhs).GetCellIndex();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Set swapped<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owner-&gt;SetItem(lhs,OwnerFileItem(rhs_cell_index));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_owner-&gt;SetItem(rhs,OwnerFileItem(lhs_cell_index));<br/>
&nbsp;&nbsp;}<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::Files::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::Files::Test");<br/>
&nbsp;&nbsp;//operator==<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files f;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f == f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files g;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f == g);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(g == f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(g == g);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator==<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files f;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f == f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files g;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f == g);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(g == f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(g == g);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::foam::Files&gt;&gt; v { Files::CreateTestFiles() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::size_t sz = v.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (std::size_t i=0; i!=sz; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (std::size_t j=0; j!=sz; ++j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i == j) { assert(v[i] == v[j]); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i != j) { assert(v[i] != v[j]); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//CreateCopy<br/>
&nbsp;&nbsp;for (int test_index=0; test_index!=5; ++test_index)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string temp_folder_source = ribi::fileio::GetTempFolderName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!ribi::fileio::IsFolder(temp_folder_source));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateTestFiles(temp_folder_source,test_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files source(temp_folder_source);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string temp_folder_target = ribi::fileio::GetTempFolderName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Files::CreateCopy(source,temp_folder_target);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files target(temp_folder_target);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(source == target);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ribi::fileio::DeleteFolder(temp_folder_source);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ribi::fileio::DeleteFolder(temp_folder_target);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Swap faces<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string temp_folder = ribi::fileio::GetTempFolderName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!ribi::fileio::IsFolder(temp_folder));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreateTestFiles(temp_folder,3); //3 = 2x2x2 cubes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files f(temp_folder);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f == f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Files g(temp_folder);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f == g);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(g == f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(g == g);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex i(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex j(11);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;g.Swap(i,j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(g != f);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f != g);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;g.Swap(i,j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(f == g);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ribi::fileio::DeleteFolder(temp_folder);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!ribi::fileio::IsFolder(temp_folder));<br/>
<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::Files::Test successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const ribi::foam::Files&amp; lhs, const ribi::foam::Files&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;//Split function for ease in debugging<br/>
&nbsp;&nbsp;if (*lhs.GetBoundary()!= *rhs.GetBoundary())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Boundaries differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*lhs.GetBoundary());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*rhs.GetBoundary());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (*lhs.GetFaces() != *rhs.GetFaces())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Faces differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*lhs.GetFaces());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*rhs.GetFaces());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (*lhs.GetNeighbour() != *rhs.GetNeighbour())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Neighbours differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*lhs.GetNeighbour());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*rhs.GetNeighbour());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (*lhs.GetOwner() != *rhs.GetOwner())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Owners differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*lhs.GetOwner());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*rhs.GetOwner());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (*lhs.GetPoints() != *rhs.GetPoints())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Points differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*lhs.GetPoints());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(*rhs.GetPoints());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const ribi::foam::Files&amp; lhs, const ribi::foam::Files&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const Files&amp; files)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; (*files.GetBoundary()) &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; (*files.GetFaces())&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; (*files.GetNeighbour()) &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; (*files.GetOwner())&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; (*files.GetPoints())<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfiles.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfiles.h" border = "1"><tr><td><code>
#ifndef OPENFOAMFILES_H<br/>
#define OPENFOAMFILES_H<br/>
<br/>
#include &lt;vector&gt;<br/>
#include &lt;iosfwd&gt;<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#include "openfoamfwd.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///Files contains the info of all files in an OpenFOAM folder<br/>
///This info can be used to create a Mesh<br/>
///After creating a Files, these files can be deleted<br/>
///Use CreateCopy to let these files be recreated again<br/>
struct Files<br/>
{<br/>
&nbsp;&nbsp;///Builds up Files from the current or any folder<br/>
&nbsp;&nbsp;///Use an empty string to build up from current folder<br/>
&nbsp;&nbsp;explicit Files(const std::string&amp; folder_name)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: Files(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateBoundary(folder_name),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateFaces(folder_name),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateNeighbour(folder_name),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateOwner(folder_name),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreatePoints(folder_name)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) { }<br/>
<br/>
&nbsp;&nbsp;///Builds up a Files from its information or from nothing<br/>
&nbsp;&nbsp;explicit Files(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;BoundaryFile&gt; boundary = CreateDefaultBoundary(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;FacesFile&gt; faces = CreateDefaultFaces(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;NeighbourFile&gt; neighbour = CreateDefaultNeighbour(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;OwnerFile&gt; owner = CreateDefaultOwner(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;PointsFile&gt; points = CreateDefaultPoints()<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;//Files(const Files&amp;) = delete;<br/>
&nbsp;&nbsp;//Files&amp; operator=(const Files&amp;) = delete;<br/>
<br/>
&nbsp;&nbsp;///Create a copy of the complete file structure of Files in the copy folder name<br/>
&nbsp;&nbsp;static void CreateCopy(const Files&amp; files, const std::string copy_folder_name) noexcept;<br/>
<br/>
&nbsp;&nbsp;///Create test files in the correct OpenFOAM folder structure<br/>
&nbsp;&nbsp;///These files are obtained from the /Classes/CppOpenFoam/CppOpenFoam.qrc resources file<br/>
&nbsp;&nbsp;static void CreateTestFiles(const std::string&amp; folder_name, const int test_index);<br/>
<br/>
&nbsp;&nbsp;///Create valid test Files<br/>
&nbsp;&nbsp;///0: empty Files<br/>
&nbsp;&nbsp;///1: Cube<br/>
&nbsp;&nbsp;///2: 1x2 cubes<br/>
&nbsp;&nbsp;///3: 2x2 cubes<br/>
&nbsp;&nbsp;static const std::vector&lt;boost::shared_ptr&lt;Files&gt;&gt; CreateTestFiles() noexcept;<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const BoundaryFile&gt; GetBoundary() const noexcept { return m_boundary; }<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const FacesFile&gt; GetFaces() const noexcept { return m_faces; }<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const NeighbourFile&gt; GetNeighbour() const noexcept { return m_neighbour; }<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const OwnerFile&gt; GetOwner() const noexcept { return m_owner; }<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const PointsFile&gt; GetPoints() const noexcept { return m_points; }<br/>
<br/>
&nbsp;&nbsp;void Swap(const FaceIndex&amp; lhs, const FaceIndex&amp; rhs);<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;BoundaryFile&gt; m_boundary;<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FacesFile&gt; m_faces;<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;NeighbourFile&gt; m_neighbour;<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;OwnerFile&gt; m_owner;<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;PointsFile&gt; m_points;<br/>
<br/>
&nbsp;&nbsp;///Checks this class for correctless<br/>
&nbsp;&nbsp;///Throws std::logic_error if there are incorrectnesses<br/>
&nbsp;&nbsp;void CheckMe() const;<br/>
<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;BoundaryFile&gt; CreateBoundary(const std::string&amp; folder_name);<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;BoundaryFile&gt; CreateDefaultBoundary() noexcept;<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;FacesFile&gt; CreateDefaultFaces() noexcept;<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;NeighbourFile&gt; CreateDefaultNeighbour() noexcept;<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;OwnerFile&gt; CreateDefaultOwner() noexcept;<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;PointsFile&gt; CreateDefaultPoints() noexcept;<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;FacesFile&gt; CreateFaces(const std::string&amp; folder_name);<br/>
<br/>
&nbsp;&nbsp;///Creates the folder structure needed by OpenFOAM<br/>
&nbsp;&nbsp;static void CreateFolders(const std::string&amp; folder_name);<br/>
<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;Filenames&gt; CreateFilenames() noexcept;<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;NeighbourFile&gt; CreateNeighbour(const std::string&amp; folder_name);<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;OwnerFile&gt; CreateOwner(const std::string&amp; folder_name);<br/>
&nbsp;&nbsp;static const boost::shared_ptr&lt;PointsFile&gt; CreatePoints(const std::string&amp; folder_name);<br/>
<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
};<br/>
<br/>
///Write all info to a single stream. Use CreateCopy to write all info<br/>
///to an OpenFOAM folder structure with multiple files<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Files&amp; files);<br/>
<br/>
bool operator==(const Files&amp; lhs, const Files&amp; rhs);<br/>
bool operator!=(const Files&amp; lhs, const Files&amp; rhs);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMFILES_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamfwd.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamfwd.h" border = "1"><tr><td><code>
#ifndef OPENFOAMFWD_H<br/>
#define OPENFOAMFWD_H<br/>
<br/>
namespace ribi {<br/>
<br/>
struct Coordinat3D;<br/>
<br/>
namespace foam {<br/>
<br/>
struct Boundary;<br/>
struct BoundaryFile;<br/>
struct BoundaryFileItem;<br/>
struct BoundaryIndex;<br/>
struct Cell;<br/>
struct CellIndex;<br/>
struct Face;<br/>
struct FaceIndex;<br/>
struct FacesFile;<br/>
struct FacesFileItem;<br/>
struct Filenames;<br/>
struct Files;<br/>
struct Header;<br/>
struct Mesh;<br/>
struct NeighbourFile;<br/>
struct NeighbourFileItem;<br/>
struct OwnerFile;<br/>
struct OwnerFileItem;<br/>
struct PointIndex;<br/>
struct PointsFile;<br/>
struct PointsFileItem;<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMFWD_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamheader.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamheader.cpp" border = "1"><tr><td><code>
#include "openfoamheader.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;ostream&gt;<br/>
#include &lt;sstream&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/algorithm/string/trim.hpp&gt;<br/>
<br/>
#include "fileio.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
ribi::foam::Header::Header(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; class_name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; location,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; note,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; object<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_class_name(class_name),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_location(location),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_note(note),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_object(object)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;assert( (location.empty() || location[0] != '\"' )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A location may not start with a quotation mark"<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;assert( (location.empty() || location[ location.size() - 1 ] != '\"' )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A location may not end with a quotation mark"<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
void ribi::foam::Header::CleanFile(<br/>
&nbsp;&nbsp;const std::string&amp; filename) noexcept<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;if(!fileio::IsRegularFile(filename))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;assert(fileio::IsRegularFile(filename));<br/>
&nbsp;&nbsp;//v is dirty<br/>
&nbsp;&nbsp;const std::vector&lt;std::string&gt; v { fileio::FileToVector(filename) };<br/>
&nbsp;&nbsp;//w will be clean<br/>
&nbsp;&nbsp;std::vector&lt;std::string&gt; w;<br/>
&nbsp;&nbsp;std::transform(v.begin(),v.end(),std::back_inserter(w),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](std::string s)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::replace(s.begin(),s.end(),'\t',' ');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::algorithm::trim(s);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s.size() &gt;= 2 &amp;&amp; s.substr(0,2) == "//") s = std::string();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;//w is clean<br/>
&nbsp;&nbsp;assert(fileio::IsRegularFile(filename));<br/>
&nbsp;&nbsp;fileio::VectorToFile(w,filename,fileio::CopyMode::allow_overwrite);<br/>
}<br/>
<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::Header::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::Header::Test");<br/>
&nbsp;&nbsp;const Header h("some_name","some_location","some_note","some_object");<br/>
&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;s &lt;&lt; h;<br/>
&nbsp;&nbsp;Header i;<br/>
&nbsp;&nbsp;s &gt;&gt; i;<br/>
&nbsp;&nbsp;if (h != i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(h);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(i);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(h == i);<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::Header::Test successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const ribi::foam::Header&amp; lhs, const ribi::foam::Header&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;if (lhs.GetClass() != rhs.GetClass())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Classes differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(lhs.GetClass());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(rhs.GetClass());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Compare location independent of OS path seperator<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string lhs_location = lhs.GetLocation();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string rhs_location = rhs.GetLocation();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::replace(lhs_location.begin(),lhs_location.end(),'\\','/');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::replace(rhs_location.begin(),rhs_location.end(),'\\','/');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (lhs_location != rhs_location)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Locations differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(lhs.GetLocation());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(rhs.GetLocation());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;if (lhs.GetObject() != rhs.GetObject())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE("Object differ:");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(lhs.GetObject());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(rhs.GetObject());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const ribi::foam::Header&amp; lhs, const ribi::foam::Header&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const Header&amp; f)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "FoamFile" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "{" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;version&nbsp;&nbsp;" &lt;&lt; "2.0"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; ";\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;format&nbsp;&nbsp; " &lt;&lt; "ascii"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; ";\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;" &lt;&lt; f.GetClass()&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ";\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;location \"" &lt;&lt; f.GetLocation() &lt;&lt; "\";\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "&nbsp;&nbsp;object&nbsp;&nbsp; " &lt;&lt; f.GetObject()&nbsp;&nbsp; &lt;&lt; ";\n"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "}" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, Header&amp; h)<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string title;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; title;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (title != "FoamFile")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(title.size() &gt;= 2);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Eat comment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (title.substr(0,2) == std::string("/*"))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (s.size() &lt; 2 || s.substr(s.size()-2,2) != std::string("*/"))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Try reading title after comment again<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; title;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (title != "FoamFile")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "Stream incorrectly assumed to be an OpenFOAM header. "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "OpenFOAM header start with 'FoamFile'. "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "This file starts with&nbsp;&nbsp;'"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; title &lt;&lt; "' instead";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::runtime_error(s.str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string bracket_open;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_open;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_open == "{");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;while (1)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (s == "version")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(t == "2.0;"&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (s == "format" )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(t == "ascii;");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (s == "class"&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string class_name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; class_name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(class_name.back() == ';');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_name.pop_back();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(class_name.back() != ';');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.m_class_name = class_name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (s == "location")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string location;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; location;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(location.size() &gt; 3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(location[0] == '\"');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(location[ location.size() - 2] == '\"');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(location[ location.size() - 1] == ';');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location = location.substr(1,location.size() - 3);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert( (location.empty() || location[0] != '\"' )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A location may not start with a quotation mark"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert( (location.empty() || location[ location.size() - 1 ] != '\"' )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A location may not end with a quotation mark"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert( (location.empty() || location[ location.size() - 1 ] != ';' )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A location may not end with a semicolon"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.m_location = location;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (s == "note")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Read until ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!s.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (s.back() != ';')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s += t;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(s.back() == ';');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.pop_back();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(s.back() != ';');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.m_note = s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (s == "object")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string object;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; object;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(object.back() == ';');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object.pop_back();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(object.back() != ';');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.m_object = object;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else if (s == "}")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamheader.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamheader.h" border = "1"><tr><td><code>
#ifndef OPENFOAMHEADER_H<br/>
#define OPENFOAMHEADER_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
#include &lt;string&gt;<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///The header that is above all OpenFoam files<br/>
struct Header<br/>
{<br/>
&nbsp;&nbsp;///In order of appearance in the text<br/>
&nbsp;&nbsp;explicit Header(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; class_name = "",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; location&nbsp;&nbsp; = "",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = "",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; object&nbsp;&nbsp;&nbsp;&nbsp; = ""<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;///Remove comments from a file<br/>
&nbsp;&nbsp;static void CleanFile(const std::string&amp; filename) noexcept;<br/>
<br/>
&nbsp;&nbsp;const std::string&amp; GetClass() const noexcept { return m_class_name; }<br/>
&nbsp;&nbsp;const std::string&amp; GetLocation() const noexcept { return m_location; }<br/>
&nbsp;&nbsp;const std::string&amp; GetNote() const noexcept { return m_note; }<br/>
&nbsp;&nbsp;const std::string&amp; GetObject() const noexcept { return m_object; }<br/>
<br/>
&nbsp;&nbsp;///A header consists out of multiple lines<br/>
&nbsp;&nbsp;///(1) header name<br/>
&nbsp;&nbsp;///(2) bracket open<br/>
&nbsp;&nbsp;///(3) version<br/>
&nbsp;&nbsp;///(4) format<br/>
&nbsp;&nbsp;///(5) class<br/>
&nbsp;&nbsp;///(6) location<br/>
&nbsp;&nbsp;///(7) object<br/>
&nbsp;&nbsp;///(8) bracket close<br/>
&nbsp;&nbsp;int GetNumberOfLines() const noexcept { return 8; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;std::string m_class_name;<br/>
&nbsp;&nbsp;std::string m_location;<br/>
&nbsp;&nbsp;std::string m_note;<br/>
&nbsp;&nbsp;std::string m_object;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Header&amp; h);<br/>
};<br/>
<br/>
bool operator==(const Header&amp; lhs, const Header&amp; rhs);<br/>
bool operator!=(const Header&amp; lhs, const Header&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Header&amp; f);<br/>
<br/>
///Read the header of an OpenFOAM file.<br/>
///Throws std::runtime_error if file is incorrectly formed<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Header&amp; h);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMHEADER_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoammesh.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoammesh.cpp" border = "1"><tr><td><code>
#include "openfoammesh.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;ostream&gt;<br/>
#include &lt;map&gt;<br/>
<br/>
#include "openfoamboundary.h"<br/>
#include "openfoamboundaryfile.h"<br/>
#include "openfoamboundaryfileitem.h"<br/>
#include "openfoamboundaryindex.h"<br/>
#include "openfoamcell.h"<br/>
#include "openfoamface.h"<br/>
#include "openfoamfacesfile.h"<br/>
#include "openfoamfiles.h"<br/>
#include "openfoamneighbourfile.h"<br/>
#include "openfoamownerfile.h"<br/>
#include "openfoampoint.h"<br/>
#include "openfoampointsfile.h"<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::Mesh::Mesh(<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Boundary&gt;&gt;&amp; boundaries,<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Cell&gt;&gt;&amp; cells,<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;&amp; faces,<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt;&amp; points<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_boundaries(boundaries),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_cells(cells),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces(faces),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points(points)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;for (const boost::shared_ptr&lt;Face&gt; face: m_faces)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face-&gt;GetOwner());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert( (face-&gt;GetNeighbour() || !face-&gt;GetNeighbour() )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "internalMesh faces have a neighbour, defaultWall faces don't"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;if (!AreFacesOrdered())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ReorderFaces();<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;assert(AreFacesOrdered());<br/>
&nbsp;&nbsp;const Files f(this-&gt;CreateFiles());<br/>
&nbsp;&nbsp;assert(f.GetFaces()-&gt;GetItems().size() == faces.size());<br/>
&nbsp;&nbsp;assert(f.GetBoundary()-&gt;GetItems().size() == boundaries.size());<br/>
&nbsp;&nbsp;assert(f.GetPoints()-&gt;GetItems().size() == points.size());<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
}<br/>
<br/>
ribi::foam::Mesh::Mesh(<br/>
&nbsp;&nbsp;const Files&amp; files,<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt;&amp; points<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_boundaries{},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_cells{CreateEmptyCells(files)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces{CreateFacesWithPoints(files,points)},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points(points)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;//Add Cell owner to Faces<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!m_cells.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex n_faces = files.GetFaces()-&gt;GetMaxFaceIndex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (FaceIndex i = FaceIndex(0); i!=n_faces; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex owner_cell_index { files.GetOwner()-&gt;GetItem(i).GetCellIndex() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (owner_cell_index.Get() &gt;= static_cast&lt;int&gt;(m_cells.size()))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(owner_cell_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(m_cells.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(owner_cell_index.Get() &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(owner_cell_index.Get() &lt; static_cast&lt;int&gt;(m_cells.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(m_cells[ owner_cell_index.Get() ]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; owner { m_cells[ owner_cell_index.Get() ] };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(owner);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!m_faces[i.Get()]-&gt;GetOwner() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_faces[i.Get()]-&gt;AssignOwner(owner);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert( m_faces[i.Get()]-&gt;GetOwner() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;for (const boost::shared_ptr&lt;Face&gt; face: m_faces) { assert(face); assert(face-&gt;GetOwner()); }<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;//Add owned Faces to Cells<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::map&lt;boost::shared_ptr&lt;Cell&gt;,std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;&gt; m;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (const boost::shared_ptr&lt;Face&gt; face: m_faces)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; owner { face-&gt;GetOwner() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(owner);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (!owner) continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m.find(owner) == m.end()) { m.insert(std::make_pair(owner, std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;() ) ); }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(m.find(owner) != m.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*m.find(owner)).second.push_back(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (auto p: m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.first-&gt;AssignOwnedFaces(p.second);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Add neighbours to Faces<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_faces = static_cast&lt;int&gt;(m_faces.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_faces; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex index(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(files.GetNeighbour());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Not all Faces have a neighbour<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!files.GetNeighbour()-&gt;CanGetItem(index)) continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(files.GetNeighbour()-&gt;CanGetItem(index));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex neighbour_index {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files.GetNeighbour()-&gt;GetItem(index).GetCellIndex()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(i &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; static_cast&lt;int&gt;(m_faces.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(neighbour_index.Get() &lt; static_cast&lt;int&gt;(m_cells.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!m_faces[i]-&gt;GetNeighbour());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_faces[i]-&gt;AssignNeighbour( m_cells[ neighbour_index.Get() ] );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(m_faces[i]-&gt;GetNeighbour());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Assign boundaries<br/>
&nbsp;&nbsp;m_boundaries = CreateBoundaries(files,m_faces);<br/>
<br/>
&nbsp;&nbsp;//Check<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;for (boost::shared_ptr&lt;Cell&gt; cell: m_cells)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(cell);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//assert( (cell-&gt;GetNeighbour() || !cell-&gt;GetNeighbour())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&amp;&amp; "Not all cells have a neighbour, for example in a 1x1x1 mesh");<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;if (GetNumberOfBoundaries() != files.GetBoundary()-&gt;GetMaxBoundaryIndex().Get())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(GetNumberOfBoundaries());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(files.GetBoundary()-&gt;GetMaxBoundaryIndex());<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(GetNumberOfBoundaries() == files.GetBoundary()-&gt;GetMaxBoundaryIndex().Get());<br/>
<br/>
&nbsp;&nbsp;assert(GetNumberOfFaces() == files.GetFaces()-&gt;GetMaxFaceIndex().Get());<br/>
}<br/>
<br/>
bool ribi::foam::Mesh::AreFacesOrdered() const noexcept<br/>
{<br/>
&nbsp;&nbsp;for (const boost::shared_ptr&lt;Boundary&gt; boundary: m_boundaries)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!boundary-&gt;GetFaces().empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_faces {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;int&gt;(boundary-&gt;GetFaces().size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(n_faces &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Determine the start face: at which indices are the Faces in m_faces?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; indices;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::transform(boundary-&gt;GetFaces().begin(),boundary-&gt;GetFaces().end(),std::back_inserter(indices),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[this](const boost::shared_ptr&lt;Face&gt; face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;::const_iterator iter {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::find(m_faces.begin(),m_faces.end(),face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(iter != m_faces.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int index = std::distance(m_faces.begin(),iter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index &lt; static_cast&lt;int&gt;(m_faces.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return index;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!indices.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(indices.size() == boundary-&gt;GetFaces().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::sort(indices.begin(),indices.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::size_t n_indices = indices.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (n_indices &gt; 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (std::size_t i=1; i!=n_indices; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indices[i-1] != indices[i]&nbsp;&nbsp;&amp;&amp; "All face indices must be unique");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (indices[i-1] + 1 != indices[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return true;<br/>
}<br/>
<br/>
double ribi::foam::Mesh::CalcSimilarityFaster(<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt;&amp; v,<br/>
&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; w) noexcept<br/>
{<br/>
&nbsp;&nbsp;if (v.size() != w.size()) return std::numeric_limits&lt;double&gt;::max();<br/>
&nbsp;&nbsp;//Sum all coordinats, distance equals the distance between the center points<br/>
&nbsp;&nbsp;const Coordinat3D a = std::accumulate(v.begin(),v.end(),Coordinat3D(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](const Coordinat3D&amp; init, const boost::shared_ptr&lt;const ribi::Coordinat3D&gt; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return init + (*c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;//for (const boost::shared_ptr&lt;const ribi::Coordinat3D&gt; c: v) { a += (*c); }<br/>
&nbsp;&nbsp;const Coordinat3D b = std::accumulate(w.begin(),w.end(),Coordinat3D());<br/>
&nbsp;&nbsp;return Distance(a,b);<br/>
}<br/>
<br/>
<br/>
double ribi::foam::Mesh::CalcSimilaritySlow(<br/>
&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; v,<br/>
&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; w) noexcept<br/>
{<br/>
&nbsp;&nbsp;if (v.size() != w.size()) return std::numeric_limits&lt;double&gt;::max();<br/>
&nbsp;&nbsp;const double distance {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::accumulate(v.begin(),v.end(),0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[w](const double init,const ribi::Coordinat3D&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find the closest coordinat in w to c<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;::const_iterator closest {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::min_element(w.begin(),w.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[c](const ribi::Coordinat3D&amp; lhs, const ribi::Coordinat3D&amp; rhs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Distance(lhs,c) &lt; Distance(rhs,c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return init + Distance(c,*closest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;return distance;<br/>
}<br/>
<br/>
double ribi::foam::Mesh::CalcSimilaritySlow(<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt;&amp; v,<br/>
&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; w) noexcept<br/>
{<br/>
&nbsp;&nbsp;if (v.size() != w.size()) return std::numeric_limits&lt;double&gt;::max();<br/>
&nbsp;&nbsp;const double distance {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::accumulate(v.begin(),v.end(),0.0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[w](const double init,const boost::shared_ptr&lt;const ribi::Coordinat3D&gt;&amp; c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Find the closest coordinat in w to c<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;::const_iterator closest {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::min_element(w.begin(),w.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[c](const ribi::Coordinat3D&amp; lhs, const ribi::Coordinat3D&amp; rhs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Distance(lhs,*c) &lt; Distance(rhs,*c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return init + Distance(*c,*closest);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;return distance;<br/>
}<br/>
<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;ribi::foam::Boundary&gt; &gt; ribi::foam::Mesh::CreateBoundaries(<br/>
&nbsp;&nbsp;const Files&amp; files,<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;&amp; all_faces<br/>
&nbsp;&nbsp;)<br/>
{<br/>
&nbsp;&nbsp;assert(files.GetFaces()-&gt;GetMaxFaceIndex().Get() == static_cast&lt;int&gt;(all_faces.size()));<br/>
<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;ribi::foam::Boundary&gt;&gt; boundaries;<br/>
<br/>
&nbsp;&nbsp;const BoundaryIndex n_boundaries = files.GetBoundary()-&gt;GetMaxBoundaryIndex();<br/>
&nbsp;&nbsp;for (BoundaryIndex i = BoundaryIndex(0); i!=n_boundaries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFileItem&amp; item { files.GetBoundary()-&gt;GetItem(i) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string name = item.GetName();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string type = item.GetType();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;Face&gt; &gt; faces;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex end_face { item.GetEndFace() } ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (FaceIndex face_index = item.GetStartFace(); face_index!=end_face; ++face_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int fi = face_index.Get();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(fi &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(fi &lt; static_cast&lt;int&gt;(all_faces.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faces.push_back(all_faces[fi]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Face belongs to Boundary<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Boundary&gt; boundary {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Boundary(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faces,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boundaries.push_back(boundary);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return boundaries;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::BoundaryFile&gt; ribi::foam::Mesh::CreateBoundary() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;BoundaryFileItem&gt; items;<br/>
<br/>
<br/>
&nbsp;&nbsp;for (const boost::shared_ptr&lt;Boundary&gt; boundary: m_boundaries)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!boundary-&gt;GetFaces().empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_faces {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;int&gt;(boundary-&gt;GetFaces().size())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(n_faces &gt; 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Determine the start face: at which indices are the Faces in m_faces?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt; indices;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::transform(boundary-&gt;GetFaces().begin(),boundary-&gt;GetFaces().end(),std::back_inserter(indices),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[this](const boost::shared_ptr&lt;Face&gt; face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;::const_iterator iter {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::find(m_faces.begin(),m_faces.end(),face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(iter != m_faces.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int index = std::distance(m_faces.begin(),iter);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index &lt; static_cast&lt;int&gt;(m_faces.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return index;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!indices.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(indices.size() == boundary-&gt;GetFaces().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::sort(indices.begin(),indices.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::size_t n_indices = indices.size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (n_indices &gt; 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (std::size_t i=1; i!=n_indices; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indices[i-1] != indices[i]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "All face indices must be unique");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (indices[i-1] + 1 != indices[i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(indices[i-1] + 1 == indices[i]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "All face indices must be adjacent");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex n_start_face = FaceIndex(indices[0]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//TRACE(n_start_face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const BoundaryFileItem item(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary-&gt;GetName(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundary-&gt;GetType(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_faces,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_start_face<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;items.push_back(item);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;BoundaryFile&gt; f {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new BoundaryFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundaryFile::GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(f);<br/>
&nbsp;&nbsp;return f;<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;ribi::foam::Cell&gt; &gt; ribi::foam::Mesh::CreateEmptyCells(<br/>
&nbsp;&nbsp;const Files&amp; files)<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;ribi::foam::Cell&gt; &gt; cells;<br/>
&nbsp;&nbsp;const CellIndex n_cells = files.GetNeighbour()-&gt;CountNumberOfCells();<br/>
&nbsp;&nbsp;assert(n_cells == files.GetOwner()-&gt;CountNumberOfCells());<br/>
&nbsp;&nbsp;assert(n_cells &gt; CellIndex(0));<br/>
&nbsp;&nbsp;for (CellIndex i=CellIndex(0); i!=n_cells; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; cell(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Cell<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;cells.push_back(cell);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(!cells.empty());<br/>
&nbsp;&nbsp;return cells;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::FacesFile&gt; ribi::foam::Mesh::CreateFaces() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;FacesFileItem&gt; items;<br/>
<br/>
&nbsp;&nbsp;//std::vector&lt;boost::shared_ptr&lt;const ribi::foam::Face&gt;&gt; faces;<br/>
&nbsp;&nbsp;std::transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(items),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[this](const boost::shared_ptr&lt;const Face&gt; face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt; points {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;face-&gt;GetPoints()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;PointIndex&gt; point_indices;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::transform(points.begin(),points.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(point_indices),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[this](boost::shared_ptr&lt;const ribi::Coordinat3D&gt; coordinat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt;::const_iterator iter {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::find(m_points.begin(),m_points.end(),coordinat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(iter != m_points.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int index {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::distance(m_points.begin(),iter)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index &lt; static_cast&lt;int&gt;(m_points.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return PointIndex(index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return FacesFileItem(point_indices);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FacesFile&gt; f {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new FacesFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FacesFile::GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(f);<br/>
&nbsp;&nbsp;return f;<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;ribi::foam::Face&gt;&gt; ribi::foam::Mesh::CreateFacesWithPoints(<br/>
&nbsp;&nbsp;const Files&amp; files,<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt;&amp; all_points)<br/>
{<br/>
&nbsp;&nbsp;const FaceIndex n_faces { files.GetFaces()-&gt;GetMaxFaceIndex() };<br/>
<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; faces;<br/>
&nbsp;&nbsp;for (FaceIndex i = FaceIndex(0); i!=n_faces; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;PointIndex&gt; point_indices {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files.GetFaces()-&gt;GetItem(i).GetPointIndices()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt; points;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (const PointIndex&amp; point_index: point_indices)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(point_index.Get() &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(point_index.Get() &lt; static_cast&lt;int&gt;(all_points.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points.push_back(all_points[point_index.Get() ]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Face&gt; face(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Face(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nullptr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nullptr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces.push_back(face);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(faces.size() == files.GetFaces()-&gt;GetItems().size());<br/>
&nbsp;&nbsp;return faces;<br/>
}<br/>
<br/>
ribi::foam::Files ribi::foam::Mesh::CreateFiles() const noexcept<br/>
{<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;BoundaryFile&gt; boundary {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreateBoundary()<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(boundary);<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;FacesFile&gt; faces {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreateFaces()<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(faces);<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;NeighbourFile&gt; neighbour {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreateNeighbour()<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(neighbour);<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;OwnerFile&gt; owner {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreateOwner()<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(owner);<br/>
&nbsp;&nbsp;boost::shared_ptr&lt;PointsFile&gt; points {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;CreatePoints()<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(points);<br/>
&nbsp;&nbsp;const Files f(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boundary,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;faces,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;neighbour,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;owner,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;points<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;return f;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::NeighbourFile&gt; ribi::foam::Mesh::CreateNeighbour() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;NeighbourFileItem&gt; v;<br/>
&nbsp;&nbsp;for (boost::shared_ptr&lt;Face&gt; face: m_faces)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const ribi::foam::Cell&gt; neighbour { face-&gt;GetNeighbour() };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert( (neighbour || !neighbour)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Not all cells have a neighbour, for example in a 1x1x1 mesh");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!neighbour) continue;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(std::find(m_cells.begin(),m_cells.end(),neighbour) != m_cells.end());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int index<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= std::distance(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_cells.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::find(m_cells.begin(),m_cells.end(),neighbour)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(index &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(index &lt; static_cast&lt;int&gt;(m_cells.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex cell_index(index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const NeighbourFileItem item(cell_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(item);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::foam::NeighbourFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new NeighbourFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NeighbourFile::GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::OwnerFile&gt; ribi::foam::Mesh::CreateOwner() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;OwnerFileItem&gt; items;<br/>
<br/>
&nbsp;&nbsp;std::transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(items),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[this](const boost::shared_ptr&lt;Face&gt; face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; owner = face-&gt;GetOwner();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(owner);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const auto iter = std::find(m_cells.begin(),m_cells.end(),owner);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(iter != m_cells.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int index = static_cast&lt;int&gt;(std::distance(m_cells.begin(),iter));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index &gt;= 0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(index &lt; static_cast&lt;int&gt;(m_cells.size()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex cell_index(index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return OwnerFileItem(cell_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;OwnerFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new OwnerFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OwnerFile::GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;ribi::foam::PointsFile&gt; ribi::foam::Mesh::CreatePoints() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;PointsFileItem&gt; items;<br/>
&nbsp;&nbsp;std::transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_points.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(items),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](const boost::shared_ptr&lt;ribi::Coordinat3D&gt; point)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(point);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return PointsFileItem(*point);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;PointsFile&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;new PointsFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointsFile::GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt; &gt;<br/>
&nbsp;&nbsp;ribi::foam::Mesh::CreatePoints(const Files&amp; files)<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt; &gt; v;<br/>
&nbsp;&nbsp;for (const PointsFileItem&amp; item: files.GetPoints()-&gt;GetItems())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static_assert(std::is_same&lt;PointsFileItem,Point&gt;(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Point is a typedef for PointsFileItem"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ribi::Coordinat3D(item.GetCoordinat())<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(p);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
const boost::shared_ptr&lt;const ribi::foam::Face&gt; ribi::foam::Mesh::FindMostSimilarFace(<br/>
&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; coordinats<br/>
&nbsp;&nbsp;) const<br/>
{<br/>
&nbsp;&nbsp;///Obtain the distance from focal coordinats to each face its coordinat<br/>
&nbsp;&nbsp;std::vector&lt;double&gt; distances;<br/>
&nbsp;&nbsp;const std::size_t sz = m_faces.size();<br/>
&nbsp;&nbsp;for (std::size_t i=0; i!=sz; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i &lt; m_faces.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(m_faces[i]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const double distance = CalcSimilarityFaster(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_faces[i]-&gt;GetPoints(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coordinats<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(distance);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;distances.push_back(distance);<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;//Find the most similar<br/>
&nbsp;&nbsp;const int index {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::distance(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distances.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::min_element(distances.begin(),distances.end())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;};<br/>
<br/>
&nbsp;&nbsp;//Return the face<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const ribi::foam::Face&gt; p {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces[index]<br/>
&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;assert(p);<br/>
&nbsp;&nbsp;return p;<br/>
}<br/>
<br/>
const std::vector&lt;boost::shared_ptr&lt;const ribi::foam::Face&gt; &gt; ribi::foam::Mesh::GetFaces() const noexcept<br/>
{<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;const ribi::foam::Face&gt; &gt; v;<br/>
&nbsp;&nbsp;std::transform(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_faces.begin(),m_faces.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(v),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](boost::shared_ptr&lt;ribi::foam::Face&gt; old_face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const ribi::foam::Face&gt; new_face(old_face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(old_face == new_face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new_face;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;return v;<br/>
}<br/>
<br/>
int ribi::foam::Mesh::GetNumberOfBoundaries() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(this-&gt;m_boundaries.size());<br/>
}<br/>
<br/>
int ribi::foam::Mesh::GetNumberOfCells() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(m_cells.size());<br/>
}<br/>
<br/>
int ribi::foam::Mesh::GetNumberOfFaces() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(m_faces.size());<br/>
}<br/>
<br/>
int ribi::foam::Mesh::GetNumberOfPoints() const noexcept<br/>
{<br/>
&nbsp;&nbsp;return static_cast&lt;int&gt;(m_points.size());<br/>
}<br/>
<br/>
void ribi::foam::Mesh::ReorderFaces()<br/>
{<br/>
&nbsp;&nbsp;assert(!this-&gt;AreFacesOrdered());<br/>
<br/>
&nbsp;&nbsp;const std::size_t n_boundaries = m_boundaries.size();<br/>
&nbsp;&nbsp;std::size_t new_face_index = 0; //The index to put the next Face at<br/>
&nbsp;&nbsp;for (std::size_t i=0; i!=n_boundaries; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Boundary&gt; boundary = m_boundaries[i];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::size_t n_faces = boundary-&gt;GetFaces().size();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (std::size_t j=0; j!=n_faces; ++j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(j &lt; boundary-&gt;GetFaces().size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt; &gt;::iterator here {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::find(m_faces.begin(),m_faces.end(),boundary-&gt;GetFaces()[j])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(here != m_faces.end());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::size_t old_face_index = std::distance(m_faces.begin(),here);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(old_face_index &gt;= new_face_index);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::swap(m_faces[old_face_index],m_faces[new_face_index]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++new_face_index;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
<br/>
<br/>
&nbsp;&nbsp;assert(this-&gt;AreFacesOrdered());<br/>
}<br/>
<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::Mesh::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::Mesh::Test");<br/>
&nbsp;&nbsp;//Check if the number of boundary faces is correct<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::foam::Files&gt;&gt; v { Files::CreateTestFiles() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(v.size() == 6);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;int&gt; n_internal_mesh_faces_expected { 0,0,1,4,12,133 };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(v.size() == n_internal_mesh_faces_expected.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int n_meshes = static_cast&lt;int&gt;(v.size());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int mesh_index = 0; mesh_index != n_meshes; ++mesh_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Mesh mesh(*v[mesh_index]);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const Face&gt; &gt; mesh_faces {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mesh.GetFaces()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int n_internal {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::count_if(mesh_faces.begin(),mesh_faces.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](const boost::shared_ptr&lt;const Face&gt; face)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face-&gt;GetOwner());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return face-&gt;GetNeighbour(); //internal faces have a neighbour<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(n_internal == n_internal_mesh_faces_expected[mesh_index]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Must have as much internal faces as expected"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//CalcSimilarity: empty<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;ribi::Coordinat3D&gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(CalcSimilarityFaster(v,w) &lt; 0.001);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//CalcSimilarity: one point<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;ribi::Coordinat3D&gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ribi::Coordinat3D c(1.1,2.2,3.3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; d {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ribi::Coordinat3D(c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(c == *d); //Exact comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Distance(c,*d) &lt; 0.0000001); //Fuzzier comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(CalcSimilarityFaster(v,w) &lt; 0.001);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//CalcSimilarity: two points<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;ribi::Coordinat3D&gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ribi::Coordinat3D c(1.1,2.2,3.3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; d {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ribi::Coordinat3D(c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(c == *d); //Exact comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Distance(c,*d) &lt; 0.0000001); //Fuzzier comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ribi::Coordinat3D c(2.2,3.3,4.4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; d {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ribi::Coordinat3D(c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(c == *d); //Exact comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Distance(c,*d) &lt; 0.0000001); //Fuzzier comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(CalcSimilarityFaster(v,w) &lt; 0.001);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//CalcSimilarity: one versus two points<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt; v;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;ribi::Coordinat3D&gt; w;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ribi::Coordinat3D c(1.1,2.2,3.3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; d {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ribi::Coordinat3D(c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(c == *d); //Exact comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(Distance(c,*d) &lt; 0.0000001); //Fuzzier comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.push_back(d);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const ribi::Coordinat3D c(2.2,3.3,4.4);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w.push_back(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(CalcSimilarityFaster(v,w) &gt; 1000000000.0);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Find most similar Faces<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Handcraft Faces, put these in mesh<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//For the Points, I used the same setup as in Classes/CppOpenFoam/points_1x1x1:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// 8((0 0 0) (1 0 0) (0 1 0) (1 1 0) (0 0 1) (1 0 1) (0 1 1) (1 1 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// The order of points is determined by blockMesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p0 { new ribi::Coordinat3D(0.0,0.0,0.0) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p1 { new ribi::Coordinat3D(1.0,0.0,0.0) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p2 { new ribi::Coordinat3D(0.0,1.0,0.0) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p3 { new ribi::Coordinat3D(1.0,1.0,0.0) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p4 { new ribi::Coordinat3D(0.0,0.0,1.0) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p5 { new ribi::Coordinat3D(1.0,0.0,1.0) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p6 { new ribi::Coordinat3D(0.0,1.0,1.0) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;ribi::Coordinat3D&gt; p7 { new ribi::Coordinat3D(1.0,1.0,1.0) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(p0); assert(p1); assert(p2); assert(p3);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(p4); assert(p5); assert(p6); assert(p7);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; cell { new Cell };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Cell&gt;&gt; cells { cell };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; n0; //No neighbours in a 1x1 mesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; n1; //No neighbours in a 1x1 mesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; n2; //No neighbours in a 1x1 mesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; n3; //No neighbours in a 1x1 mesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; n4; //No neighbours in a 1x1 mesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; n5; //No neighbours in a 1x1 mesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; own0 { cell }; //The only Cell owns all Faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; own1 { cell }; //The only Cell owns all Faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; own2 { cell }; //The only Cell owns all Faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; own3 { cell }; //The only Cell owns all Faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; own4 { cell }; //The only Cell owns all Faces<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Cell&gt; own5 { cell }; //The only Cell owns all Faces<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt; points { p0,p1,p2,p3,p4,p5,p6,p7 };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//For the Faces, I used the same setup as in Classes/CppOpenFoam/faces_1x1x1:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;6<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;4(0 2 3 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;4(0 4 6 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;4(0 1 5 4)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;4(1 3 7 5)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;4(2 6 7 3)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;4(4 5 7 6)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// The order of faces is determined by blockMesh<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Face&gt; f0 { new Face(n0,own0, { p0, p2, p3, p1 } ) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Face&gt; f1 { new Face(n1,own1, { p0, p4, p6, p2 } ) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Face&gt; f2 { new Face(n2,own2, { p0, p1, p5, p4 } ) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Face&gt; f3 { new Face(n3,own3, { p1, p3, p7, p5 } ) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Face&gt; f4 { new Face(n4,own4, { p2, p6, p7, p3 } ) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;Face&gt; f5 { new Face(n5,own5, { p4, p5, p7, p6 } ) };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; faces { f0,f1,f2,f3,f4,f5 };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;cell-&gt;AssignOwnedFaces( { f0,f1,f2,f3,f4,f5 } );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boost::shared_ptr&lt;Boundary&gt; boundary { new Boundary(&nbsp;&nbsp;{f0,f1,f2,f3,f4,f5 },"defaultFaces","patch" ) };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Boundary&gt;&gt; boundaries { boundary };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Mesh m(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundaries,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;faces,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (const boost::shared_ptr&lt;Face&gt; face: faces)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt;&gt; points { face-&gt;GetPoints() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;ribi::Coordinat3D&gt; coordinats;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::transform(points.begin(),points.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::back_inserter(coordinats),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](const boost::shared_ptr&lt;const ribi::Coordinat3D&gt; shared_coordinat)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ribi::Coordinat3D(*shared_coordinat);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//For every Face, extract the coordinats<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//FindMostSimilar should find back the original Face<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const boost::shared_ptr&lt;const ribi::foam::Face&gt; result {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.FindMostSimilarFace(coordinats)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(result);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (face != result)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(*face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(*result);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(result == face);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::Mesh::Test successfully");<br/>
}<br/>
#endif<br/>
<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const ribi::foam::Mesh&amp; mesh)<br/>
{<br/>
&nbsp;&nbsp;TRACE("Smallest: points");<br/>
&nbsp;&nbsp;os &lt;&lt; "Points: ";<br/>
&nbsp;&nbsp;for (boost::shared_ptr&lt;ribi::Coordinat3D&gt; point: mesh.m_points)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(point);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; "* " &lt;&lt; *point &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Small: faces");<br/>
&nbsp;&nbsp;os &lt;&lt; "Faces:\n";<br/>
&nbsp;&nbsp;for (boost::shared_ptr&lt;Face&gt; face: mesh.m_faces)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "* Neighbour: " &lt;&lt; face-&gt;GetNeighbour() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "* Owner: " &lt;&lt; face-&gt;GetOwner() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "* Coordinats: ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for(boost::shared_ptr&lt;const ribi::Coordinat3D&gt; coordinat: face-&gt;GetPoints())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; coordinat &lt;&lt; ' ';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Bigger: boundaries");<br/>
&nbsp;&nbsp;os &lt;&lt; "Boundary:\n";<br/>
&nbsp;&nbsp;for (boost::shared_ptr&lt;Boundary&gt; boundary: mesh.m_boundaries)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "* Name: " &lt;&lt; boundary-&gt;GetName() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "* Type: " &lt;&lt; boundary-&gt;GetType() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "* Faces: ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (const boost::shared_ptr&lt;const Face&gt; face: boundary-&gt;GetFaces())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; face &lt;&lt; ' ';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;TRACE("Biggest: cells");<br/>
&nbsp;&nbsp;os &lt;&lt; "Cells:\n";<br/>
&nbsp;&nbsp;for (const boost::shared_ptr&lt;Cell&gt; cell: mesh.m_cells)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&lt;&lt; "* Neighbour: " &lt;&lt; cell-&gt;GetNeighbour() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; "* Faces: ";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (boost::shared_ptr&lt;const ribi::foam::Face&gt; face: cell-&gt;GetOwnedFaces())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; face &lt;&lt; ' ';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoammesh.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoammesh.h" border = "1"><tr><td><code>
#ifndef OPENFOAMMESH_H<br/>
#define OPENFOAMMESH_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
#include &lt;boost/shared_ptr.hpp&gt;<br/>
#include "openfoamfwd.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///Mesh contains the mesh of an OpenFOAM mesh in an indexless way<br/>
///A Mesh can be converted to a Files and vice versa<br/>
struct Mesh<br/>
{<br/>
&nbsp;&nbsp;///Step #0<br/>
&nbsp;&nbsp;///Create Points so these can be shared over the Faces<br/>
&nbsp;&nbsp;///Create Cells so these can be shared over the Faces<br/>
&nbsp;&nbsp;Mesh(const Files&amp; files) : Mesh(files,CreatePoints(files)) {}<br/>
<br/>
&nbsp;&nbsp;Mesh(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Boundary&gt;&gt;&amp; boundaries,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Cell&gt;&gt;&amp; cells,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;&amp; faces,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt;&amp; points<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;///Write the Mesh to a Files<br/>
&nbsp;&nbsp;Files CreateFiles() const noexcept;<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;const Face&gt; FindMostSimilarFace(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; coordinats<br/>
&nbsp;&nbsp;) const;<br/>
<br/>
&nbsp;&nbsp;int GetNumberOfBoundaries() const noexcept;<br/>
&nbsp;&nbsp;int GetNumberOfCells() const noexcept;<br/>
&nbsp;&nbsp;int GetNumberOfFaces() const noexcept;<br/>
&nbsp;&nbsp;int GetNumberOfPoints() const noexcept;<br/>
<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Boundary&gt; &gt;&amp; GetBoundaries() noexcept { return m_boundaries; }<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;Cell&gt; &gt;&amp; GetCells() noexcept { return&nbsp;&nbsp;m_cells; }<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Face&gt; &gt;&amp; GetFaces()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noexcept { return m_faces; }<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const Face&gt; &gt;&nbsp;&nbsp;GetFaces() const noexcept;<br/>
&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt;&amp; GetPoints() noexcept { return m_points; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;///Order is not important<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;Boundary&gt;&gt; m_boundaries;<br/>
<br/>
&nbsp;&nbsp;///Order is not important<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;Cell&gt;&gt; m_cells;<br/>
<br/>
&nbsp;&nbsp;///Order is important for ReorderFaces only<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt; m_faces;<br/>
<br/>
&nbsp;&nbsp;///Order is not important<br/>
&nbsp;&nbsp;std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt; m_points;<br/>
<br/>
&nbsp;&nbsp;///Step #1<br/>
&nbsp;&nbsp;///Create Faces so these can be shared over Boundary and Cell<br/>
&nbsp;&nbsp;Mesh(const Files&amp; files,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt;&amp; points);<br/>
<br/>
&nbsp;&nbsp;///Checks if the Faces their indices are adjacent<br/>
&nbsp;&nbsp;///when they belong to the<br/>
&nbsp;&nbsp;///same Boundary<br/>
&nbsp;&nbsp;bool AreFacesOrdered() const noexcept;<br/>
<br/>
&nbsp;&nbsp;static double CalcSimilaritySlow(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; v,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; w) noexcept;<br/>
<br/>
&nbsp;&nbsp;static double CalcSimilarityFaster(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt;&amp; v,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; w) noexcept;<br/>
<br/>
&nbsp;&nbsp;static double CalcSimilaritySlow(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;const ribi::Coordinat3D&gt; &gt;&amp; v,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;ribi::Coordinat3D&gt;&amp; w) noexcept;<br/>
<br/>
&nbsp;&nbsp;static const std::vector&lt;boost::shared_ptr&lt;Boundary&gt; &gt; CreateBoundaries(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files&amp; files, const std::vector&lt;boost::shared_ptr&lt;Face&gt;&gt;&amp; faces);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;BoundaryFile&gt; CreateBoundary() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Create empty Cells, as much as needed<br/>
&nbsp;&nbsp;static const std::vector&lt;boost::shared_ptr&lt;Cell&gt; &gt; CreateEmptyCells(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files&amp; files);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;FacesFile&gt; CreateFaces() const noexcept;<br/>
<br/>
&nbsp;&nbsp;///Create the Faces from the points, but cannot initialize Owner and Neighbour<br/>
&nbsp;&nbsp;static const std::vector&lt;boost::shared_ptr&lt;Face&gt; &gt; CreateFacesWithPoints(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Files&amp; files,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt;&gt;&amp; points);<br/>
<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;NeighbourFile&gt; CreateNeighbour() const noexcept;<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;OwnerFile&gt; CreateOwner() const noexcept;<br/>
&nbsp;&nbsp;const boost::shared_ptr&lt;PointsFile&gt; CreatePoints() const noexcept;<br/>
<br/>
&nbsp;&nbsp;static const std::vector&lt;boost::shared_ptr&lt;ribi::Coordinat3D&gt; &gt; CreatePoints(const Files&amp; files);<br/>
<br/>
&nbsp;&nbsp;///This member function is called to reorder the faces in such a way<br/>
&nbsp;&nbsp;///that indices in m_faces are adjacent when they belong to the<br/>
&nbsp;&nbsp;///same Boundary<br/>
&nbsp;&nbsp;///<br/>
&nbsp;&nbsp;///For example, consider the following boundary file:<br/>
&nbsp;&nbsp;///<br/>
&nbsp;&nbsp;///2<br/>
&nbsp;&nbsp;///(<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;boundary_left<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0;<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;boundary_right<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;patch;<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;nFaces&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;&nbsp;&nbsp;startFace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2;<br/>
&nbsp;&nbsp;///&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;///)<br/>
&nbsp;&nbsp;///<br/>
&nbsp;&nbsp;///ReorderFaces will put the faces belonging to 'boundary_left'<br/>
&nbsp;&nbsp;///at indices 0 and 1, and the faces belonging to 'boundary_right'<br/>
&nbsp;&nbsp;///at indices 2 and 3.<br/>
&nbsp;&nbsp;///<br/>
&nbsp;&nbsp;///Because this is an indexless structure, the ordering of Faces in<br/>
&nbsp;&nbsp;///m_faces is unimportant, except for this: when writing to file<br/>
&nbsp;&nbsp;void ReorderFaces();<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Mesh&amp; mesh);<br/>
};<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Mesh&amp; mesh);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMMESH_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamneighbourfile.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamneighbourfile.cpp" border = "1"><tr><td><code>
#include "openfoamneighbourfile.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<br/>
#include &lt;boost/algorithm/string/trim.hpp&gt;<br/>
#include &lt;boost/algorithm/string/split.hpp&gt;<br/>
#include &lt;boost/lexical_cast.hpp&gt;<br/>
<br/>
#include &lt;QFile&gt;<br/>
<br/>
#include "filename.h"<br/>
#include "fileio.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoamneighbourfileitem.h"<br/>
#include "openfoamfaceindex.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
<br/>
ribi::foam::NeighbourFile::NeighbourFile(<br/>
&nbsp;&nbsp;const Header header,<br/>
&nbsp;&nbsp;const std::vector&lt;NeighbourFileItem&gt;&amp; items)<br/>
&nbsp;&nbsp;: m_header{header},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items(items)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
bool ribi::foam::NeighbourFile::CanGetItem(<br/>
&nbsp;&nbsp;const FaceIndex&amp; face_index) const noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(face_index.Get() &gt;= 0);<br/>
&nbsp;&nbsp;return face_index.Get() &lt; static_cast&lt;int&gt;(m_items.size());<br/>
}<br/>
<br/>
/*<br/>
const ribi::foam::CellIndex ribi::foam::NeighbourFile::CountNumberOfCells() const noexcept<br/>
{<br/>
&nbsp;&nbsp;//NOT CONFIDENT ABOUT THIS<br/>
&nbsp;&nbsp;if (m_items.empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return CellIndex(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//throw std::logic_error(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;"NeighbourFile::FindMaxCellIndex: there is no valid cell index");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert( (!m_items.empty() || m_items.empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "If a mesh has no non-boundary cells, neighbour can be empty");<br/>
<br/>
&nbsp;&nbsp;CellIndex i = (*std::max_element(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](const NeighbourFileItem&amp; lhs, const NeighbourFileItem&amp; rhs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return lhs.GetCellIndex() &lt; rhs.GetCellIndex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;)).GetCellIndex();<br/>
&nbsp;&nbsp;//TRACE(m_items.size());<br/>
&nbsp;&nbsp;//TRACE(i);<br/>
&nbsp;&nbsp;++i;<br/>
&nbsp;&nbsp;return i;<br/>
}<br/>
*/<br/>
<br/>
const ribi::foam::Header ribi::foam::NeighbourFile::GetDefaultHeader() noexcept<br/>
{<br/>
&nbsp;&nbsp;return Header("labelList","constant/polyMesh","","neighbour");<br/>
}<br/>
<br/>
const ribi::foam::NeighbourFileItem&amp; ribi::foam::NeighbourFile::GetItem(<br/>
&nbsp;&nbsp;const FaceIndex&amp; face_index) const noexcept<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;if(!CanGetItem(face_index))<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE("BREAK");<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;assert(CanGetItem(face_index));<br/>
&nbsp;&nbsp;return m_items[ static_cast&lt;int&gt;(face_index.Get()) ];<br/>
}<br/>
<br/>
const ribi::foam::NeighbourFile ribi::foam::NeighbourFile::Parse(std::istream&amp; is)<br/>
{<br/>
&nbsp;&nbsp;NeighbourFile b;<br/>
&nbsp;&nbsp;is &gt;&gt; b;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return b;<br/>
}<br/>
<br/>
const ribi::foam::NeighbourFile ribi::foam::NeighbourFile::Parse(const std::string&amp; filename)<br/>
{<br/>
&nbsp;&nbsp;const std::string tmp_filename { fileio::GetTempFileName() };<br/>
&nbsp;&nbsp;fileio::CopyFile(filename,tmp_filename);<br/>
&nbsp;&nbsp;Header::CleanFile(tmp_filename);<br/>
&nbsp;&nbsp;std::ifstream f(tmp_filename.c_str());<br/>
&nbsp;&nbsp;const NeighbourFile file { Parse(f) };<br/>
&nbsp;&nbsp;f.close();<br/>
&nbsp;&nbsp;fileio::DeleteFile(tmp_filename);<br/>
&nbsp;&nbsp;return file;<br/>
}<br/>
<br/>
void ribi::foam::NeighbourFile::SetItem(const FaceIndex&amp; face_index, const NeighbourFileItem&amp; item) noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(face_index.Get() &gt;= 0);<br/>
&nbsp;&nbsp;assert(face_index.Get() &lt; static_cast&lt;int&gt;(m_items.size()));<br/>
&nbsp;&nbsp;m_items[ face_index.Get() ] = item;<br/>
&nbsp;&nbsp;assert(GetItem(face_index) == item);<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::NeighbourFile::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::NeighbourFile::Test");<br/>
&nbsp;&nbsp;//Some initial data<br/>
&nbsp;&nbsp;const Header header("some_name","some_location","some_object");<br/>
&nbsp;&nbsp;std::vector&lt;NeighbourFileItem&gt; items;<br/>
&nbsp;&nbsp;for (int i=1; i!=4; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NeighbourFileItem item(CellIndex(i * i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;items.push_back(item);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator==<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const NeighbourFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const NeighbourFile c(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header == header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const NeighbourFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header other_header("some_other_name","some_other_location","some_other_object");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header != other_header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const NeighbourFile c(other_header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const NeighbourFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;NeighbourFileItem&gt; other_items;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=1; i!=3; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NeighbourFileItem item(CellIndex(2 * i * i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const NeighbourFile c(header,other_items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Stream conversion<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const NeighbourFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NeighbourFile c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (b != c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Read from testing file<br/>
&nbsp;&nbsp;for (int test_index = 0; test_index!=5; ++test_index)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;switch (test_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: filename_appendix = "_1x1x1"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: filename_appendix = "_1x1x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: filename_appendix = "_1x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: filename_appendix = "_2x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: filename_appendix = "_3x4x5"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Should never get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("foam::Files::CreateTestFiles: unknown test index");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!filename_appendix.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename_base { GetDefaultHeader().GetObject() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename = filename_base + filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string resources_path { ":/CppOpenFoam/files/" + filename };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QFile f( resources_path.c_str() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.copy(filename.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!fileio::IsRegularFile(filename))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(fileio::IsRegularFile(filename));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NeighbourFile b(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert( (!b.GetItems().empty() || b.GetItems().empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "If a mesh has no non-bhoundary cells, neighbour can be empty");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::Header::NeighbourFile successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const NeighbourFile&amp; lhs,const NeighbourFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;if (lhs.GetHeader() != rhs.GetHeader())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const std::vector&lt;NeighbourFileItem&gt;&amp; lhs_items = lhs.GetItems();<br/>
&nbsp;&nbsp;const std::vector&lt;NeighbourFileItem&gt;&amp; rhs_items = rhs.GetItems();<br/>
&nbsp;&nbsp;if (lhs_items.size() != rhs_items.size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return std::equal(lhs_items.begin(),lhs_items.end(),rhs_items.begin());<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const NeighbourFile&amp; lhs,const NeighbourFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, NeighbourFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;assert(f.m_items.empty()); //Make empty otherwise<br/>
<br/>
&nbsp;&nbsp;//Read header<br/>
&nbsp;&nbsp;is &gt;&gt; f.m_header;<br/>
&nbsp;&nbsp;assert(is);<br/>
<br/>
&nbsp;&nbsp;//Read items<br/>
&nbsp;&nbsp;int n_items = 0;<br/>
&nbsp;&nbsp;char opening_bracket = '\0';<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Eat comment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char c = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (c &gt;= '0' &amp;&amp; c &lt;= '9')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (c != '(' &amp;&amp; c != '{')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Start eating n_items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items *= 10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int n = c - '0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(n &gt;= 0 &amp;&amp; n &lt;= 9);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items += n;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;opening_bracket = c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(opening_bracket == '(' || opening_bracket == '{'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(opening_bracket);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;if (opening_bracket == '(')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NeighbourFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '{');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Read once, push n_items times<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NeighbourFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Eat comments until bracket close<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_close = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (bracket_close != ')' &amp;&amp; bracket_close != '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_close == ')' || bracket_close == '}');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (opening_bracket == '(' &amp;&amp; bracket_close == ')')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (opening_bracket == '{' &amp;&amp; bracket_close == '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const NeighbourFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.GetHeader() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.m_items.size() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "(" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;for(const NeighbourFileItem item: f.m_items)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; item &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ")" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamneighbourfile.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamneighbourfile.h" border = "1"><tr><td><code>
#ifndef OPENFOAMNEIGHBOURFILE_H<br/>
#define OPENFOAMNEIGHBOURFILE_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "fileiofwd.h"<br/>
#include "openfoamfwd.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoamneighbourfileitem.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///Reads and writes an OpenFOAM boundary file<br/>
struct NeighbourFile<br/>
{<br/>
&nbsp;&nbsp;explicit NeighbourFile(const std::string&amp; filename) : NeighbourFile(Parse(filename)) {}<br/>
&nbsp;&nbsp;explicit NeighbourFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header header = GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;NeighbourFileItem&gt;&amp; items = {});<br/>
<br/>
&nbsp;&nbsp;///If the FaceIndex is present<br/>
&nbsp;&nbsp;bool CanGetItem(const FaceIndex&amp; face_index) const noexcept;<br/>
<br/>
&nbsp;&nbsp;//DON'T: Use OwnerFile::CountNumberOfCells instead<br/>
&nbsp;&nbsp;//WHY: because all cell indices are detected in owner<br/>
&nbsp;&nbsp;///Find the first CellIndex beyond the cell indices present<br/>
&nbsp;&nbsp;///Or: find the first CellIndex that does not exist anymore<br/>
&nbsp;&nbsp;//const CellIndex CountNumberOfCells() const noexcept;<br/>
<br/>
&nbsp;&nbsp;static const Header GetDefaultHeader() noexcept;<br/>
&nbsp;&nbsp;const Header&amp; GetHeader() const noexcept { return m_header; }<br/>
&nbsp;&nbsp;const std::vector&lt;NeighbourFileItem&gt; GetItems() const noexcept { return m_items; }<br/>
<br/>
&nbsp;&nbsp;///Assumes CanGetItem == true<br/>
&nbsp;&nbsp;const NeighbourFileItem&amp; GetItem(const FaceIndex&amp; face_index) const noexcept;<br/>
<br/>
&nbsp;&nbsp;int GetNumberOfItems() const noexcept { return static_cast&lt;int&gt;(m_items.size()); }<br/>
<br/>
&nbsp;&nbsp;void SetItem(const FaceIndex&amp; face_index, const NeighbourFileItem&amp; item) noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;explicit NeighbourFile(std::istream&amp; is) : NeighbourFile(Parse(is)) {}<br/>
<br/>
&nbsp;&nbsp;///The OpenFOAM header<br/>
&nbsp;&nbsp;Header m_header;<br/>
&nbsp;&nbsp;///The items 'neighbour' contains<br/>
&nbsp;&nbsp;std::vector&lt;NeighbourFileItem&gt; m_items;<br/>
<br/>
&nbsp;&nbsp;static const NeighbourFile Parse(std::istream&amp; is);<br/>
&nbsp;&nbsp;static const NeighbourFile Parse(const std::string&amp; filename);<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NeighbourFile&amp; f);<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, NeighbourFile&amp; f);<br/>
};<br/>
<br/>
bool operator==(const NeighbourFile&amp; lhs,const NeighbourFile&amp; rhs);<br/>
bool operator!=(const NeighbourFile&amp; lhs,const NeighbourFile&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NeighbourFile&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, NeighbourFile&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMNEIGHBOURFILE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamneighbourfileitem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamneighbourfileitem.cpp" border = "1"><tr><td><code>
#include "openfoamneighbourfileitem.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::NeighbourFileItem::NeighbourFileItem(<br/>
&nbsp;&nbsp;const CellIndex cell_index<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_cell_index{cell_index}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;assert(m_cell_index.Get() &gt;= -1 &amp;&amp; "Also allow -1"); //?NONSENSE or not?<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::NeighbourFileItem::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::NeighbourFileItem::Test");<br/>
&nbsp;&nbsp;const NeighbourFileItem i(CellIndex(123));<br/>
&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;s &lt;&lt; i;<br/>
&nbsp;&nbsp;NeighbourFileItem j;<br/>
&nbsp;&nbsp;s &gt;&gt; j;<br/>
&nbsp;&nbsp;if (i != j)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TRACE(j);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(i == j);<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::NeighbourFileItem::Test successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const NeighbourFileItem&amp; lhs, const NeighbourFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetCellIndex() == rhs.GetCellIndex()<br/>
&nbsp;&nbsp;;<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const NeighbourFileItem&amp; lhs, const NeighbourFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const NeighbourFileItem&amp; item)<br/>
{<br/>
&nbsp;&nbsp;os &lt;&lt; item.GetCellIndex();<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, NeighbourFileItem&amp; f)<br/>
{<br/>
&nbsp;&nbsp;is &gt;&gt; f.m_cell_index;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;assert(f.GetCellIndex().Get() &gt;= -1);<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamneighbourfileitem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamneighbourfileitem.h" border = "1"><tr><td><code>
#ifndef OPENFOAMNEIGHBOURFILEITEM_H<br/>
#define OPENFOAMNEIGHBOURFILEITEM_H<br/>
<br/>
#include &lt;vector&gt;<br/>
#include &lt;iosfwd&gt;<br/>
#include "openfoamcellindex.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///An item in an OpenFOAM 'neighbour' file<br/>
///A neighbour files contains, for every face, the cell index of which the face is a neighbour of<br/>
///<br/>
///For example, from /Classes/CppOpenFoam/neighbour_1x2x2:<br/>
///<br/>
///4(1 2 3 3)<br/>
///<br/>
///Equivalent to, as faces_1x2x2 contains twenty faces:<br/>
///<br/>
///20(1 2 3 3 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1)<br/>
///<br/>
///This means that:<br/>
/// - Face 0 has Cell 1 as its neighbour, and is thus an internal face<br/>
/// - Face 1 has Cell 2 as its neighbour, and is thus an internal face<br/>
/// - Face 2 has Cell 3 as its neighbour, and is thus an internal face<br/>
/// - Face 3 has Cell 3 as its neighbour, and is thus an internal face<br/>
/// - All other Faces have no neighbours, and are thus boundary faces<br/>
///<br/>
///The file 'neighbour' has path '[case_folder]/constant/polyMesh/neighbour'<br/>
struct NeighbourFileItem<br/>
{<br/>
&nbsp;&nbsp;///A CellIndex of -1 denotes that a Face has no Neighbour<br/>
&nbsp;&nbsp;explicit NeighbourFileItem(const CellIndex cell_index = CellIndex(-1));<br/>
<br/>
&nbsp;&nbsp;///A CellIndex of -1 denotes that a Face has no Neighbour<br/>
&nbsp;&nbsp;const CellIndex GetCellIndex() const noexcept { return m_cell_index; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;CellIndex m_cell_index;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend class OpenFoamNeighbourFile;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, NeighbourFileItem&amp; f);<br/>
};<br/>
<br/>
bool operator==(const NeighbourFileItem&amp; lhs, const NeighbourFileItem&amp; rhs);<br/>
bool operator!=(const NeighbourFileItem&amp; lhs, const NeighbourFileItem&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NeighbourFileItem&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, NeighbourFileItem&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMNEIGHBOURFILEITEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamownerfile.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamownerfile.cpp" border = "1"><tr><td><code>
#include "openfoamownerfile.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<br/>
#include &lt;boost/algorithm/string/trim.hpp&gt;<br/>
#include &lt;boost/algorithm/string/split.hpp&gt;<br/>
#include &lt;boost/lexical_cast.hpp&gt;<br/>
<br/>
#include &lt;QFile&gt;<br/>
<br/>
#include "filename.h"<br/>
#include "fileio.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoamfaceindex.h"<br/>
#include "openfoamownerfileitem.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
<br/>
ribi::foam::OwnerFile::OwnerFile(<br/>
&nbsp;&nbsp;const Header header,<br/>
&nbsp;&nbsp;const std::vector&lt;OwnerFileItem&gt;&amp; items)<br/>
&nbsp;&nbsp;: m_header{header},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items(items)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
const ribi::foam::CellIndex ribi::foam::OwnerFile::CountNumberOfCells() const noexcept<br/>
{<br/>
&nbsp;&nbsp;assert(!m_items.empty());<br/>
<br/>
&nbsp;&nbsp;const CellIndex i = (*std::max_element(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items.begin(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items.end(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[](const OwnerFileItem&amp; lhs, const OwnerFileItem&amp; rhs)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return lhs.GetCellIndex() &lt; rhs.GetCellIndex();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;)).GetCellIndex();<br/>
<br/>
&nbsp;&nbsp;// +1, because if the highest cell index found is x, there are x+1 cells<br/>
&nbsp;&nbsp;return i + 1;<br/>
}<br/>
<br/>
const ribi::foam::Header ribi::foam::OwnerFile::GetDefaultHeader() noexcept<br/>
{<br/>
&nbsp;&nbsp;return Header("labelList","constant/polyMesh","","owner");<br/>
}<br/>
<br/>
const ribi::foam::OwnerFileItem&amp; ribi::foam::OwnerFile::GetItem(<br/>
&nbsp;&nbsp;const ribi::foam::FaceIndex&amp; face_index) const noexcept<br/>
{<br/>
&nbsp;&nbsp;const int i = face_index.Get();<br/>
&nbsp;&nbsp;assert(i &lt; static_cast&lt;int&gt;(m_items.size()));<br/>
&nbsp;&nbsp;return m_items[i];<br/>
}<br/>
<br/>
const ribi::foam::OwnerFile ribi::foam::OwnerFile::Parse(std::istream&amp; is)<br/>
{<br/>
&nbsp;&nbsp;OwnerFile b;<br/>
&nbsp;&nbsp;is &gt;&gt; b;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return b;<br/>
}<br/>
<br/>
const ribi::foam::OwnerFile ribi::foam::OwnerFile::Parse(const std::string&amp; filename)<br/>
{<br/>
&nbsp;&nbsp;const std::string tmp_filename { fileio::GetTempFileName() };<br/>
&nbsp;&nbsp;fileio::CopyFile(filename,tmp_filename);<br/>
&nbsp;&nbsp;Header::CleanFile(tmp_filename);<br/>
&nbsp;&nbsp;std::ifstream f(tmp_filename.c_str());<br/>
&nbsp;&nbsp;const OwnerFile file { Parse(f) };<br/>
&nbsp;&nbsp;f.close();<br/>
&nbsp;&nbsp;fileio::DeleteFile(tmp_filename);<br/>
&nbsp;&nbsp;return file;<br/>
}<br/>
<br/>
void ribi::foam::OwnerFile::SetItem(const FaceIndex&amp; face_index, const OwnerFileItem&amp; item) noexcept<br/>
{<br/>
&nbsp;&nbsp;const int i = face_index.Get();<br/>
&nbsp;&nbsp;assert(i &lt; static_cast&lt;int&gt;(m_items.size()));<br/>
&nbsp;&nbsp;m_items[i] = item;<br/>
&nbsp;&nbsp;assert(m_items[i] == item);<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::OwnerFile::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::OwnerFile::Test");<br/>
&nbsp;&nbsp;//Some initial data<br/>
&nbsp;&nbsp;const Header header("some_name","some_location","some_object");<br/>
&nbsp;&nbsp;std::vector&lt;OwnerFileItem&gt; items;<br/>
&nbsp;&nbsp;for (int i=1; i!=4; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OwnerFileItem item(CellIndex(i * i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;items.push_back(item);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator==<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFile c(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header == header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header other_header("some_other_name","some_other_location","some_other_object");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header != other_header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFile c(other_header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;OwnerFileItem&gt; other_items;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=1; i!=3; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OwnerFileItem item(CellIndex(2 * i * i));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFile c(header,other_items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OwnerFile c(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const FaceIndex i(1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const CellIndex j { c.GetItem(i).GetCellIndex() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFileItem new_item(CellIndex(j.Get() + 1));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(c.GetItem(i) != new_item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;c.SetItem(i,new_item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(c.GetItem(i) == new_item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Stream conversion<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OwnerFile c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (b != c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Read from testing file<br/>
&nbsp;&nbsp;for (int test_index = 0; test_index!=5; ++test_index)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;switch (test_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: filename_appendix = "_1x1x1"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: filename_appendix = "_1x1x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: filename_appendix = "_1x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: filename_appendix = "_2x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: filename_appendix = "_3x4x5"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Should never get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("foam::Files::CreateTestFiles: unknown test index");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!filename_appendix.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename_base { GetDefaultHeader().GetObject() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename = filename_base + filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string resources_path { ":/CppOpenFoam/files/" + filename };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QFile f( resources_path.c_str() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.copy(filename.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!fileio::IsRegularFile(filename))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(fileio::IsRegularFile(filename));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OwnerFile b(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (b.GetItems().empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!b.GetItems().empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::Header::OwnerFile successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const OwnerFile&amp; lhs,const OwnerFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;if (lhs.GetHeader() != rhs.GetHeader())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const std::vector&lt;OwnerFileItem&gt;&amp; lhs_items = lhs.GetItems();<br/>
&nbsp;&nbsp;const std::vector&lt;OwnerFileItem&gt;&amp; rhs_items = rhs.GetItems();<br/>
&nbsp;&nbsp;if (lhs_items.size() != rhs_items.size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return std::equal(lhs_items.begin(),lhs_items.end(),rhs_items.begin());<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const OwnerFile&amp; lhs,const OwnerFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, OwnerFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;assert(f.m_items.empty()); //Make empty otherwise<br/>
<br/>
&nbsp;&nbsp;//Read header<br/>
&nbsp;&nbsp;is &gt;&gt; f.m_header;<br/>
&nbsp;&nbsp;assert(is);<br/>
<br/>
&nbsp;&nbsp;//Read items<br/>
&nbsp;&nbsp;int n_items = 0;<br/>
&nbsp;&nbsp;char opening_bracket = '\0';<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Eat comment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char c = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (c &gt;= '0' &amp;&amp; c &lt;= '9')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (c != '(' &amp;&amp; c != '{')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Start eating n_items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items *= 10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int n = c - '0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(n &gt;= 0 &amp;&amp; n &lt;= 9);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items += n;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;opening_bracket = c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(opening_bracket == '(' || opening_bracket == '{'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(opening_bracket);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;if (opening_bracket == '(')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OwnerFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '{');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Read once, push n_items times<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OwnerFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Eat comments until bracket close<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_close = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (bracket_close != ')' &amp;&amp; bracket_close != '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_close == ')' || bracket_close == '}');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (opening_bracket == '(' &amp;&amp; bracket_close == ')')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (opening_bracket == '{' &amp;&amp; bracket_close == '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const OwnerFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.GetHeader() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.m_items.size() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "(" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;for(const OwnerFileItem item: f.m_items)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; item &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ")" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamownerfile.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamownerfile.h" border = "1"><tr><td><code>
#ifndef OPENFOAMOWNERFILE_H<br/>
#define OPENFOAMOWNERFILE_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "fileiofwd.h"<br/>
#include "openfoamfwd.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoamownerfileitem.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///Reads and writes an OpenFOAM boundary file<br/>
struct OwnerFile<br/>
{<br/>
&nbsp;&nbsp;explicit OwnerFile(const std::string&amp; filename) : OwnerFile(Parse(filename)) {}<br/>
&nbsp;&nbsp;explicit OwnerFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header header = GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;OwnerFileItem&gt;&amp; items = {});<br/>
<br/>
&nbsp;&nbsp;///Find the first CellIndex beyond the cell indices present<br/>
&nbsp;&nbsp;///Or: find the first CellIndex that does not exist anymore<br/>
&nbsp;&nbsp;const CellIndex CountNumberOfCells() const noexcept;<br/>
<br/>
&nbsp;&nbsp;static const Header GetDefaultHeader() noexcept;<br/>
&nbsp;&nbsp;const Header&amp; GetHeader() const noexcept { return m_header; }<br/>
&nbsp;&nbsp;const std::vector&lt;OwnerFileItem&gt; GetItems() const noexcept { return m_items; }<br/>
&nbsp;&nbsp;const OwnerFileItem&amp; GetItem(const FaceIndex&amp; face_index) const noexcept;<br/>
<br/>
<br/>
&nbsp;&nbsp;void SetItem(const FaceIndex&amp; face_index, const OwnerFileItem&amp; item) noexcept;<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;///The OpenFOAM header<br/>
&nbsp;&nbsp;Header m_header;<br/>
&nbsp;&nbsp;///The items 'neighbour' contains<br/>
&nbsp;&nbsp;std::vector&lt;OwnerFileItem&gt; m_items;<br/>
<br/>
&nbsp;&nbsp;explicit OwnerFile(std::istream&amp; is) : OwnerFile(Parse(is)) {}<br/>
&nbsp;&nbsp;static const OwnerFile Parse(std::istream&amp; is);<br/>
&nbsp;&nbsp;static const OwnerFile Parse(const std::string&amp; filename);<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const OwnerFile&amp; f);<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, OwnerFile&amp; f);<br/>
};<br/>
<br/>
bool operator==(const OwnerFile&amp; lhs,const OwnerFile&amp; rhs);<br/>
bool operator!=(const OwnerFile&amp; lhs,const OwnerFile&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const OwnerFile&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, OwnerFile&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMOWNERFILE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamownerfileitem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamownerfileitem.cpp" border = "1"><tr><td><code>
#include "openfoamownerfileitem.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::OwnerFileItem::OwnerFileItem(<br/>
&nbsp;&nbsp;const CellIndex&amp; cell_index<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_cell_index{cell_index}<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;assert(m_cell_index.Get() &gt;= 0);<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::OwnerFileItem::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::OwnerFileItem::Test");<br/>
&nbsp;&nbsp;//operator==<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFileItem i(CellIndex(123));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i == i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFileItem j(CellIndex(123));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i == j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(j == i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(j == j);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFileItem i(CellIndex(123));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFileItem j(CellIndex(234));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i != j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(j != i);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator&lt;&lt; and operator&gt;&gt;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const OwnerFileItem i(CellIndex(123));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;OwnerFileItem j;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; j;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (i != j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i == j);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::OwnerFileItem::Test successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const OwnerFileItem&amp; lhs, const OwnerFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lhs.GetCellIndex() == rhs.GetCellIndex()<br/>
&nbsp;&nbsp;;<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const OwnerFileItem&amp; lhs, const OwnerFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const OwnerFileItem&amp; item)<br/>
{<br/>
&nbsp;&nbsp;os &lt;&lt; item.GetCellIndex();<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, OwnerFileItem&amp; f)<br/>
{<br/>
&nbsp;&nbsp;is &gt;&gt; f.m_cell_index;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;if (f.GetCellIndex().Get() &lt; 0) TRACE(f.GetCellIndex());<br/>
&nbsp;&nbsp;assert(f.GetCellIndex().Get() &gt;= 0);<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamownerfileitem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamownerfileitem.h" border = "1"><tr><td><code>
#ifndef OPENFOAMOWNERFILEITEM_H<br/>
#define OPENFOAMOWNERFILEITEM_H<br/>
<br/>
#include &lt;vector&gt;<br/>
#include &lt;iosfwd&gt;<br/>
#include "openfoamcellindex.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///An item in an OpenFOAM boundary file<br/>
struct OwnerFileItem<br/>
{<br/>
&nbsp;&nbsp;explicit OwnerFileItem(const CellIndex&amp; cell_index = CellIndex(0));<br/>
<br/>
&nbsp;&nbsp;CellIndex GetCellIndex() const noexcept { return m_cell_index; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;CellIndex m_cell_index;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend class OpenFoamOwnerFile;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, OwnerFileItem&amp; f);<br/>
};<br/>
<br/>
bool operator==(const OwnerFileItem&amp; lhs, const OwnerFileItem&amp; rhs);<br/>
bool operator!=(const OwnerFileItem&amp; lhs, const OwnerFileItem&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const OwnerFileItem&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, OwnerFileItem&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMOWNERFILEITEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamparseerror.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamparseerror.cpp" border = "1"><tr><td><code>
#include "openfoamparseerror.h"<br/>
<br/>
#include &lt;sstream&gt;<br/>
<br/>
ribi::foam::ParseError::ParseError(<br/>
&nbsp;&nbsp;const std::string&amp; filename,<br/>
&nbsp;&nbsp;const int line)<br/>
: std::runtime_error(CreateErrorMsg(filename,line).c_str()),<br/>
&nbsp;&nbsp;m_filename(filename),<br/>
&nbsp;&nbsp;m_line(line)<br/>
{<br/>
<br/>
}<br/>
<br/>
const std::string ribi::foam::ParseError::CreateErrorMsg(<br/>
&nbsp;&nbsp;const std::string&amp; filename,<br/>
&nbsp;&nbsp;const int line) noexcept<br/>
{<br/>
&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;s &lt;&lt; "OpenFOAM file parsing error in ";<br/>
&nbsp;&nbsp;if (filename.empty())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "unknown file";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "file '" &lt;&lt; filename &lt;&lt; "'";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;s &lt;&lt; " in ";<br/>
&nbsp;&nbsp;if (line &lt; 0)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "unknown line";<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; "line " &lt;&lt; line;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return s.str();<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoamparseerror.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoamparseerror.h" border = "1"><tr><td><code>
#ifndef OPENFOAMPARSEERROR_H<br/>
#define OPENFOAMPARSEERROR_H<br/>
<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
struct ParseError : public std::runtime_error<br/>
{<br/>
&nbsp;&nbsp;explicit ParseError(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; filename = "",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int line = -1);<br/>
<br/>
&nbsp;&nbsp;const std::string m_filename;<br/>
&nbsp;&nbsp;const int m_line;<br/>
<br/>
&nbsp;&nbsp;const std::string CreateErrorMsg(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string&amp; filename,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const int line) noexcept;<br/>
};<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMPARSEERROR_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoampoint.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoampoint.cpp" border = "1"><tr><td><code>
#include "openfoampoint.h"<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoampoint.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoampoint.h" border = "1"><tr><td><code>
#ifndef OPENFOAMPOINT_H<br/>
#define OPENFOAMPOINT_H<br/>
<br/>
#include "openfoampointsfileitem.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
typedef PointsFileItem Point;<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
<br/>
#endif // OPENFOAMPOINT_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoampointindex.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoampointindex.cpp" border = "1"><tr><td><code>
#include "openfoampointindex.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
<br/>
ribi::foam::PointIndex::PointIndex(const int index)<br/>
&nbsp;&nbsp;: m_index(index)<br/>
{<br/>
&nbsp;&nbsp;assert(m_index &gt;= 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "A PointIndex must be zero or a positive value");<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const PointIndex&amp; face_index)<br/>
{<br/>
&nbsp;&nbsp;os &lt;&lt; face_index.Get();<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, PointIndex&amp; face_index)<br/>
{<br/>
&nbsp;&nbsp;is &gt;&gt; face_index.m_index;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
bool ribi::foam::operator==(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() == rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
bool ribi::foam::operator&lt;(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() &lt; rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator&gt;(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return lhs.Get() &gt; rhs.Get();<br/>
}<br/>
<br/>
bool ribi::foam::operator&lt;=(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs &gt; rhs);<br/>
}<br/>
<br/>
bool ribi::foam::operator&gt;=(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept<br/>
{<br/>
&nbsp;&nbsp;return !(lhs &lt; rhs);<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoampointindex.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoampointindex.h" border = "1"><tr><td><code>
#ifndef OPENFOAMPOINTINDEX_H<br/>
#define OPENFOAMPOINTINDEX_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///The index in the 'points' file<br/>
struct PointIndex<br/>
{<br/>
&nbsp;&nbsp;explicit PointIndex(const int index = 0);<br/>
&nbsp;&nbsp;int Get() const noexcept { return m_index; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;int m_index;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, PointIndex&amp; face_index);<br/>
};<br/>
<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const PointIndex&amp; face_index);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, PointIndex&amp; face_index);<br/>
<br/>
bool operator==(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept;<br/>
bool operator!=(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept;<br/>
bool operator&lt;(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept;<br/>
bool operator&gt;(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept;<br/>
bool operator&lt;=(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept;<br/>
bool operator&gt;=(const PointIndex&amp; lhs, const PointIndex&amp; rhs) noexcept;<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMPOINTINDEX_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoampointsfile.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoampointsfile.cpp" border = "1"><tr><td><code>
#include "openfoampointsfile.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;fstream&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;stdexcept&gt;<br/>
<br/>
#pragma GCC diagnostic push<br/>
#pragma GCC diagnostic ignored "-Weffc++"<br/>
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"<br/>
<br/>
#include &lt;boost/algorithm/string/trim.hpp&gt;<br/>
#include &lt;boost/algorithm/string/split.hpp&gt;<br/>
#include &lt;boost/lexical_cast.hpp&gt;<br/>
<br/>
#include &lt;QFile&gt;<br/>
<br/>
#include "fileio.h"<br/>
#include "filename.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoampointsfileitem.h"<br/>
#include "trace.h"<br/>
#pragma GCC diagnostic pop<br/>
<br/>
<br/>
ribi::foam::PointsFile::PointsFile(<br/>
&nbsp;&nbsp;const Header header,<br/>
&nbsp;&nbsp;const std::vector&lt;PointsFileItem&gt;&amp; items)<br/>
&nbsp;&nbsp;: m_header{header},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;m_items(items)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
const ribi::foam::Header ribi::foam::PointsFile::GetDefaultHeader() noexcept<br/>
{<br/>
&nbsp;&nbsp;return Header("vectorField","constant/polyMesh","","points");<br/>
}<br/>
<br/>
const ribi::foam::PointsFile ribi::foam::PointsFile::Parse(std::istream&amp; is)<br/>
{<br/>
&nbsp;&nbsp;PointsFile b;<br/>
&nbsp;&nbsp;is &gt;&gt; b;<br/>
&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;return b;<br/>
}<br/>
<br/>
const ribi::foam::PointsFile ribi::foam::PointsFile::Parse(const std::string&amp; filename)<br/>
{<br/>
&nbsp;&nbsp;const std::string tmp_filename { fileio::GetTempFileName() };<br/>
&nbsp;&nbsp;fileio::CopyFile(filename,tmp_filename);<br/>
&nbsp;&nbsp;Header::CleanFile(tmp_filename);<br/>
&nbsp;&nbsp;std::ifstream f(tmp_filename.c_str());<br/>
&nbsp;&nbsp;ribi::foam::PointsFile file { Parse(f) };<br/>
&nbsp;&nbsp;f.close();<br/>
&nbsp;&nbsp;fileio::DeleteFile(tmp_filename);<br/>
&nbsp;&nbsp;return file;<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::PointsFile::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::PointsFile::Test");<br/>
&nbsp;&nbsp;//Some initial data<br/>
&nbsp;&nbsp;const Header header("some_name","some_location","some_object");<br/>
&nbsp;&nbsp;std::vector&lt;PointsFileItem&gt; items;<br/>
&nbsp;&nbsp;for (int i=1; i!=4; ++i)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PointsFileItem item(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat3D(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;double&gt;(i) * 1.1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;double&gt;(i) * 2.2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;double&gt;(i) * 3.3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;items.push_back(item);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator==<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFile c(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header == header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header other_header("some_other_name","some_other_location","some_other_object");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(header != other_header);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFile c(other_header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;PointsFileItem&gt; other_items;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=1; i!=3; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointsFileItem item(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat3D(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;double&gt;(i) * 4.4,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;double&gt;(i) * 5.5,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static_cast&lt;double&gt;(i) * 6.6<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFile c(header,other_items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b != c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Stream conversion<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFile b(header,items);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; b;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PointsFile c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (b != c)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(b);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(c);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(b == c);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Read from testing file<br/>
&nbsp;&nbsp;for (int test_index = 0; test_index!=5; ++test_index)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;switch (test_index)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: filename_appendix = "_1x1x1"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: filename_appendix = "_1x1x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: filename_appendix = "_1x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: filename_appendix = "_2x2x2"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4: filename_appendix = "_3x4x5"; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: assert(!"Should never get here");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw std::logic_error("foam::Files::CreateTestFiles: unknown test index");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(!filename_appendix.empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename_base { GetDefaultHeader().GetObject() };<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string filename = filename_base + filename_appendix;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::string resources_path { ":/CppOpenFoam/files/" + filename };<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QFile f( resources_path.c_str() );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.copy(filename.c_str());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!fileio::IsRegularFile(filename))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(fileio::IsRegularFile(filename));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointsFile b(filename);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (b.GetItems().empty())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(!b.GetItems().empty());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::Header::PointsFile successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const PointsFile&amp; lhs,const PointsFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;if (lhs.GetHeader() != rhs.GetHeader())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;const std::vector&lt;PointsFileItem&gt;&amp; lhs_items = lhs.GetItems();<br/>
&nbsp;&nbsp;const std::vector&lt;PointsFileItem&gt;&amp; rhs_items = rhs.GetItems();<br/>
&nbsp;&nbsp;if (lhs_items.size() != rhs_items.size())<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return std::equal(lhs_items.begin(),lhs_items.end(),rhs_items.begin());<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const PointsFile&amp; lhs,const PointsFile&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, PointsFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;assert(f.m_items.empty()); //Make empty otherwise<br/>
<br/>
&nbsp;&nbsp;//Read header<br/>
&nbsp;&nbsp;is &gt;&gt; f.m_header;<br/>
&nbsp;&nbsp;assert(is);<br/>
<br/>
&nbsp;&nbsp;//Read items<br/>
&nbsp;&nbsp;int n_items = 0;<br/>
&nbsp;&nbsp;char opening_bracket = '\0';<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Eat comment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char c = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (c &gt;= '0' &amp;&amp; c &lt;= '9')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (c != '(' &amp;&amp; c != '{')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Start eating n_items<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items *= 10;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const int n = c - '0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(n &gt;= 0 &amp;&amp; n &lt;= 9);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_items += n;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;opening_bracket = c;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(opening_bracket == '(' || opening_bracket == '{'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(opening_bracket);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE("ERROR");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;#endif<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;assert(opening_bracket == '(' || opening_bracket == '{');<br/>
&nbsp;&nbsp;if (opening_bracket == '(')<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PointsFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;else<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(opening_bracket == '{');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;//Read once, push n_items times<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PointsFileItem item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; item;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i!=n_items; ++i)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.m_items.push_back(item);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//Eat comments until bracket close<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_close = '\0';<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (bracket_close != ')' &amp;&amp; bracket_close != '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_close == ')' || bracket_close == '}');<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (opening_bracket == '(' &amp;&amp; bracket_close == ')')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (opening_bracket == '{' &amp;&amp; bracket_close == '}')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const PointsFile&amp; f)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.GetHeader() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; f.m_items.size() &lt;&lt; '\n'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "(" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;for(const PointsFileItem item: f.m_items)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;os &lt;&lt; item &lt;&lt; '\n';<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ")" &lt;&lt; '\n'<br/>
&nbsp;&nbsp;;<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoampointsfile.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoampointsfile.h" border = "1"><tr><td><code>
#ifndef OPENFOAMPOINTSFILE_H<br/>
#define OPENFOAMPOINTSFILE_H<br/>
<br/>
#include &lt;iosfwd&gt;<br/>
#include &lt;string&gt;<br/>
#include &lt;vector&gt;<br/>
#include "fileiofwd.h"<br/>
#include "openfoamfwd.h"<br/>
#include "openfoamheader.h"<br/>
#include "openfoampointsfileitem.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///Reads and writes an OpenFOAM boundary file<br/>
struct PointsFile<br/>
{<br/>
&nbsp;&nbsp;explicit PointsFile(const std::string&amp; filename) : PointsFile(Parse(filename)) {}<br/>
&nbsp;&nbsp;explicit PointsFile(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Header header = GetDefaultHeader(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const std::vector&lt;PointsFileItem&gt;&amp; items = {});<br/>
<br/>
&nbsp;&nbsp;static const Header GetDefaultHeader() noexcept;<br/>
&nbsp;&nbsp;const Header&amp; GetHeader() const noexcept { return m_header; }<br/>
&nbsp;&nbsp;const std::vector&lt;PointsFileItem&gt;&amp; GetItems() const noexcept { return m_items; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
&nbsp;&nbsp;explicit PointsFile(std::istream&amp; is) : PointsFile(Parse(is)) {}<br/>
<br/>
&nbsp;&nbsp;///The OpenFOAM header<br/>
&nbsp;&nbsp;Header m_header;<br/>
&nbsp;&nbsp;///The items faces contains<br/>
&nbsp;&nbsp;std::vector&lt;PointsFileItem&gt; m_items;<br/>
<br/>
&nbsp;&nbsp;static const PointsFile Parse(std::istream&amp; is);<br/>
&nbsp;&nbsp;static const PointsFile Parse(const std::string&amp; filename);<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const PointsFile&amp; f);<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, PointsFile&amp; f);<br/>
};<br/>
<br/>
bool operator==(const PointsFile&amp; lhs,const PointsFile&amp; rhs);<br/>
bool operator!=(const PointsFile&amp; lhs,const PointsFile&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const PointsFile&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, PointsFile&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
#endif // OPENFOAMPOINTSFILE_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoampointsfileitem.cpp</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoampointsfileitem.cpp" border = "1"><tr><td><code>
#include "openfoampointsfileitem.h"<br/>
<br/>
#include &lt;cassert&gt;<br/>
#include &lt;iostream&gt;<br/>
#include &lt;sstream&gt;<br/>
#include "fuzzy_equal_to.h"<br/>
#include "trace.h"<br/>
<br/>
ribi::foam::PointsFileItem::PointsFileItem(<br/>
&nbsp;&nbsp;const Coordinat3D&amp; coordinat<br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;: m_coordinat(coordinat)<br/>
{<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;Test();<br/>
&nbsp;&nbsp;#endif<br/>
}<br/>
<br/>
#ifndef NDEBUG<br/>
void ribi::foam::PointsFileItem::Test() noexcept<br/>
{<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;static bool is_tested = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (is_tested) return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is_tested = true;<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Starting ribi::foam::PointsFileItem::Test");<br/>
&nbsp;&nbsp;//operator== and operator!=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFileItem i( Coordinat3D(1.1,2.2,3.3) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PointsFileItem j( Coordinat3D(2.2,3.3,4.4) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i == i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i != j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(j != i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(j == j);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;//operator&lt;&lt; and operator&gt;&gt;<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const PointsFileItem i( Coordinat3D(1.1,2.2,3.3) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &lt;&lt; i;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;PointsFileItem j;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;s &gt;&gt; j;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (i != j)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(i);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRACE(j);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(i == j);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;TRACE("Finished ribi::foam::PointsFileItem::Test successfully");<br/>
}<br/>
#endif<br/>
<br/>
bool ribi::foam::operator==(const PointsFileItem&amp; lhs, const PointsFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;const double abs_tolerance = 0.001;<br/>
&nbsp;&nbsp;return<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuzzy_equal_to_abs(abs_tolerance)(lhs.GetCoordinat().GetX(),rhs.GetCoordinat().GetX())<br/>
&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; fuzzy_equal_to_abs(abs_tolerance)(lhs.GetCoordinat().GetY(),rhs.GetCoordinat().GetY())<br/>
&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; fuzzy_equal_to_abs(abs_tolerance)(lhs.GetCoordinat().GetZ(),rhs.GetCoordinat().GetZ())<br/>
&nbsp;&nbsp;;<br/>
}<br/>
<br/>
bool ribi::foam::operator!=(const PointsFileItem&amp; lhs, const PointsFileItem&amp; rhs)<br/>
{<br/>
&nbsp;&nbsp;return !(lhs == rhs);<br/>
}<br/>
<br/>
std::ostream&amp; ribi::foam::operator&lt;&lt;(std::ostream&amp; os, const PointsFileItem&amp; item)<br/>
{<br/>
&nbsp;&nbsp;os<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "("<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; item.GetCoordinat().GetX() &lt;&lt; " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; item.GetCoordinat().GetY() &lt;&lt; " "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; item.GetCoordinat().GetZ()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; ")"<br/>
&nbsp;&nbsp;;<br/>
<br/>
&nbsp;&nbsp;return os;<br/>
}<br/>
<br/>
std::istream&amp; ribi::foam::operator&gt;&gt;(std::istream&amp; is, PointsFileItem&amp; f)<br/>
{<br/>
<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_open;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_open;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_open == '(');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double d = 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; d;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f.m_coordinat.SetX(d);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double d = 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; d;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f.m_coordinat.SetY(d);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;double d = 0.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; d;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;f.m_coordinat.SetZ(d);<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;char bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;is &gt;&gt; bracket_close;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(is);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assert(bracket_close == ')');<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;return is;<br/>
}<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/openfoampointsfileitem.h</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/openfoampointsfileitem.h" border = "1"><tr><td><code>
#ifndef OPENFOAMPOINTSFILEITEM_H<br/>
#define OPENFOAMPOINTSFILEITEM_H<br/>
<br/>
#include &lt;array&gt;<br/>
#include &lt;vector&gt;<br/>
#include &lt;iosfwd&gt;<br/>
<br/>
#include "coordinat3d.h"<br/>
<br/>
namespace ribi {<br/>
namespace foam {<br/>
<br/>
///An item in an OpenFOAM 'points' file<br/>
struct PointsFileItem<br/>
{<br/>
&nbsp;&nbsp;explicit PointsFileItem(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Coordinat3D&amp; coordinat = Coordinat3D(0.0, 0.0, 0.0)<br/>
&nbsp;&nbsp;);<br/>
<br/>
&nbsp;&nbsp;const Coordinat3D&amp; GetCoordinat() const noexcept { return m_coordinat; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Coordinat3D&amp; GetCoordinat()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noexcept { return m_coordinat; }<br/>
<br/>
&nbsp;&nbsp;private:<br/>
<br/>
&nbsp;&nbsp;Coordinat3D m_coordinat;<br/>
<br/>
&nbsp;&nbsp;#ifndef NDEBUG<br/>
&nbsp;&nbsp;static void Test() noexcept;<br/>
&nbsp;&nbsp;#endif<br/>
<br/>
&nbsp;&nbsp;friend class OpenFoamPointsFile;<br/>
&nbsp;&nbsp;friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, PointsFileItem&amp; f);<br/>
};<br/>
<br/>
bool operator==(const PointsFileItem&amp; lhs, const PointsFileItem&amp; rhs);<br/>
bool operator!=(const PointsFileItem&amp; lhs, const PointsFileItem&amp; rhs);<br/>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const PointsFileItem&amp; f);<br/>
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, PointsFileItem&amp; f);<br/>
<br/>
} //~namespace foam<br/>
} //~namespace ribi<br/>
<br/>
<br/>
<br/>
#endif // OPENFOAMPOINTSFILEITEM_H<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/owner_1x1x1</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/owner_1x1x1" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 8 nCells: 1 nFaces: 6 nInternalFaces: 0";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
6{0}<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/owner_1x1x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/owner_1x1x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 12 nCells: 2 nFaces: 11 nInternalFaces: 1";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
11<br/>
(<br/>
0<br/>
0<br/>
0<br/>
1<br/>
0<br/>
1<br/>
0<br/>
1<br/>
0<br/>
1<br/>
1<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/owner_1x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/owner_1x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 18 nCells: 4 nFaces: 20 nInternalFaces: 4";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
20<br/>
(<br/>
0<br/>
0<br/>
1<br/>
2<br/>
0<br/>
1<br/>
0<br/>
1<br/>
2<br/>
3<br/>
0<br/>
2<br/>
0<br/>
1<br/>
2<br/>
3<br/>
1<br/>
3<br/>
2<br/>
3<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/owner_2x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/owner_2x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 27 nCells: 8 nFaces: 36 nInternalFaces: 12";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
36<br/>
(<br/>
0<br/>
0<br/>
0<br/>
1<br/>
1<br/>
2<br/>
2<br/>
3<br/>
4<br/>
4<br/>
5<br/>
6<br/>
0<br/>
2<br/>
1<br/>
3<br/>
0<br/>
2<br/>
4<br/>
6<br/>
0<br/>
4<br/>
1<br/>
5<br/>
1<br/>
3<br/>
5<br/>
7<br/>
2<br/>
6<br/>
3<br/>
7<br/>
4<br/>
6<br/>
5<br/>
7<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/owner_3x4x5</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/owner_3x4x5" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labelList;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;note&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"nPoints: 120 nCells: 60 nFaces: 227 nInternalFaces: 133";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
227<br/>
(<br/>
0<br/>
0<br/>
0<br/>
1<br/>
1<br/>
1<br/>
2<br/>
2<br/>
3<br/>
3<br/>
3<br/>
4<br/>
4<br/>
4<br/>
5<br/>
5<br/>
6<br/>
6<br/>
6<br/>
7<br/>
7<br/>
7<br/>
8<br/>
8<br/>
9<br/>
9<br/>
10<br/>
10<br/>
11<br/>
12<br/>
12<br/>
12<br/>
13<br/>
13<br/>
13<br/>
14<br/>
14<br/>
15<br/>
15<br/>
15<br/>
16<br/>
16<br/>
16<br/>
17<br/>
17<br/>
18<br/>
18<br/>
18<br/>
19<br/>
19<br/>
19<br/>
20<br/>
20<br/>
21<br/>
21<br/>
22<br/>
22<br/>
23<br/>
24<br/>
24<br/>
24<br/>
25<br/>
25<br/>
25<br/>
26<br/>
26<br/>
27<br/>
27<br/>
27<br/>
28<br/>
28<br/>
28<br/>
29<br/>
29<br/>
30<br/>
30<br/>
30<br/>
31<br/>
31<br/>
31<br/>
32<br/>
32<br/>
33<br/>
33<br/>
34<br/>
34<br/>
35<br/>
36<br/>
36<br/>
36<br/>
37<br/>
37<br/>
37<br/>
38<br/>
38<br/>
39<br/>
39<br/>
39<br/>
40<br/>
40<br/>
40<br/>
41<br/>
41<br/>
42<br/>
42<br/>
42<br/>
43<br/>
43<br/>
43<br/>
44<br/>
44<br/>
45<br/>
45<br/>
46<br/>
46<br/>
47<br/>
48<br/>
48<br/>
49<br/>
49<br/>
50<br/>
51<br/>
51<br/>
52<br/>
52<br/>
53<br/>
54<br/>
54<br/>
55<br/>
55<br/>
56<br/>
57<br/>
58<br/>
0<br/>
3<br/>
6<br/>
9<br/>
1<br/>
4<br/>
7<br/>
10<br/>
2<br/>
5<br/>
8<br/>
11<br/>
0<br/>
3<br/>
6<br/>
9<br/>
12<br/>
15<br/>
18<br/>
21<br/>
24<br/>
27<br/>
30<br/>
33<br/>
36<br/>
39<br/>
42<br/>
45<br/>
48<br/>
51<br/>
54<br/>
57<br/>
0<br/>
12<br/>
24<br/>
36<br/>
48<br/>
1<br/>
13<br/>
25<br/>
37<br/>
49<br/>
2<br/>
14<br/>
26<br/>
38<br/>
50<br/>
2<br/>
5<br/>
8<br/>
11<br/>
14<br/>
17<br/>
20<br/>
23<br/>
26<br/>
29<br/>
32<br/>
35<br/>
38<br/>
41<br/>
44<br/>
47<br/>
50<br/>
53<br/>
56<br/>
59<br/>
9<br/>
21<br/>
33<br/>
45<br/>
57<br/>
10<br/>
22<br/>
34<br/>
46<br/>
58<br/>
11<br/>
23<br/>
35<br/>
47<br/>
59<br/>
48<br/>
51<br/>
54<br/>
57<br/>
49<br/>
52<br/>
55<br/>
58<br/>
50<br/>
53<br/>
56<br/>
59<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/points_1x1x1</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/points_1x1x1" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vectorField;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
8((0 0 0) (1 0 0) (0 1 0) (1 1 0) (0 0 1) (1 0 1) (0 1 1) (1 1 1))<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/points_1x1x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/points_1x1x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vectorField;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
12<br/>
(<br/>
(0 0 0)<br/>
(1 0 0)<br/>
(0 1 0)<br/>
(1 1 0)<br/>
(0 0 0.5)<br/>
(1 0 0.5)<br/>
(0 1 0.5)<br/>
(1 1 0.5)<br/>
(0 0 1)<br/>
(1 0 1)<br/>
(0 1 1)<br/>
(1 1 1)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/points_1x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/points_1x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vectorField;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
18<br/>
(<br/>
(0 0 0)<br/>
(1 0 0)<br/>
(0 0.5 0)<br/>
(1 0.5 0)<br/>
(0 1 0)<br/>
(1 1 0)<br/>
(0 0 0.5)<br/>
(1 0 0.5)<br/>
(0 0.5 0.5)<br/>
(1 0.5 0.5)<br/>
(0 1 0.5)<br/>
(1 1 0.5)<br/>
(0 0 1)<br/>
(1 0 1)<br/>
(0 0.5 1)<br/>
(1 0.5 1)<br/>
(0 1 1)<br/>
(1 1 1)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/points_2x2x2</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/points_2x2x2" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vectorField;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
27<br/>
(<br/>
(0 0 0)<br/>
(0.5 0 0)<br/>
(1 0 0)<br/>
(0 0.5 0)<br/>
(0.5 0.5 0)<br/>
(1 0.5 0)<br/>
(0 1 0)<br/>
(0.5 1 0)<br/>
(1 1 0)<br/>
(0 0 0.5)<br/>
(0.5 0 0.5)<br/>
(1 0 0.5)<br/>
(0 0.5 0.5)<br/>
(0.5 0.5 0.5)<br/>
(1 0.5 0.5)<br/>
(0 1 0.5)<br/>
(0.5 1 0.5)<br/>
(1 1 0.5)<br/>
(0 0 1)<br/>
(0.5 0 1)<br/>
(1 0 1)<br/>
(0 0.5 1)<br/>
(0.5 0.5 1)<br/>
(1 0.5 1)<br/>
(0 1 1)<br/>
(0.5 1 1)<br/>
(1 1 1)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>./CppOpenFoam/points_3x4x5</h2>
<p>&nbsp;</p>
<!-- start of code -->
<table summary="./CppOpenFoam/points_3x4x5" border = "1"><tr><td><code>
/*--------------------------------*- C++ -*----------------------------------*\<br/>
| =========&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
| \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;F ield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | OpenFOAM: The Open Source CFD Toolbox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp; O peration&nbsp;&nbsp;&nbsp;&nbsp; | Version:&nbsp;&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
|&nbsp;&nbsp; \\&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;A nd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Web:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.OpenFOAM.org&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>
|&nbsp;&nbsp;&nbsp;&nbsp;\\/&nbsp;&nbsp;&nbsp;&nbsp; M anipulation&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
/*&nbsp;&nbsp; Windows 32 and 64 bit porting by blueCAPE: http://www.bluecape.com.pt&nbsp;&nbsp; *\<br/>
|&nbsp;&nbsp;Based on Windows porting (2.0.x v4) by Symscape: http://www.symscape.com&nbsp;&nbsp; |<br/>
\*---------------------------------------------------------------------------*/<br/>
FoamFile<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp; 2.0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vectorField;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;&nbsp;&nbsp;&nbsp;"constant/polyMesh";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points;<br/>
}<br/>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //<br/>
<br/>
<br/>
120<br/>
(<br/>
(0 0 0)<br/>
(0.3333333333 0 0)<br/>
(0.6666666667 0 0)<br/>
(1 0 0)<br/>
(0 0.25 0)<br/>
(0.3333333333 0.25 0)<br/>
(0.6666666667 0.25 0)<br/>
(1 0.25 0)<br/>
(0 0.5 0)<br/>
(0.3333333333 0.5 0)<br/>
(0.6666666667 0.5 0)<br/>
(1 0.5 0)<br/>
(0 0.75 0)<br/>
(0.3333333333 0.75 0)<br/>
(0.6666666667 0.75 0)<br/>
(1 0.75 0)<br/>
(0 1 0)<br/>
(0.3333333333 1 0)<br/>
(0.6666666667 1 0)<br/>
(1 1 0)<br/>
(0 0 0.2)<br/>
(0.3333333333 0 0.2)<br/>
(0.6666666667 0 0.2)<br/>
(1 0 0.2)<br/>
(0 0.25 0.2)<br/>
(0.3333333333 0.25 0.2)<br/>
(0.6666666667 0.25 0.2)<br/>
(1 0.25 0.2)<br/>
(0 0.5 0.2)<br/>
(0.3333333333 0.5 0.2)<br/>
(0.6666666667 0.5 0.2)<br/>
(1 0.5 0.2)<br/>
(0 0.75 0.2)<br/>
(0.3333333333 0.75 0.2)<br/>
(0.6666666667 0.75 0.2)<br/>
(1 0.75 0.2)<br/>
(0 1 0.2)<br/>
(0.3333333333 1 0.2)<br/>
(0.6666666667 1 0.2)<br/>
(1 1 0.2)<br/>
(0 0 0.4)<br/>
(0.3333333333 0 0.4)<br/>
(0.6666666667 0 0.4)<br/>
(1 0 0.4)<br/>
(0 0.25 0.4)<br/>
(0.3333333333 0.25 0.4)<br/>
(0.6666666667 0.25 0.4)<br/>
(1 0.25 0.4)<br/>
(0 0.5 0.4)<br/>
(0.3333333333 0.5 0.4)<br/>
(0.6666666667 0.5 0.4)<br/>
(1 0.5 0.4)<br/>
(0 0.75 0.4)<br/>
(0.3333333333 0.75 0.4)<br/>
(0.6666666667 0.75 0.4)<br/>
(1 0.75 0.4)<br/>
(0 1 0.4)<br/>
(0.3333333333 1 0.4)<br/>
(0.6666666667 1 0.4)<br/>
(1 1 0.4)<br/>
(0 0 0.6)<br/>
(0.3333333333 0 0.6)<br/>
(0.6666666667 0 0.6)<br/>
(1 0 0.6)<br/>
(0 0.25 0.6)<br/>
(0.3333333333 0.25 0.6)<br/>
(0.6666666667 0.25 0.6)<br/>
(1 0.25 0.6)<br/>
(0 0.5 0.6)<br/>
(0.3333333333 0.5 0.6)<br/>
(0.6666666667 0.5 0.6)<br/>
(1 0.5 0.6)<br/>
(0 0.75 0.6)<br/>
(0.3333333333 0.75 0.6)<br/>
(0.6666666667 0.75 0.6)<br/>
(1 0.75 0.6)<br/>
(0 1 0.6)<br/>
(0.3333333333 1 0.6)<br/>
(0.6666666667 1 0.6)<br/>
(1 1 0.6)<br/>
(0 0 0.8)<br/>
(0.3333333333 0 0.8)<br/>
(0.6666666667 0 0.8)<br/>
(1 0 0.8)<br/>
(0 0.25 0.8)<br/>
(0.3333333333 0.25 0.8)<br/>
(0.6666666667 0.25 0.8)<br/>
(1 0.25 0.8)<br/>
(0 0.5 0.8)<br/>
(0.3333333333 0.5 0.8)<br/>
(0.6666666667 0.5 0.8)<br/>
(1 0.5 0.8)<br/>
(0 0.75 0.8)<br/>
(0.3333333333 0.75 0.8)<br/>
(0.6666666667 0.75 0.8)<br/>
(1 0.75 0.8)<br/>
(0 1 0.8)<br/>
(0.3333333333 1 0.8)<br/>
(0.6666666667 1 0.8)<br/>
(1 1 0.8)<br/>
(0 0 1)<br/>
(0.3333333333 0 1)<br/>
(0.6666666667 0 1)<br/>
(1 0 1)<br/>
(0 0.25 1)<br/>
(0.3333333333 0.25 1)<br/>
(0.6666666667 0.25 1)<br/>
(1 0.25 1)<br/>
(0 0.5 1)<br/>
(0.3333333333 0.5 1)<br/>
(0.6666666667 0.5 1)<br/>
(1 0.5 1)<br/>
(0 0.75 1)<br/>
(0.3333333333 0.75 1)<br/>
(0.6666666667 0.75 1)<br/>
(1 0.75 1)<br/>
(0 1 1)<br/>
(0.3333333333 1 1)<br/>
(0.6666666667 1 1)<br/>
(1 1 1)<br/>
)<br/>
<br/>
<br/>
// ************************************************************************* //<br/>
</code></td></tr></table>
<!-- end of the code -->
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="Cpp.htm">Go back to Richel Bilderbeek's C++ page</a>.</p>
<p><a href="index.htm">Go back to Richel Bilderbeek's homepage</a>.</p>
<p>&nbsp;</p>
<p><a href="http://validator.w3.org/check?uri=referer"><img src="valid-xhtml10.png" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></p>
<p>This page has been created by the <a href="Tools.htm">tool</a> <a href="ToolCodeToHtml.htm">CodeToHtml</a></p>
</body>
</html>
